{
  "data": [
    {
      "_id": "5b049cc861d83561035ea0f11c262ec1",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "## 实现路由跳转\n\n实现了与`react-router-dom`的`5.x`版本相同的用法，包括`BrowserRouter`、`Link`、`Switch`、`Route`等组件，基本用法如下代码所示：\n\n```html\n<Router>\n    <div>\n        <Link to=\"/a\">组件A</Link>\n        <Link to=\"/b\">组件B</Link>\n        <Link to=\"/a/c\">组件C</Link>\n    </div>\n    <Switch>\n        <Route path=\"/a\" component={A} />\n        <Route path=\"/b\" component={B} />\n        <Route path=\"/a/c\" component={C} />\n    </Switch>\n</Router>\n```\n\n![](https://img.lzxjack.top:99/20220107194142.gif)\n\n## BrowserRouter\n\n`BrowserRouter`组件需要将全部的组件包起来，利用`context`提供`history`对象和`location`对象。其中，`history`对象由`createBrowserHistory()`提供，`location`对象初始值是`window.location`。\n\n`history.listen()`用于监听`location`的变化，当其发生变化时，更新`state`中的`location`。\n\n```jsx\nimport { createContext, useState, useEffect } from 'react';\nimport { createBrowserHistory } from 'history';\n\nconst history = createBrowserHistory();\nexport const RouterContext = createContext();\n\nconst BrowserRouter = ({ children }) => {\n    const [location, setLocation] = useState(window.location);\n    useEffect(() => {\n        // 监听路由变化\n        const unlisten = history.listen(({ location: loc }) => {\n            setLocation(loc);\n        });\n        return () => {\n            unlisten && unlisten();\n        };\n    }, []);\n    return (\n        <RouterContext.Provider value={{ history, location }}>{children}</RouterContext.Provider>\n    );\n};\n\nexport default BrowserRouter;\n```\n\n## Link\n\n`Link`组件里实际上是`a`链接。但点击路由时，实际上是不发生跳转的，所以在`onClick`事件里阻止了`a`链接跳转的默认行为。并且利用`history.push()`将当前的`location`推入`history`栈中，触发`BrowserRouter`中的监听器，更新`state`中的`location`。此时`window.location`也将更新，`url`会发生变化。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst style = {\n    border: '2px solid blue',\n    padding: '10px',\n    margin: '20px',\n    textDecoration: 'none',\n};\n\nconst Link = ({ to, children }) => {\n    const { history } = useContext(RouterContext);\n    return (\n        <a\n            href={to}\n            style={style}\n            onClick={e => {\n                e.preventDefault();\n                history.push(to);\n            }}\n        >\n            {children}\n        </a>\n    );\n};\n\nexport default Link;\n```\n\n## Switch\n\n`Switch`组件将一系列`Route`组件包起来。若包含多个`Route`组件，则`children`是数组；若只有一个`Route`，`children`是单个元素，故进行判断，确保转化为数组。\n\n将`state`中`location.pathname`与包含的`Route`组件`path`进行对比，只渲染匹配上的`Route`。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Switch = ({ children }) => {\n    const { location } = useContext(RouterContext);\n    const routes = Array.isArray(children) ? children : [children];\n    return (\n        <>\n            {routes.map(child => {\n                const {\n                    props: { path },\n                } = child;\n                if (location.pathname === path) return child;\n                return null;\n            })}\n        </>\n    );\n};\n\nexport default Switch;\n```\n\n## Route\n\n将`state`中`location.pathname`与当前`Route`的`path`进行对比，若匹配上，则渲染传入的组件。\n\n```jsx\nimport { createElement, useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Route = ({ path, component }) => {\n    const { location } = useContext(RouterContext);\n    return <>{location.pathname === path ? createElement(component) : null}</>;\n};\n\nexport default Route;\n```\n\n## 源码\n\n<a href=\"https://github.com/lzxjack/mini-react-router\" target=\"_blank\">「GitHub」</a>\n\n\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      "date": 1641559368000,
      "post": true,
      "tags": ["JavaScript", "React"],
      "title": "mini-react-router 实现核心路由跳转功能",
      "titleEng": "mini-react-router",
      "url": "https://lzxjack.top/post?title=mini-react-router"
    },
    {
      "_id": "bf4a0bf261d3e6ed028d74443e6edd46",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 手撕代码",
      "content": "## 题目要求\n\n最近遇到了一个 JavaScript 手写代码题，要求实现一个具有并发数量限制的异步任务调度器，可以规定最大同时运行的任务。\n\n实现一个`Scheduler`类，使下面的代码能正确输出。\n\n```javascript\n// 延迟函数\nconst sleep = time => new Promise(resolve => setTimeout(resolve, time));\n\n// 同时进行的任务最多2个\nconst scheduler = new Scheduler(2);\n\n// 添加异步任务\n// time: 任务执行的时间\n// val: 参数\nconst addTask = (time, val) => {\n    scheduler.add(() => {\n        return sleep(time).then(() => console.log(val));\n    });\n};\n\naddTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');\n// 2\n// 3\n// 1\n// 4\n```\n\n## 思路及实现\n\n设计`Scheduler`类，要具有**并发数量限制**功能，需要定义最大可并发任务数`max`，从入参中获取。并定义当前并发任务数`count`，表示正在执行的任务数量。另外，定义一个待执行的任务队列`queue`。\n\n在添加任务`add`函数中，首先判断当前正在执行的任务数，若当前正在执行的任务数达到最大容量`max`，则当前的任务需要**阻塞在此处**。具体做法为，`new`一个`Promise`对象，将`resolve`函数的引用推入队列`queue`中。只要`resolve`函数没有被执行，当前任务就会一直阻塞在这里。\n\n若当前正在执行的任务数没有达到最大容量，那么对`count`进行加一，执行当前函数`fn`，并拿到返回值`res`，执行完毕后`count`减一。此时若队列`queue`中有值，说明之前有任务因为并发数量限制而被阻塞，将队头的`resolve`弹出，并执行。执行`resolve`之后，之前阻塞的任务就可以正常执行了。\n\n最后返回`fn`函数执行的结果`res`。\n\n具体代码如下：\n\n```javascript\nclass Scheduler {\n    constructor(max) {\n        // 最大可并发任务数\n        this.max = max;\n        // 当前并发任务数\n        this.count = 0;\n        // 阻塞的任务队列\n        this.queue = [];\n    }\n\n    async add(fn) {\n        if (this.count >= this.max) {\n            // 若当前正在执行的任务，达到最大容量max\n            // 阻塞在此处，等待前面的任务执行完毕后将resolve弹出并执行\n            await new Promise(resolve => this.queue.push(resolve));\n        }\n        // 当前并发任务数++\n        this.count++;\n        // 使用await执行此函数\n        const res = await fn();\n        // 执行完毕，当前并发任务数--\n        this.count--;\n        // 若队列中有值，将其resolve弹出，并执行\n        // 以便阻塞的任务，可以正常执行\n        this.queue.length && this.queue.shift()();\n        // 返回函数执行的结果\n        return res;\n    }\n}\n```\n\n## 测试\n\n```javascript\nclass Scheduler {\n\t...\n}\n\nconst sleep = time => new Promise(resolve => setTimeout(resolve, time));\n\nconst scheduler = new Scheduler(2);\n\nconst addTask = (time, val) => {\n    scheduler.add(() => {\n        return sleep(time).then(() => console.log(val));\n    });\n};\n\naddTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');\n// 2\n// 3\n// 1\n// 4\n```\n\n如上代码所示，并发任务数量最大为`2`。添加了`4`个异步任务，所需要执行的时间分别为`1000 ms`、`500 ms`、`300 ms`、`400 ms`。\n\n由于并发任务数量最大为`2`，最初执行任务`1`和`2`。任务`2`经过`500 ms`后执行完毕，输出`'2'`。接着执行任务`3`，又经过`300 ms`后，输出`'3'`。任务`1`仍然在执行，任务`4`开始执行。到了`1000 ms`时刻，任务`1`执行完毕，输出`'1'`。最后任务`4`执行完，输出`'4'`。\n\n符合并发数量限制，达到了设计要求。\n\n将执行过程表示在时间轴上，如下图所示：\n\n![](https://img.lzxjack.top:99/20220104141707.png)\n\n\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      "date": 1641277083000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 实现异步任务调度器",
      "titleEng": "async-scheduler",
      "url": "https://lzxjack.top/post?title=async-scheduler"
    },
    {
      "_id": "d20aea5861baf776006fa3c406f99c6b",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "JavaScript 中的基本数据类型包括：`String`、`Number`、`Boolean`、`null`、`undefined`、`BigInt`，其中`null`和`undefined`都表示“无”这层含义，一般情况下，两者几乎没有区别。\n\n## 相似之处\n\n在全局定义两个变量，一个是`null`，另一个是`undefined`，最终他们都被挂载到**全局对象**上了，且值都为`undefined`：\n\n```javascript\nvar a = null;\nvar b = undefined;\n\nconsole.log(global.a, global.b); // undefined undefined\n```\n\n这说明，`null`不是全局对象的一个属性。\n\n另外，在`if`语句中，`null`和`undefined`都会被认为是`false`：\n\n```javascript\nvar a = null;\nvar b = undefined;\n\nif (!a) {\n    console.log(a); // null\n}\n\nif (!b) {\n    console.log(b); // undefined\n}\n```\n\n也就是说，在具有类型转换的场景中，`null`和`undefined`都会被转化为`false`：\n\n```javascript\nconsole.log(!!null); // false\nconsole.log(!!undefined); // false\n```\n\n如下代码，用`==`判断`null`和`undefined`，结果为`true`，~~这是因为它们都被转化为了布尔值的`false`，~~这是因为它们都表示**无效的值**，所以 JavaScript 规范规定了`null`和`undefined`是相等的，并不能用转换数据类型来解释。\n\n```javascript\nconsole.log(null == undefined); // true\n```\n\n而使用`===`判断时，由于它们属于**不同的数据类型**，则直接会返回`false`：\n\n```javascript\nconsole.log(null === undefined); // false\n```\n\n## 不同点\n\n### null\n\n`null`表示一个值被定义了，但定义的是**空值**。\n\n以下是`null`的经典用法。\n\n（1）作为函数的参数，表示不传入此参数。\n\n```javascript\nconst test = (a, b) => {\n    console.log(b);\n};\n\ntest(null, 2); // 2\n```\n\n（2）作为原型链的终点。\n\n```javascript\nconsole.log(Object.prototype.__proto__); // null\n```\n\n### undefined\n\n`undefined`表示**根本不存在定义**。\n\n以下是`undefined`的经典用法。\n\n（1）变量被声明，但还没有赋值，此时的变量等于`undefined`。\n\n```javascript\nlet a;\nconsole.log(a); // undefined\n```\n\n（2）调用函数时，应该传入的参数未传入，则该参数为`undefined`。\n\n```javascript\nconst test = a => {\n    console.log(a);\n};\n\ntest(); // undefined\n```\n\n（3）对象没有定义的属性，该属性为`undefined`。\n\n```javascript\nconst obj = {};\n\nconsole.log(obj.a); // undefined\n\n// 注意，在未定义的属性上，继续读取属性会报错\nconsole.log(obj.a.b); // TypeError: Cannot read property 'b' of undefined\n```\n\n（4）不在数组索引范围的值，为`undefined`。\n\n```javascript\nconst arr = [1];\n\nconsole.log(arr[100]); // undefined\n```\n\n（5）函数没有返回值时，默认返回的是`undefined`。\n\n```javascript\nconst test = () => {};\n\nconsole.log(test()); // undefined\n```\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      "date": 1639642896000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 中null和undefined的区别",
      "titleEng": "null-undefined",
      "url": "https://lzxjack.top/post?title=null-undefined"
    },
    {
      "_id": "b8f1ea0261b9e9730054d6a43623d397",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "在 React 中，可以使用`useMemo`和`useCallback`来优化**无用渲染**的性能问题。本文是自己学习`useMemo`和`useCallback`的笔记，介绍了它们的**使用场景**和**区别**。\n\n## useMemo\n\n`useMemo`用来缓存**值**，保存每次渲染时，不会发生变化的值，减少计算。在一些开销较大**且**值不会变的场景下特别有用。\n\n如下代码所示，定义了两个状态`max`和`count`，在页面上显示当前`max`和`count`的值，并可以点击按钮增加`max`和`count`的值。\n\n定义了一个函数`getSum`求`0~max`的和，模拟一个开销大的操作，将求和的结果显示在页面上。但是这个求和的操作只依赖于`max`这个`state`，与其他值无关。\n\n```jsx\nimport { useState } from 'react';\n\nconst A = () => {\n    const [max, setMax] = useState(100);\n    const [count, setCount] = useState(0);\n\n    // 模拟一个开销大的操作\n    const getSum = () => {\n        console.log('sum被重新计算了');\n        let sum = 0;\n        for (let i = 0; i <= max; i++) {\n            sum += i;\n        }\n        return sum;\n    };\n\n    return (\n        <>\n            <div>sum：{getSum()}</div>\n            <div>\n                max：{max} <button onClick={() => setMax(max => max + 1)}>max++</button>\n            </div>\n            <div>\n                count：{count}\n                <button onClick={() => setCount(count => count + 1)}>count++</button>\n            </div>\n        </>\n    );\n};\n\nexport default A;\n```\n\n更改`count`的值，求和结果`sum`并不会发生变化，因为求和的操作只依赖于`max`。若不使用`useMemo`进行优化，如下图所示，每次更改`count`的值，都会重新调用一次`getSum`函数，每次都进行了一次**不必要**的操作。\n\n![](https://img.lzxjack.top:99/20211215202738.gif)\n\n可以使用`useMemo`进行优化，如下代码所示，使用`useMemo`将函数包裹起来，并在`useMemo`的第二个参数中，写上`max`这个依赖项，表示只有当`max`发生变化时，才重新调用一次`getSum`函数，**否则就使用上一次计算的值**。\n\n```jsx\nimport { useState, useMemo } from 'react';\n\nconst A = () => {\n    const [max, setMax] = useState(100);\n    const [count, setCount] = useState(0);\n\n    // 模拟一个开销大的操作\n    const getSum = useMemo(() => {\n        console.log('sum被重新计算了');\n        let sum = 0;\n        for (let i = 0; i <= max; i++) {\n            sum += i;\n        }\n        return sum;\n        // 写上依赖项，只有当max发生变化时，才重新计算一次\n    }, [max]);\n\n    return (\n        <>\n            {/* 注意这里的写法 */}\n            <div>sum：{getSum}</div>\n            <div>\n                max：{max} <button onClick={() => setMax(max => max + 1)}>max++</button>\n            </div>\n            <div>\n                count：{count}\n                <button onClick={() => setCount(count => count + 1)}>count++</button>\n            </div>\n        </>\n    );\n};\n\nexport default A;\n```\n\n结果如下图所示，更新`count`时，并不会重新调用`getSum`。只有`max`变化时，才会重新调用`getSum`，减少了不必要的函数调用和渲染，实现了优化。\n\n![](https://img.lzxjack.top:99/20211215202814.gif)\n\n> 注意：\n>\n> - `useMemo`会返回一个值，所以写的是`<div>sum：{getSum}</div>`而不是`<div>sum：{getSum()}</div>`，不用自己调用，体会下这里的区别。\n> - 传入`useMemo`的函数会在**渲染期间**执行，不要在这个函数内部执行与渲染无关的操作。这里只是为了演示，在函数内执行了`console.log()`。\n> - 不要忘记写正确的依赖数组。若没有提供依赖数组，`useMemo`在每次渲染时都会计算新的值。\n\n## useCallback\n\n`useCallback`用来缓存**函数**。通常用于父子组件中，父组件传给子组件一个函数，父组件更新时，传递给子组件的函数也会被重新创建。有时候传递给子组件的函数**没必要**重新创建，`useCallback`就可以缓存这个函数，**不使这个函数重新被创建**。\n\n如下代码所示，父组件`A`内部创建了`num`和`count`两个变量，显示在页面上，并可以更新它们的值。创建了一个函数`getCount`，返回`count`的值。父组件`A`向子组件`B`传递`getCount`这个函数。\n\n子组件`B`拿到`getCount`函数后，调用并将`count`值显示在页面上。为了演示每次更新时，`getCount`是否被重新创建，这里使用了`Set`这个数据结构。在`B`组件内部将`getCount`函数的**引用**存入`Set`，并显示`Set`的长度，**长度增加**则说明`getCount`函数被重新创建了。\n\n```jsx\nimport { useState } from 'react';\n\nconst set = new Set();\n\nconst A = () => {\n    const [num, setNum] = useState(0);\n    const [count, setCount] = useState(0);\n\n    const getCount = () => count;\n\n    return (\n        <>\n            <B getCount={getCount} />\n            <div>\n                count：{count}\n                <button onClick={() => setCount(count => count + 1)}>count++</button>\n            </div>\n            <div>\n                num：{num}\n                <button onClick={() => setNum(num => num + 1)}>num++</button>\n            </div>\n        </>\n    );\n};\n\nconst B = ({ getCount }) => {\n    set.add(getCount);\n    return (\n        <>\n            <div>count：{getCount()}</div>\n            <div>集合内元素数量：{set.size}</div>\n        </>\n    );\n};\n\nexport default A;\n```\n\n结果如下图所示，当`num`发生变化时，触发父组件`A`更新，传递给`B`的`getCount`函数也被重新创建了。然而`getCount`函数返回的是`count`，`num`发生变化没必要再重新创建一次`getCount`函数，这造成了性能的浪费。\n\n![](https://img.lzxjack.top:99/20211215202316.gif)\n\n可以使用`useCallback`进行性能优化，在创建`getCount`函数时，使用`useCallback`包裹，并写上依赖数组`[count]`，表示只有当`count`变化时，才重新创建一次`getCount`函数。\n\n```jsx\nimport { useState, useCallback } from 'react';\n\nconst set = new Set();\n\nconst A = () => {\n    const [num, setNum] = useState(0);\n    const [count, setCount] = useState(0);\n\n    const getCount = useCallback(() => count, [count]);\n\n    return (\n        <>\n            <B getCount={getCount} />\n            <div>\n                count：{count}\n                <button onClick={() => setCount(count => count + 1)}>count++</button>\n            </div>\n            <div>\n                num：{num}\n                <button onClick={() => setNum(num => num + 1)}>num++</button>\n            </div>\n        </>\n    );\n};\n\nconst B = ({ getCount }) => {\n    set.add(getCount);\n    return (\n        <>\n            <div>count：{getCount()}</div>\n            <div>集合内元素数量：{set.size}</div>\n        </>\n    );\n};\n\nexport default A;\n```\n\n结果如下图所示，`count`更新时，传递给`B`组件的`getCount`函数被重新创建。而`num`更新时，`getCount`函数不会被重新创建，这减少了不必要的创建函数开销，实现了优化。\n\n![](https://img.lzxjack.top:99/20211215202441.gif)\n\n> 注意：\n>\n> - 因为`useCallback`返回的是一个**函数**，所以页面上还是要写`<div>count：{getCount()}</div>`，需要自己调用。体会一下与`useMemo`的区别。\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      "date": 1639573723000,
      "post": true,
      "tags": ["React", "性能优化"],
      "title": "React 性能优化方法useMemo、useCallback",
      "titleEng": "react-mm-cb",
      "url": "https://lzxjack.top/post?title=react-mm-cb"
    },
    {
      "_id": "859059a5619f83880819c13170ce071e",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "> 本文是自己学习`useContext`的笔记。\n\n## 两组件通信\n\nReact 中，**父子组件**需要通信时，父组件可以将参数写在`props`中传递给子组件，实现父组件向子组件通信；父组件还可以传递一个函数给子组件，子组件调用这个函数，实现子组件向父组件的通信。这就完成了父子组件的相互通信。\n\n但当组件嵌套关系复杂的时候，如下图所示，`A`组件下有`B`组件和`C`组件，`B`组件下有`D`组件，`C`组件下有`E`组件。\n\n![](https://img.lzxjack.top:99/20211124190709.png)\n\n当需要在`A`组件和`D`组件之间通信时，也可以采取上述的方法，`A`通过`props`一层一层传递参数到`D`组件，`D`组件再调用函数，一层一层返回到`A`组件。\n\n## Context\n\n但当组件嵌套关系更复杂时，这样的方式极其繁琐，且不易维护。这里介绍一种使用`Context`实现组件通信的方式。\n\n> Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。\n\n使用`Context`，可以避免通过中间组件传递`props`。有的时候在组件树中很多不同层级的组件需要访问**同一批数据**。`Context`能让你将这些数据向组件树下所有的组件进行**广播**，所有的组件都能访问到这些数据，也能访问到后续的数据更新。\n\n## useContext 实践\n\n首先实现上述关系的组件：\n\n![](https://img.lzxjack.top:99/20211124192026.png)\n\n要实现的效果为，`E`组件中点击`add`，会增加计数值。点击`D`组件的`clear`按钮，会对`E`组件的计数值进行**清零**。\n\n![](https://img.lzxjack.top:99/20211124192259.png)\n\n`A`组件中，需要从`react`中导入`createContext`方法，在组件外部创建Context对象，并导出。同时，需要用`<MyContext.Provider></MyContext.Provider>`进行包裹，其中，`MyContext`是自定义的名称。**数据对象**放在`<MyContext.Provider>`的`value`中。这样，被包裹的所有组件，都能直接拿到这两个参数了。\n\n```javascript\nimport { createContext, useState } from 'react';\nimport B from './B';\nimport C from './C';\nimport './index.css';\n\n// 在组件外部创建Context对象，并导出\nexport const MyContext = createContext();\n\nconst A = () => {\n    const [count, setCount] = useState(0);\n    return (\n        // 数据对象放在value中，向下传递\n        <MyContext.Provider value={{ count, setCount }}>\n            A组件\n            <B />\n            <C />\n        </MyContext.Provider>\n    );\n};\n\nexport default A;\n```\n\n`E`组件需要从`A`中引入创建的`context`对象`MyContext`，并使用`useContext`方法，从`MyContext`中拿到其中的参数。\n\n```javascript\n// 引入创建的context\nimport { MyContext } from './A';\nimport { useContext } from 'react';\n\nconst E = () => {\n    // 拿到两个参数\n    const { count, setCount } = useContext(MyContext);\n\n    return (\n        <div>\n            我是E, 计数值：{count}\n            <button onClick={() => setCount(count => count + 1)}>add</button>\n        </div>\n    );\n};\n\nexport default E;\n```\n\n`D`组件也需要从`A`中引入创建的`context`对象`MyContext`，使用`useContext`方法，拿到`setCount`方法。\n\n```javascript\n// 引入创建的context\nimport { MyContext } from './A';\nimport { useContext } from 'react';\n\nconst D = () => {\n    // 拿到参数\n    const { setCount } = useContext(MyContext);\n\n    return (\n        <div>\n            我是D\n            <button onClick={() => setCount(0)}>clear</button>\n        </div>\n    );\n};\n\nexport default D;\n```\n\n这样，`E`组件和`D`组件使用的是同一批数据，也能**访问到这些数据的更新**，实现了跨组件通信。\n\n![](https://img.lzxjack.top:99/20211124200443.gif)\n\n## 集中式管理 Context 对象\n\n如果一个项目中，多处使用`context`，会造成代码结构不清晰，不便于维护。这时可以将所有创建`context`的代码，放入到专门的文件中，进行集中管理，需要用到的地方，都从此文件引入即可。\n\n例如，将创建的所有`Context`对象放入`contextManager.js`中，并导出：\n\n```javascript\n// contextManager.js\n\nimport { createContext } from 'react';\n\nexport const MyContext = createContext();\n\n// 定义的其他context\nexport const MyContext2 = createContext();\nexport const MyContext3 = createContext();\n```\n\n",
      "date": 1637843802000,
      "post": true,
      "tags": ["React", "JavaScript"],
      "title": "React 利用Context实现组件通信",
      "titleEng": "react-context",
      "url": "https://lzxjack.top/post?title=react-context"
    },
    {
      "_id": "18ed0968619e2d350719d6775ebf93b0",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "## 两组件通信\n\n在 React 中，组件之间的通信方式有很多。例如在**父子组件**中，父组件向子组件通信时，可以将参数写在`props`传递给子组件；子组件向父组件通信时，可以使用回调函数的方式，父组件传递给子组件一个**函数**，子组件通过调用这个函数，实现向父组件通信。父子组件通信，<a href=\"https://lzxjack.top/post?title=react-father-son\" target=\"_blank\">具体看这里</a>。\n\n但是，假如有这样一些组件，`A`组件下有`B`组件和`C`组件，`B`组件下有`D`组件，`C`组件下有`E`组件，如图所示：\n\n![](https://img.lzxjack.top:99/20211124190709.png)\n\n如果需要`D`组件向E组件通信，即`D`组件向`E`组件传值，可以将**状态**定义在公共的父组件`A`上，分别向`B`、`C`组件传递参数和函数，再依次传递给`D`组件和`E`组件。`D`组件可以调用函数，改变`A`中的状态，同时也就会改变了`E`组件的`props`，实现了`D`组件向`E`组件的通信。这种方式实现起来可行，但太过于繁琐，如果组件嵌套得更深，代码将难以维护。\n\n另一种思路是可以将状态定义在`redux`中，统一管理。`E`组件使用`redux`中的值，`D`组件改变`redux`中的值。**但需求仅仅是实现`D`组件向`E`组件传值，就引入了`redux`，显得没那么必要。**\n\n还有一种解决方案，即使用**消息订阅与发布机制**，主要实现步骤：要实现`D`组件向`E`组件传值，在`E`组件中，订阅消息，在`D`组件中，发布相应的消息，`E`组件中就会得到相应的数据。这种方式适合任意关系组件的通信。下面是 React 中**消息订阅与发布机制**的具体实现。\n\n### 消息订阅与发布机制\n\n#### 订阅消息\n\n```javascript\n// 创建订阅的回调函数\nvar mySubscriber = function (msg, data) {\n    console.log(msg, data);\n};\n\n// 订阅\nvar token = PubSub.subscribe('MY TOPIC', mySubscriber);\n```\n\n通过`PubSub.subscribe()`订阅消息，第一个参数为订阅的**消息名称**，可以自定义。第二个参数为订阅的回调函数，这个回调函数有两个参数。回调函数的第一个参数`msg`是订阅的消息名称，第二个参数`data`是传递过来的数据。\n\n#### 发布消息\n\n```javascript\n// 发布\nPubSub.publish('MY TOPIC', 'hello world!');\n```\n\n通过`PubSub.publish()`发布消息，第一个参数为发布的**消息名称**，第二个参数为发布消息的数据，可以是对象、字符串、数字等类型。\n\n如果有人订阅了这个**消息名称**，当消息发布成功时，发布消息的**数据**就会被传到上述**订阅消息的回调函数**中，并被执行，拿到这个数据。\n\n#### 取消订阅\n\n```javascript\nPubSub.unsubscribe(token);\n```\n\n记得要在合适的时间**取消订阅**。\n\n### React 实现\n\n首先需要安装模块：\n\n```powershell\nyarn add pubsub-js\n```\n\n实现上述关系的组件：\n\n![](https://img.lzxjack.top:99/20211124192026.png)\n\n要实现的效果为，`E`组件中点击`add`，会增加计数值。点击`D`组件的`clear`按钮，会对`E`组件的计数值进行**清零**。\n\n![](https://img.lzxjack.top:99/20211124192259.png)\n\n首先在`E`组件中引入`pubsub-js`，并在`useEffect`中订阅**清零消息**，组件卸载时清除副作用，**取消订阅**。\n\n```javascript\nimport PubSub from 'pubsub-js';\nimport { useState, useEffect } from 'react';\n\nconst E = () => {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n        // 订阅清零消息\n        const mySub = PubSub.subscribe('clearCount', clear);\n        return () => {\n            // 取消订阅\n            PubSub.unsubscribe(mySub);\n        };\n    }, []);\n\n    const clear = (msgName, data) => {\n        // msgName是订阅的消息名称\n        // data是发布消息时，传递的参数\n        // 这里我传递过来的是一个对象\n        console.log(msgName, data); // clearCount {count: 0}\n        const { count } = data;\n        setCount(count);\n    };\n\n    return (\n        <div>\n            我是E, 计数值：{count}\n            <button onClick={() => setCount(count => count + 1)}>add</button>\n        </div>\n    );\n};\n\nexport default E;\n```\n\n`D`组件中，点击`clear`发布消息，传递一个对象：\n\n```javascript\nimport PubSub from 'pubsub-js';\n\nconst D = () => {\n    const pubsub = () => {\n        // 发布消息\n        // 第一个参数为消息名称，clearCount\n        // 第二个参数为传递的参数，这里我传递一个对象\n        PubSub.publish('clearCount', { count: 0 });\n    };\n\n    return (\n        <div>\n            我是D\n            <button onClick={pubsub}>clear</button>\n        </div>\n    );\n};\n\nexport default D;\n```\n\n如上代码所示，在`D`组件中点击`clear`按钮，就发布一条清零消息`clearCount`，并传递一个对象，里面包含了`count`值。在`E`组件中，由于订阅过清零消息`clearCount`，所以会执行回调函数，在回调函数的第二个参数`data`中，拿到`D`组件传递过来的`count`值，并执行`setCount(count)`，完成清零。\n\n这样就实现了`D`组件向`E`组件通信，总体思路，`D`组件发布消息并传递参数，`E`组件拿到参数，执行相应的操作。\n\n实现效果：\n\n![](https://img.lzxjack.top:99/20211124200443.gif)",
      "date": 1637756154000,
      "post": true,
      "tags": ["React", "PubSub"],
      "title": "React 利用消息订阅与发布机制实现组件通信",
      "titleEng": "react-pubsub",
      "url": "https://lzxjack.top/post?title=react-pubsub"
    },
    {
      "_id": "fa24ce1a618e8f100608abec0371156f",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "## 1. Promise\n\n异步函数，即`async / await`，是基于`Promise`的应用，可以让我们以同步的方式写异步的代码。\n\n如下代码，一个使用`Promise`的简单例子，`Promise`对象中的函数参数中，写了一个定时器`setTimeout`。定时器的第三个参数为`10`，表示定时器结束后，`10`将作为参数，传递给定时器的回调函数`resolve`。这就意味着，定时器结束后，这个`Promise`对象会解决为数值`10`。\n\n```javascript\nconst p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 10));\n```\n\n但是，如果访问到这个数值`10`，需要调用`then()`方法：\n\n```javascript\np.then(x => console.log(x)); // 10\n```\n\n这非常不方便，虽然解决了回调地域问题，但是后续代码必须要放在`then()`方法里面。\n\n在 ES8 中，JavaScript 支持了`async / await`关键字，可以用同步的方式，写异步代码。\n\n## 2. async 关键字\n\n`async`关键字用来声明异步函数，可以在函数声明、函数表达式、箭头函数、方法前声明使用：\n\n```javascript\n// 函数声明\nasync function fun1() {}\n\n// 函数表达式\nconst fun2 = async function () {};\n\n// 箭头函数\nconst fun3 = async () => {};\n\n// 方法\nconst obj = {\n    async fun4() {},\n};\n```\n\n使用`async`关键字可以让函数具有**异步**的特征，但代码还是同步求值的：\n\n```javascript\nasync function fun() {\n    console.log(1);\n}\n\nfun();\nconsole.log(2);\n// 1\n// 2\n```\n\n如上代码，`fun`函数被声明成异步函数，但总体代码仍然是同步执行的，因为先打印出了`1`，再打印`2`。\n\n另外，被`async`声明的函数如果使用`return`返回了值（若没有`return`，则返回`undefined`），那么返回的值会被`Promise.resolve()`包装成一个`Promise`对象。所以，异步函数始终会返回`Promise`对象。\n\n如下代码，调用`fun`函数，`fun`函数内部首先打印出`1`，接着返回`Promise`对象，然后打印出`2`，最后打印出`Promise`对象解决的值`3`。\n\n```javascript\nasync function fun() {\n    console.log(1);\n    return 3;\n}\n\nfun().then(console.log);\n\nconsole.log(2);\n// 1\n// 2\n// 3\n```\n\n异步函数内部直接返回一个`Promise`对象也能达到同样效果，如下代码等价于上面的代码：\n\n```javascript\nasync function fun() {\n    console.log(1);\n    return Promise.resolve(3);\n}\n\nfun().then(console.log);\n\nconsole.log(2);\n// 1\n// 2\n// 3\n```\n\n但是，若`Promise`被拒绝，那么将不会被异步函数捕获：\n\n```javascript\nasync function fun() {\n    console.log(1);\n    Promise.reject(3);\n}\n\nfun().then(console.log);\n\nconsole.log(2);\n// 1\n// 2\n// 报错：Unhandled promise rejection\n```\n\n## 3. await 关键字\n\n使用`await`关键字可以暂停异步函数代码的执行，等待`Promise`解决。\n\n本文首个例子：\n\n```javascript\nconst p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 10));\np.then(x => console.log(x)); // 10\n```\n\n可以使用`async`和`await`关键字改写为：\n\n```javascript\nasync function fun() {\n    const p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 10));\n    console.log(await p);\n}\n\nfun(); // 10\n```\n\n`await`关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的**执行线程**。\n\n但是，`await`必须和`async`一起使用，也就是说，`await`只能写在被`async`声明过的异步函数中。若`await`写在同步函数中，将会报错：\n\n```javascript\nfunction fun() {\n    let a = await 1; // SyntaxError: await is only valid in async function\n    console.log(a);\n}\n\nfun();\n```\n\n\n\n***\n\n> 参考：\n>\n> 《JavaScript高级程序设计（第4版）》",
      "date": 1636732616000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 理解异步函数、async/await关键字",
      "titleEng": "async-await",
      "url": "https://lzxjack.top/post?title=async-await"
    },
    {
      "_id": "9e7190f1618b6a3c04bd2d8e0145ee02",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "## 1. 两个setState，调用几次？\n\n如下代码所示，`state`中有一个`count`。对按钮绑定了点击事件，事件中执行了两次`setState`，每次都将`count`的值加`1`。\n\n当点击按钮时，`setState`会执行几次？`render()`会执行几次？\n\n答案：都是`1`次。\n\n```javascript\nstate = { count: 0 };\nhandleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 1 });\n};\nrender() {\n    console.log(`render`);\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button onClick={this.handleClick}>add</button>\n        </>\n    );\n}\n```\n\n按照常理来说，第一次点击按钮时，由于执行了两次两次`setState`，每次都将`count`的值进行加`1`，`render()`应该会执行两次，最后`count`的值应该是2。但是 React 并不是这么执行的。\n\n以上代码放到浏览器运行一下即可：\n\n![](https://img.lzxjack.top:99/20211110135610.gif)\n\n最开始时，页面显示`count`的值为`0`，控制台打印出`render`，这是 React 首次渲染时打印的。当点击完按钮后，页面显示`count`值是`1`，同时也只打印了`1`个`render`，说明在这过程中 React 只执行了一次`setState`，只执行了一次`render()`渲染操作。\n\n原因在于，React 内部将**同一事件响应函数**中的多个`setState`进行合并，减少`setState`的调用次数，也就能减少渲染的次数，提高性能。\n\n这也就解释了上述代码，为什么最后`count`的值是`1`，因为 React 将两个`setState`进行了合并，最终只执行了`1`次，`render()`也只执行了一次。\n\n## 2. 两个setState，调用的是哪一个？\n\n但上述代码没有验证，React 合并后，到底执行的是哪一次`setState`。如下代码所示，将第二个`setState`中，对`count`的操作改为加`2`，其余代码保持不变：\n\n```javascript\nstate = { count: 0 };\nhandleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    this.setState({ count: this.state.count + 2 }); // 改为+2\n};\nrender() {\n    console.log(`render`);\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button onClick={this.handleClick}>add</button>\n        </>\n    );\n}\n```\n\n再次放到浏览器中执行：\n\n![](https://img.lzxjack.top:99/20211110141434.gif)\n\n结果显示，点击按钮后，`count`的值最终变成了`2`，也就是进行了`+2`的操作，`render()`也只执行了`1`次。这就说明 React 在合并多个`setState`时，若出现同名属性，会将**后面的同名属性**覆盖掉**前面的同名属性**。可以这么理解，对于同名属性，最终执行的的是**最后**的`setState`中的属性。\n\n## 3. 两个setState放在setTimeout中？\n\n若在点击事件函数中，添加一个定时器`setTimeout`，在定时器中执行两次`setState`操作，结果又将如何？如下代码，事件处理函数中，写了一个定时器`setTimeout`，将两次`setState`放入`setTimeout`中。\n\n```javascript\nstate = { count: 0 };\nhandleClick = () => {\n    setTimeout(() => {\n        this.setState({ count: this.state.count + 1 });\n        this.setState({ count: this.state.count + 2 });\n    }, 0);\n};\nrender() {\n    console.log(`render`);\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button onClick={this.handleClick}>add</button>\n        </>\n    );\n}\n```\n\n运行结果：\n\n![](https://img.lzxjack.top:99/20211110142842.gif)\n\n结果显示，点击按钮后，`count`的值最终变成了`3`，也就`+1`和`+2`的操作都执行了，`render()`也执行了`2`次。\n\n这是因为在 React 的**合成事件**和**生命周期函数**中直接调用`setState`，会交由 React 的**性能优化机制**管理，合并多个`setState`。而在**原生事件**、`setTimeout`中调用`setState`，是不受 React 管理的，故并**不会**合并多个`setState`，写了几次`setState`，就会调用几次`setState`。\n\n## 4. 总结\n\n在 React 中直接使用的事件，如`onChange`、`onClick`等，都是由 React 封装后的事件，是**合成事件**，由 React 管理。\n\nReact 对于合成事件和生命周期函数，有一套**性能优化机制**，会合并多个`setState`，若出现同名属性，会将**后面的同名属性**覆盖掉**前面的同名属性**。\n\n若越过 React 的**性能优化机制**，在**原生事件**、`setTimeout`中使用`setState`，就不归 React 管理了，写了几次`setState`，就会调用几次`setState`。\n\n\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      "date": 1636526516000,
      "post": true,
      "tags": ["React"],
      "title": "React 关于setState调用次数问题的个人理解",
      "titleEng": "react-setstate-render",
      "url": "https://lzxjack.top/post?title=react-setstate-render"
    }
  ],
  "requestId": "fed7534c3b07f"
}
