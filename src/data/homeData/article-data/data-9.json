{
  "data": [
    {
      "_id": "6360507662415a3e0219226f19ff5623",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "## 1. 单行文字溢出省略\n\n只需添加三行代码即可：\n\n```css\noverflow: hidden; /* 超出的文本隐藏 */\ntext-overflow: ellipsis; /* 显示省略符号来代表被修剪的文本。 */\nwhite-space: nowrap; /* 文本不换行 */\n```\n\n举例：\n\n![](https://img.lzxjack.top:99/20210719132004.png)\n\n`CSS`：\n\n```css\n.demo {\n    width: 200px;\n    height: 20px;\n    border: 2px solid #000;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n```\n\n## 2. 多行文字溢出省略\n\n需要添加`4`行`CSS`代码：\n\n```css\ndisplay: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */\n-webkit-box-orient: vertical; /* 设置或检索伸缩盒对象的子元素的排列方式 */\n-webkit-line-clamp: 3; /* 表示显示的行数，不是CSS规范属性 */\noverflow: hidden; /* 超出的文本隐藏 */\n```\n\n举例：\n\n![](https://img.lzxjack.top:99/20210719131949.png)\n\n`CSS`：\n\n```css\n.demo {\n    width: 200px;\n    height: 64px;\n    border: 2px solid #000;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 3;\n    overflow: hidden;\n}\n```\n\n\n",
      "date": 1626672366000,
      "post": true,
      "tags": ["CSS", "实用技巧"],
      "title": "CSS 文字溢出部分用省略号代替",
      "titleEng": "text-ellipsis"
    },
    {
      "_id": "8937eaa96124f5bc061bb41f4a78b7d7",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "## 1. forEach\n\n`forEach`用来遍历数组，用`forEach`有以下特征：\n\n- 相比于`for`循环，形式更加简洁\n- 没有**返回值**\n- 不能使用`break`、`continue`来控制循环\n- 若使用`return`，则会**跳过当前循环**，直接进入下一个循环，**不会跳出外层函数**\n\n在`forEach`中，使用`break`或`continue`，会直接报错：\n\n```javascript\nconst arr = [0, 1, 2, 3, 4, 5];\n\narr.forEach((item, index) => {\n    if (index === 2) break; // SyntaxError: Illegal break statement\n    console.log(item);\n});\n```\n\n```javascript\nconst arr = [0, 1, 2, 3, 4, 5];\n\narr.forEach((item, index) => {\n    if (index === 2) continue; // SyntaxError: Illegal continue statement\n    console.log(item);\n});\n```\n\n如下代码，在`index===2`的时候，希望跳出`test`函数，然而实际上只是跳过了当前的循环：\n\n```javascript\nconst arr = [0, 1, 2, 3, 4, 5];\n\nfunction test() {\n    arr.forEach((item, index) => {\n        if (index === 2) return;\n        console.log(item);\n    });\n}\n\ntest();\n// 0\n// 1\n// 3\n// 4\n// 5\n```\n\n而同样功能，使用`for`循环就可以直接跳出`test`函数：\n\n```javascript\nconst arr = [0, 1, 2, 3, 4, 5];\n\nfunction test() {\n    const len = arr.length;\n    for (let i = 0; i < len; i++) {\n        if (i === 2) return;\n        console.log(arr[i]);\n    }\n}\n\ntest();\n// 0\n// 1\n```\n\n## 2. for-in\n\n`for...in`语句以**任意顺序**遍历一个对象的除`Symbol`以外的**可枚举**属性。\n\n```javascript\nfor (variable in object){\n\t...\n}\n```\n\n-   `variable`：在每次迭代时，`variable`会被赋值为不同的`key`，即**属性名**。\n-   `object`：非`Symbol`类型的**可枚举**属性被迭代的对象。\n\n`for ... in`更适合遍历对象，不建议与**数组**一起使用，因为遍历顺序有可能不是按照实际数组的索引顺序。\n\n`for ... in`会遍历所有的可枚举属性，包括**原型**：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\n\nfunction myObj() {\n    this.name = 'Jack';\n}\n\nmyObj.prototype = obj;\n\nconst user = new myObj();\n\nfor (const prop in user) {\n    console.log(`user.${prop} = ${user[prop]}`);\n}\n// user.name = Jack\n// user.a = 1\n// user.b = 2\n// user.c = 3\n```\n\n如果想仅迭代自身的属性，需要使用`hasOwnProperty()`方法判断某个属性是否是该对象的实例属性：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\n\nfunction myObj() {\n    this.name = 'Jack';\n}\n\nmyObj.prototype = obj;\n\nconst user = new myObj();\n\nfor (const prop in user) {\n    if (user.hasOwnProperty(prop)) {\n        console.log(`user.${prop} = ${user[prop]}`);\n    }\n}\n// user.name = Jack\n```\n\n## 3. for-of\n\n`for...of`语句在**可迭代对象**（包括 `Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments`对象等 ）上创建一个迭代循环，并为每个**不同属性的值**执行语句。\n\n```javascript\nfor (variable of iterable) {\n\t...\n}\n```\n\n-   `variable`：在每次迭代中，将不同属性的**值**分配给`variable`。\n-   `iterable`：被迭代枚举其属性的对象。\n\n> 与`forEach()`不同的是，它可以正确响应`break`、`continue`和`return`语句。\n\n迭代**数组**：\n\n```javascript\nconst arr = [10, 20, 30];\n\nfor (const value of arr) {\n    console.log(value);\n}\n// 10\n// 20\n// 30\n```\n\n迭代`Map`：\n\n```javascript\nconst map = new Map([\n    ['a', 1],\n    ['b', 2],\n    ['c', 3],\n]);\n\nfor (const entry of map) {\n    console.log(entry);\n}\n// [\"a\", 1]\n// [\"b\", 2]\n// [\"c\", 3]\n\nfor (const [key, value] of map) {\n    console.log(value);\n}\n// 1\n// 2\n// 3\n```\n\n迭代`arguments`对象：\n\n```javascript\n(function () {\n    for (const argument of arguments) {\n        console.log(argument);\n    }\n})(1, 2, 3);\n\n// 1\n// 2\n// 3\n```\n\n## 4. 总结\n\n-   `forEach`是数组的方法，遍历数组，没有返回值，不能使用`break`、`continue`，不能用`return`到跳出外层函数。\n-   `for...in`语句以**任意顺序**迭代对象的**键**，包括**原型**。不建议与**数组**一起使用。\n-   `for...of` 语句遍历**可迭代对象**的**值**。\n\n",
      "date": 1626662103000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript forEach、for-in和for-of的区别总结",
      "titleEng": "for-in-of"
    },
    {
      "_id": "2d44d6c261264d2d06f3ebb8344b2e51",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 手撕代码",
      "content": "## 1. 实现代码\n\n输入随机整数出现的范围（最大值、最小值），返回此范围内的一个**随机整数**。\n\n```javascript\nconst getRandomNum = (Min, Max) => {\n    const Range = Max - Min + 1;\n    const Rand = Math.random();\n    return Min + Math.floor(Rand * Range);\n};\n```\n\n## 2. 验证\n\n产生`[2,5]`范围内 1000 个随机整数，用`Map`进行统计计数：\n\n```javascript\nconst map = new Map();\nfor (let i = 0; i < 1000; i++) {\n    const num = getRandomNum(2, 5);\n    map.set(num, (map.get(num) || 0) + 1);\n}\n\nconsole.log(map);\n```\n\n控制台输出：\n\n```javascript\nMap(4) { 3 => 240, 4 => 234, 5 => 270, 2 => 256 }\n```\n\n若产生`[1,10]`范围内 1000 个随机整数：\n\n```javascript\nMap(10) {\n  6 => 87,\n  4 => 100,\n  3 => 93,\n  10 => 100,\n  5 => 121,\n  8 => 88,\n  2 => 105,\n  9 => 95,\n  7 => 94,\n  1 => 117\n}\n```\n\n可以看到，每个整数出现的次数比较平均。\n\n\n",
      "date": 1626519643000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 生成指定范围内的随机整数",
      "titleEng": "random-num"
    },
    {
      "_id": "2d44d6c26124ddbb06beb7e34b6b0625",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 手撕代码",
      "content": "## 1. 实现深拷贝\n\n```javascript\nconst deepCopy = oldObj => {\n    // 递归出口：若属性为值或者null，则直接返回\n    if (typeof oldObj !== 'object' || oldObj === null) {\n        return oldObj;\n    }\n\n    // 结果对象\n    let newObj = {};\n    // 如果是数组，则定义结果数组\n    if (oldObj.constructor === Array) {\n        newObj = [];\n    }\n\n    // 遍历对象的key\n    for (const key in oldObj) {\n        // key是对象的自有属性，递归调用深拷贝方法\n        if (oldObj.hasOwnProperty(key)) {\n            newObj[key] = deepCopy(oldObj[key]);\n        }\n    }\n    return newObj;\n};\n```\n\n## 2. 验证\n\n### 1. 拷贝数组\n\n```javascript\nconst arr = [\n    {\n        a: () => {\n            console.log('aaaa');\n        },\n    },\n    { a: 2 },\n    { a: 3 },\n];\n\nconst arr2 = deepCopy(arr);\n\n// 改变新的数组\narr2[0].a = () => {\n    console.log('bbbb');\n};\narr2[1].a = 9;\n\narr[0].a(); // aaaa\narr2[0].a(); // bbbb\n\nconsole.log(arr[1].a); // 2\nconsole.log(arr2[1].a); // 9\n```\n\n改变新数组的内容，旧数组不会被改变。\n\n### 2. 拷贝对象\n\n```javascript\nconst oldObj = {\n    id: 0,\n    data: {\n        name: 'Jack',\n        age: 18,\n    },\n};\n\nconst newObj = deepCopy(oldObj);\n\nnewObj.id = 1;\nnewObj.data.name = 'Tom';\nnewObj.data.age = 20;\n\nconsole.log(oldObj); // { id: 0, data: { name: 'Jack', age: 18 } }\nconsole.log(newObj); // { id: 1, data: { name: 'Tom', age: 20 } }\n```\n\n改变新对象中深层对象的值，旧对象不会被改变。\n\n\n",
      "date": 1626349958000,
      "post": true,
      "tags": ["JavaScript", "数据结构"],
      "title": "JavaScript 实现对象的深拷贝",
      "titleEng": "obj-deep-copy"
    },
    {
      "_id": "8937eaa9611f3e09058068256b7bcba2",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "杂七杂八",
      "content": "先安装`antd`：\n\n```powershell\nyarn add antd\n```\n\n再安装相关插件：\n\n```powershell\nyarn add react-app-rewired customize-cra babel-plugin-import\n```\n\n修改项目中`package.json`文件：\n\n```json\n/* package.json */\n\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"react-app-rewired start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"react-app-rewired build\",\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"react-app-rewired test\",\n}\n```\n\n然后在项目根目录创建一个 `config-overrides.js` 用于修改默认配置。\n\n```javascript\nconst { override, fixBabelImports } = require('customize-cra');\n\nmodule.exports = override(\n    fixBabelImports('import', {\n        libraryName: 'antd',\n        libraryDirectory: 'es',\n        style: 'css',\n    })\n);\n```\n\n这样就完成了，修改写法即可：\n\n```javascript\n- import Button from 'antd/es/button';\n+ import { Button } from 'antd';\n```\n\n\n",
      "date": 1626154219000,
      "post": true,
      "tags": ["实用技巧"],
      "title": "React中按需引入AntD样式",
      "titleEng": "antd-style"
    },
    {
      "_id": "14139e126124d4fe06b58fb84139c9c3",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "CSS",
      "content": "## 1. 盒模型定义及分类\n\nCSS 基础框盒模型是 CSS 规范的一个模块，它定义了一种长方形的盒子, 包括它们各自的内边距（padding）与外边距（margin），并根据视觉格式化模型来生成元素，对其进行布置、编排、布局。常被直译为盒子模型、盒模型或框模型。\n\n盒模型有以下分类：\n\n- 标准定义：\n  - 标准盒模型\n  - 怪异模式盒模型\n- 元素类型\n  - 块级盒子\n  - 内联盒子\n  - 行内块\n\n## 2. 标准定义划分\n\n### 1. 标准盒子模型\n\n宽度`width` = <u>内容宽度(`content`)</u> + `padding` + `border` + `margin`\n\n内容宽度仅仅只有`content`。如果设置一个元素的宽为`100px`，那么这个元素的内容区会有`100px`宽，并且任何**边框**和**内边距**的宽度都会被增加到最后绘制出来的元素宽度中。\n\n### 2. 怪异模式盒子模型\n\n宽度`width` = <u>内容宽度(`content` + `padding` + `border`)</u> + `margin`\n\n内容宽度包含了`content`、`border`、`padding`。如果将一个元素的`width`设为`100px`，那么这`100px`会包含它的`border`和`padding`，内容区的实际宽度是`width`减去(`border` + `padding`)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。\n\n### 3. box-sizing属性\n\n`box-sizing`属性有以下两个属性值。\n\n#### 1. content-box\n\n默认值，使用**标准盒子模型**。\n\n```css\n.contentBox {\n    box-sizing: content-box;\n    width: 350px;\n    border: 10px solid black;\n    padding: 0 10px;\n}\n```\n\n以上代码在浏览器中的渲染的实际宽度是`390px`。\n\n![](https://img.lzxjack.top:99/20210708165639.png)\n\n#### 2. border-box\n\n使用**怪异模式盒子模型**。\n\n```css\n.borderBox {\n    box-sizing: border-box;\n    width: 350px;\n    border: 10px solid black;\n    padding: 0 10px;\n}\n```\n\n以上代码在浏览器中的渲染的实际宽度就是`350px`。\n\n![](https://img.lzxjack.top:99/20210708165650.png)\n\n## 3. 元素类型划分\n\n### 1. 块级盒子\n\n一个被定义成块级的（block）盒子会表现出以下行为：\n\n- 盒子可以占据父容器的所有可用空间\n- 每个盒子都会换行\n- `width`和`height`属性可以发挥作用\n- 默认情况下`h1-h6`、`p`、`div`、`section`都处于`block`状态\n\n### 2. 内联盒子\n\n一个被定义成内联的（inline）盒子会表现出以下行为：\n\n- 盒子不会产生换行\n- `width`和`height`属性将不起作用\n- 默认情况下用做链接的`a`元素、`span`、`em`以及`strong`都处于`inline`状态\n\n### 3. 特殊的行内块\n\n如果不希望一个项切换到新行，但希望它可以设定**宽度**和**高度**，此时我们可以将该元素设置为`inline-block`。\n\n### 4. 元素类型切换\n\n|          | `display`属性值 |\n| :------: | :-------------: |\n| 块级盒子 |     `block`     |\n| 内联盒子 |    `inline`     |\n|  行内块  | `inline-block`  |\n\n## 4. 盒模型属性设置\n\n### 1. margin和padding\n\n- 1个值：四个方向\n- 2个值：上下、左右\n- 3个值：上、左右、下\n- 4个值：上、右、下、左\n\n### 2. border值\n\n```css\nborder: 10px double red;\n```\n\n10px、双实线、红色边框。",
      "date": 1625724902000,
      "post": true,
      "tags": ["CSS"],
      "title": "什么是CSS盒子模型，你对盒模型知道多少？",
      "titleEng": "css-box"
    },
    {
      "_id": "8937eaa9612b365506f08ca9703f11bc",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 前言\n\n最近在用 React 写一个小项目时，遇到了这样的需求：\n\n在某个组件中引入外部`js`文件，也就是引用一个或多个`script`标签。这些`script`标签仅供某个组件使用，所以不想在`html`页面中直接引进来，想就在相应的 React 的函数组件中引入，查阅了相关资料，找到了以下可行办法。\n\n## 2. 动态创建script标签并执行\n\n在组件挂载时，动态创建`script`标签，并设置标签的`src`属性，若不是外部文件，还可以设置`innerHTML`，然后追加到`body`标签的最下面。\n\n在组件即将卸载时，移除这个标签。\n\n❗❗❗ 注意：\n\n默认情况下， 以这种方式创建的`script`元素是以**异步方式**加载的 m，相当于添加了`async`属性。但不是所有浏览器都支持`async`属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：\n\n```javascript\nmyScript.async = false;\n```\n\n> 🔍 有关`script`标签`async`和`defer`的区别，请<a href=\"https://lzxjack.top/article/async_defer.html\" target=\"_blank\">看这里</a>。\n\n**函数组件写法（useEffect）**\n\n```javascript\nuseEffect(() => {\n    // 组件挂载时，创建script标签\n    const myScript = document.createElement('script');\n    // 设置标签的src属性\n    myScript.src = 'myScript.js';\n    // 明确设置为同步加载\n    myScript.async = false;\n    // 追加到body标签的最下面\n    document.body.appendChild(myScript);\n    return () => {\n        // 组件即将卸载时，移除标签\n        document.body.removeChild(myScript);\n    };\n}, []);\n```\n\n❗❗❗ 注意：\n\n以这种方式获取的资源对**浏览器预加载器**是不可见的。这会严重影响它们在**资源获取队列**中的优先级，可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部（`HTML`文件头部）显式声明：\n\n```html\n<link rel=\"preload\" href=\"XXXXXXXXXXXXXXXXXXXXXX.js\" as=\"script\" />\n```\n\n## 3. 按顺序引入两个script标签\n\n若想引入两个`script`标签，但`script1`必须先加载，`script2`后加载，两者有顺序关系，这时候只需要声明`async = false`，再按希望的执行顺序创建标签即可，但要注意一下移除标签的顺序，先移除`script2`：\n\n```javascript\nuseEffect(() => {\n    const script1 = document.createElement('script');\n    script1.src = 'script1.js';\n    // 显示声明同步加载\n    script1.async = false;\n    document.body.appendChild(script1);\n\n    const script2 = document.createElement('script');\n    script2.src = 'script2.js';\n    // 显示声明同步加载\n    script2.async = false;\n    document.body.appendChild(script2);\n    return () => {\n        // 先移除script2\n        document.body.removeChild(script2);\n        document.body.removeChild(script1);\n    };\n}, []);\n```\n\n同样地，在文档头部（`HTML`文件头部）显式声明这些文件的存在：\n\n```html\n<link rel=\"preload\" href=\"script1.js\" as=\"script\" />\n<link rel=\"preload\" href=\"script2.js\" as=\"script\" />\n```\n\n## 4. 封装自定义hook\n\n将顺序引入两个外部`js`文件，封装成自定义`hook`，精简代码：\n\n```javascript\nimport { useEffect } from 'react';\n\nconst useScript = (url1, url2) => {\n    // 顺序引入两个外部js文件\n    useEffect(() => {\n        const script1 = document.createElement('script');\n        script1.src = url1;\n        script1.async = false;\n        document.body.appendChild(script1);\n\n        const script2 = document.createElement('script');\n        script2.src = url2;\n        script2.async = false;\n        document.body.appendChild(script2);\n        return () => {\n            document.body.removeChild(script2);\n            document.body.removeChild(script1);\n        };\n    }, [url1, url2]);\n};\n\nexport default useScript;\n```\n\n这里我封装了顺序引入两个外部`js`文件，也可以写成引入 1 个的。\n\n在需要引入`script`标签的地方，这样使用：\n\n```javascript\nimport useScript from '../../../hooks/useScript';\n...\n\nconst Demo = () => {\n\t...\n    // 顺序引入两个外部js文件\n    useScript(url1, url2);\n\n    ...\n};\n\nexport default Demo;\n```\n\n\n",
      "date": 1625628966000,
      "post": true,
      "tags": ["React"],
      "title": "在React中引入多个script标签，并同步执行",
      "titleEng": "react-load-script"
    },
    {
      "_id": "8937eaa9612e10430787e9656396ffe5",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "## 1. 实现效果\n\n最近在用 React 写一个博客管理系统，有一个功能是添加新文章。在新建文章的页面，我希望做到像 CSDN 这样，左边是编辑区（`markdown`格式），右边是预览区。实时更新，编辑文本的同时，在预览区就能看到效果。\n\n就自己动手实现了一个这样的组件，**markdown 实时预览编辑器**！\n\n具体效果如下：\n\n![](https://img.lzxjack.top:99/20210831192229.png)\n\n## 2. 实现过程\n\n使用 React 实现，做成单独的一个组件。\n\n首先 HTML 结构如下：\n\n```html\n<header>基于React的markdown实时编辑器</header>\n<div className=\"marked\">\n    {/* 编辑区 */}\n    <div className=\"input-region markdownStyle\"></div>\n    {/* 预览区 */}\n    <div className=\"show-region markdownStyle\"></div>\n</div>\n```\n\n稍微写一点样式，让编辑区和预览区左右布局。\n\n定义一个`hook`，存储输入的内容：\n\n```javascript\nconst [text, setText] = useState('');\n```\n\n左边编辑区，让一个`div`可编辑，给其加上`contentEditable`属性，并让值为`plaintext-only`，表示编辑区域只能输入**纯文本**。\n\n```html\n<div className=\"input-region markdownStyle\" contenteditable=\"plaintext-only\"></div>\n```\n\n> 为什么不用`textarea`：\n>\n> `div`高度可自适应，可以拿到纯文本。\n\n当左边编辑区内容改变时，将输入的纯文本存入到`state`，给编辑区的`div`加上`onInput`属性，通过事件对象拿到纯文本：\n\n```html\n<div\n    className=\"input-region markdownStyle\"\n    contentEditable=\"plaintext-only\"\n    onInput={e => {\n        setText(e.target.innerText);\n    }}\n></div>\n```\n\n要渲染成`markdown`格式的内容，就需要插件来渲染，这里使用`marked`，代码高亮也有需求，使用`highlight.js`：\n\n```powershell\nyarn add marked highlight.js\n```\n\n```javascript\nimport marked from 'marked';\nimport hljs from 'highlight.js';\n```\n\n配置`marked`和`highlight`：\n\n```javascript\nuseEffect(() => {\n    // 配置highlight\n    hljs.configure({\n        tabReplace: '',\n        classPrefix: 'hljs-',\n        languages: ['CSS', 'HTML', 'JavaScript', 'Python', 'TypeScript', 'Markdown'],\n    });\n    // 配置marked\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        highlight: code => hljs.highlightAuto(code).value,\n        gfm: true, //默认为true。 允许 Git Hub标准的markdown.\n        tables: true, //默认为true。 允许支持表格语法。该选项要求 gfm 为true。\n        breaks: true, //默认为false。 允许回车换行。该选项要求 gfm 为true。\n    });\n}, []);\n```\n\n引入`github`风格的代码高亮主题，但我自己又稍作了修改：\n\n```javascript\nimport './github-dark.css';\n```\n\n在预览区，使用 React 的标签属性 dangerouslySetInnerHTMl 来显示内容：\n\n```html\n<div\n    className=\"show-region markdownStyle\"\n    dangerouslySetInnerHTML={{\n        __html: marked(text).replace(/<pre>/g, \"<pre id='hljs'>\"),\n    }}\n></div>\n```\n\n调用`marked`将文本渲染成`markdown`格式的内容。后面加`replace`是因为，我发现渲染过后不显示**代码框背景色**，就在`<pre>`标签加上了`id`，然后自己写了 CSS，让其显示代码框背景。\n\n整个组件写好之后，最终的代码：\n\n```javascript\nimport { useState, useEffect } from 'react';\nimport marked from 'marked';\nimport hljs from 'highlight.js';\nimport './github-dark.css';\nimport './index.css';\n\nconst Marked = () => {\n    const [text, setText] = useState('');\n    useEffect(() => {\n        // 配置highlight\n        hljs.configure({\n            tabReplace: '',\n            classPrefix: 'hljs-',\n            languages: ['CSS', 'HTML', 'JavaScript', 'Python', 'TypeScript', 'Markdown'],\n        });\n        // 配置marked\n        marked.setOptions({\n            renderer: new marked.Renderer(),\n            highlight: code => hljs.highlightAuto(code).value,\n            gfm: true, //默认为true。 允许 Git Hub标准的markdown.\n            tables: true, //默认为true。 允许支持表格语法。该选项要求 gfm 为true。\n            breaks: true, //默认为false。 允许回车换行。该选项要求 gfm 为true。\n        });\n    }, []);\n    return (\n        <>\n            <header>基于React的markdown实时编辑器</header>\n            <div className=\"marked\">\n                <div\n                    className=\"input-region markdownStyle\"\n                    contentEditable=\"plaintext-only\"\n                    // suppressContentEditableWarning\n                    onInput={e => {\n                        setText(e.target.innerText);\n                    }}\n                ></div>\n                <div\n                    className=\"show-region markdownStyle\"\n                    dangerouslySetInnerHTML={{\n                        __html: marked(text).replace(/<pre>/g, \"<pre id='hljs'>\"),\n                    }}\n                ></div>\n            </div>\n        </>\n    );\n};\n\nexport default Marked;\n```\n\n\n\n\n",
      "date": 1625483913000,
      "post": true,
      "tags": ["React"],
      "title": "一步步教你用React写一个markdown实时编辑器！",
      "titleEng": "react-marked"
    }
  ],
  "requestId": "864533d2b732d"
}
