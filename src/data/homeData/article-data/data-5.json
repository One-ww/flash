{
  "data": [
    {
      "_id": "2d44d6c2614fcd550f66d7671d7c1220",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上 2021-9-26 的每日一题：<a href=\"https://leetcode-cn.com/problems/sum-of-two-integers/\" target=\"_blank\">「371. 两整数之和」</a>\n\n## 1. 题目描述\n\n给你两个整数 `a` 和 `b` ，**不使用** 运算符 `+` 和 `-` ，计算并返回两整数之和。\n\n**示例：**\n\n```\n输入：a = 1, b = 2\n输出：3\n```\n\n## 2. 解答\n\n对于位运算中的加法，只有四种情况：\n\n```javascript\n0 + 0 = 0\n0 + 1 = 1\n1 + 0 = 1\n1 + 1 = 0（进位 1）\n```\n\n总结规律可得，对于`a`、`b`，不考虑进位的加法 = `a^b`。\n\n例如，对于`a=2`，`b=3`：\n\n```SC\na = 0010\nb = 0011\n\na ^ b:\n\n0 0 1 0\n0 0 1 1\n-------\n0 0 0 1\n```\n\n在位运算中，进位可以有**与**得到：\n\n```javascript\na = 0010\nb = 0011\n\na & b:\n\n0 0 1 0\n0 0 1 1\n-------\n0 0 1 0\n```\n\n得到的`0010`并不是真正的进位，进位`1`需要在更高一位上，故左移一位即可得到`0100`。\n\n那么将**不考虑进位的加法**加上**进位**即可得到结果：\n\n```javascript\n0 0 0 1\n0 1 0 0\n-------\n0 1 0 1       (5)\n```\n\n若相加后还有进位的话，将`a^b`的结果与**进位**继续进行上述操作，直到没有进位为止。\n\n总结一下，对于给定的`a`和`b`：\n\n- 不考虑进位的加法：`a^b`\n- 进位：`(a & b) << 1`\n\n那么不断地将**进位**再次与**不考虑进位的加法结果**作相同的运算，直到进位为`0`即可。\n\n容易写出以下代码。\n\n### 1. 迭代\n```javascript\nconst getSum = (a, b) => {\n    while (b) {\n        // 进位\n        const c = (a & b) << 1;\n        // 不考虑进位的加法\n        a ^= b;\n        // 将进位赋值给b\n        b = c;\n    }\n    return a;\n};\n```\n\n### 2. 递归\n也可以用递归实现：\n```javascript\nconst getSum = (a, b) => {\n    if (!b) return a;\n    return getSum(a ^ b, (a & b) << 1);\n};\n```\n\n简单一点也可以：\n```javascript\nconst getSum = (a, b) => (b ? getSum(a ^ b, (a & b) << 1) : a);\n```\n\n\n\n***\n\n😄最近新创建了个开源仓库，总结 LeetCode 的每日一题，目前已有 C++、JavaScript 语言版本，欢迎大家提供其他语言版本！\n\n🖥️仓库地址：<a href=\"https://github.com/HDU-Coder-X/Daily-question-of-Leetcode\" target=\"_blank\">「每日一题系列」</a>",
      "date": 1632619824000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」两整数之和",
      "titleEng": "lc-371",
      "url": "https://lzxjack.top/post?title=lc-371"
    },
    {
      "_id": "8937eaa9614d26fb0d722ab93b33e850",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "前端基础",
      "content": "## 1. 创建\n\n在 JavaScript 中，可以通过两种方式创建一个正则表达式。\n\n（1）通过调用 `RegExp` 对象的构造函数创建\n\n```javascript\nconst regexp = new RegExp(正则表达式, 标志);\n```\n\n（2）利用字面量创建正则表达式\n\n```javascript\nconst rg = /正则表达式/[可选的标志];\n```\n\n## 2. 标志\n\n| 标志 |                           描述                           |\n| :--: | :------------------------------------------------------: |\n| `g`  |                         全局搜索                         |\n| `i`  |                     不区分大小写搜索                     |\n| `m`  |                         多行搜索                         |\n| `s`  |                   允许 `.` 匹配换行符                    |\n| `u`  |               使用unicode码的模式进行匹配                |\n| `y`  | 执行**粘性(sticky)**搜索，匹配从目标字符串的当前位置开始 |\n\n## 3. 字符\n\n一个**正则表达式**可以由简单的字符构成，比如 `/abc/`，也可以是简单和特殊字符的组合，比如 `/ab*c/` 。其中**特殊字符**也被称为**元字符**，在正则表达式中是具有**特殊意义的专用符号**，如 `^` 、`$` 、`+` 等。\n\n特殊字符非常多，可参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\" target=\"_blank\">[MDN]</a>\n\n### 1. 断言\n\n#### 1. 边界类断言\n\n（1）`^`\n\n匹配输入的**开头**。如果多行模式设为 true，在换行符后也能立即匹配。\n\n> `^` 出现在**集合**或**范围开头**时的含义与此不同。\n\n（2）`$`\n\n匹配输入的**结束**。如果多行模式设为 true，在换行符前也能立即匹配。\n\n（3）`\\b`\n\n匹配一个单词的边界。\n\n```javascript\nconst reg1 = /\\b/g;\nconst reg2 = /xx\\b/g;\nconst reg3 = /\\bs/g;\nconst str = 'sdfxx sfadf';\n\nconst arr1 = str.match(reg1); // [ '', '', '', '' ]  两个单词，一共四个边界\nconst arr2 = str.match(reg2); // [ 'xx' ]  以xx结尾\nconst arr3 = str.match(reg3); // [ 's', 's' ]  以s开头\n```\n\n（4）`\\B`\n\n匹配非单词边界。\n\n例如，`/xx\\B/`匹配非`xx`结尾，`/\\Bs/`匹配非`s`开头。\n\n#### 2. 其他断言\n\n（1）`x(?=y)`\n\n**向前断言**：`x`被`y`跟随时匹配`x`。\n\n例如，对于`/Jack(?=Sprat)/`，`Jack`在跟有`Sprat`的情况下才会得到匹配。\n\n`/Jack(?=Sprat|Frost)/` ，`Jack`后跟有`Sprat`或`Frost`的情况下才会得到匹配。\n\n不过，匹配结果**不包括**`Sprat`或`Frost`。\n\n（2）`x(?!y)`\n\n**向前否定断言**：`x`**没有**被`y`紧随时匹配`x`。\n\n例如，对于`/\\d+(?!\\.)/`，数字后**没有**跟随小数点的情况下才会得到匹配。\n\n`/\\d+(?!\\.)/.exec(3.141)`，匹配`141`而不是`3`。\n\n（3）`(?<=y)x`\n\n**向后断言**：`x`跟随`y`的情况下匹配`x`。\n\n例如，对于`/(?<=Jack)Sprat/`，`Sprat`紧随`Jack`时才会得到匹配。\n\n`/(?<=Jack|Tom)Sprat`，`Sprat`在紧随`Jack`或`Tom`的情况下才会得到匹配。不过，匹配结果中不包括`Jack`或`Tom`。\n\n（4）`(?<!y)x`\n\n**向后否定断言**：`x`不跟随`y`时匹配`x`。\n\n例如，对于`/(?<!-)\\d+/`，数字不紧随`-`符号的情况下才会得到匹配。\n\n`/(?<!-)\\d+/.exec(3)`，`3`得到匹配。\n\n而`/(?<!-)\\d+/.exec(-3)`的结果无匹配，这是由于数字之前有`-`符号。\n\n### 2. 字符类\n\n（1）`.`\n\n- 匹配除**行终止符**之外的**任何单个字符**\n- 在字符集内，`.`失去了它的特殊意义，并与文字点匹配\n\n（2）`\\d`\n\n匹配**任何数字**，相当于`[0-9]`。\n\n（3）`\\D`\n\n匹配**任何非数字**，相当于`[^0-9]`。\n\n（4）`\\w`\n\n匹配**字母+数字+下划线**，相当于`[A-Za-z0-9_]`。\n\n（5）`\\W`\n\n匹配**字母+数字+下划线**以外的字符，相当于`[^A-Za-z0-9_]`。\n\n（6）`\\s`\n\n匹配任意一个**空格**（包括**换行符**、**制表符**、**空格符**等），相当于`[\\t\\r\\n\\v\\f]`。\n\n（7）`\\S`\n\n匹配任意一个**非空格符**，相当于`[^\\t\\r\\n\\v\\f]`。\n\n（8）`\\t`、`\\r`、`\\n`、`\\v`、`\\f`\n\n| 符号 |                    说明                     |\n| :--: | :-----------------------------------------: |\n| `\\t` |   匹配一个**制表符**。等价于`\\x09`和`\\cI`   |\n| `\\r` |   匹配一个**回车符**。等价于`\\x0d`和`\\cM`   |\n| `\\n` |  匹配一个**换行符**。等价于`\\x0a`和`\\cJ`。  |\n| `\\v` | 匹配一个**垂直制表符**。等价于`\\x0b`和`\\cK` |\n| `\\f` |   匹配一个**换页符**。等价于`\\x0c`和`\\cL`   |\n\n### 3. 组、范围\n\n（1）`x|y`\n\n匹配`x`或`y`。\n\n例如，`/green|red/`在`green apple`里匹配`green`，且在`red apple`里匹配`red`。\n\n（2）`[xyz]`、`[a-c]`\n\n字符集。 匹配任何一个包含的字符。可以使用**连字符**来指定字符范围，但如果连字符为方括号中的**第一个**或**最后一个**字符，则它将被视为作为**普通字符**包含在字符集中的文字连字符。也可以在字符集中包含字符类。\n\n例如，`[abcd]`与`[a-d]`等价。\n\n`[abcd-]`和`[-abcd]`将会在`brisket`匹配`b`, 在`chop`匹配`c`，并且匹配`non-profit`中的`-`。\n\n`[\\w-]`与`[A-Za-z0-9_-]`等价。\n\n（3）`[^xyz]`\n\n匹配任何**没有**包含在括号中的字符。\n\n（4）`(x)`\n\n**捕获组**：匹配`x`并记住匹配项。\n\n例如，`/(foo)/`匹配并记住`foo bar`中的`foo`。\n\n（5）`(?:x)`\n\n**非捕获组**：匹配`x`，但不记得匹配。\n\n### 4. 量词\n\n|                     符号                     |                             说明                             |\n| :------------------------------------------: | :----------------------------------------------------------: |\n|                     `x*`                     |                   重复**0**次或**更多**次                    |\n|                     `x+`                     |                   重复**1**次或**更多**次                    |\n|                     `x?`                     |                     重复**0**次或**1**次                     |\n|                    `x{n}`                    |                         重复**n**次                          |\n|                   `x{n,}`                    |                   重复**n**次或**更多**次                    |\n|                   `x{n,m}`                   |                      重复**n**到**m**次                      |\n| `x*?` `x+?` `x??` `x{n}?` `x{n,}?` `x{n,m}?` | 默认情况，`*`和`+`这样的量词是**贪婪的**，试图匹配**尽可能多**的字符串。加`?`使量词**非贪婪**：意思是它一旦找到匹配就会停止。 |\n\n## 4. 常用方法\n\n### 1. replace\n\n`replace()`方法可以实现**替换字符串**操作，用来替换的参数可以是**一个字符串**或是**一个正则表达式**。\n\n```javascript\nstr.replace(regexp/substr,replacement)\n```\n\n - 第一个参数：**被替换**的字符串 或者 正则表达式\n - 第二个参数：**替换为**的字符串\n\n返回值是一个**替换完毕**的**新字符串**。\n\n### 2. test\n\n`test()`法执行一个检索，查看正则表达式与指定的字符串是否匹配。\n\n```javascript\nregexObj.test(str)\n```\n\n返回`true`或`false`。\n\n```javascript\nconst str = 'hello world!';\nconst result = /^hello/.test(str);\nconsole.log(result); // true\n```\n\n### 3. match\n\n `match()`方法检索返回一个字符串匹配正则表达式的结果。\n\n```javascript\nstr.match(regexp)\n```\n\n返回值：\n\n- 如果使用`g`标志，则将返回与完整正则表达式匹配的**所有结果**，但**不返回捕获组**。\n- 如果未使用`g`标志，则**仅返回第一个**完整匹配及其相关的捕获组（`Array`）。 在这种情况下，返回的项目将具有如下所述的其他属性。\n  - `groups`：一个**捕获组数**组或`undefined`\n  - `index`：匹配的结果的开始位置\n  - `input`：搜索的字符串\n\n如果正则表达式不包含`g `标志，将返回与`RegExp.exec()`相同的结果。\n\n### 4. matchAll\n\n`matchAll()`方法返回一个包含所有匹配正则表达式的结果及**分组捕获组**的**迭代器**。\n\n```javascript\nstr.matchAll(regexp)\n```\n\n`regexp`必须是设置了全局模式`g`的形式，否则会抛出异常`TypeError`。\n\n### 5. search\n\n`search()`方法执行正则表达式和字符串的搜索匹配。\n\n```javascript\nstr.search(regexp)\n```\n\n如果匹配成功，则`search()`返回正则表达式在字符串中首次匹配项的索引；否则，返回`-1`。\n\n### 6. split\n\n`split()`方法使用指定的分隔符将**字符串**分割成子字符串**数组**。 \n\n```javascript\nstr.split([separator[, limit]])\n```\n\n- `separator`：指定表示每个拆分应发生的点的字符串。可以是一个字符串或正则表达式\n- `limit`：可选，一个整数，限定返回的分割片段数量。\n\n返回原字符串以分隔符出现位置分隔而成的数组。\n\n### 7. exec\n\n`exec()`方法在一个指定字符串中执行一个搜索匹配。\n\n```javascript\nregexObj.exec(str)\n```\n\n如果匹配**成功**，返回一个数组（属性`index`和`input`），并更新正则表达式对象的`lastIndex`属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。\n\n如果匹配**失败**，返回`null`，并将`lastIndex`重置为`0`。",
      "date": 1632446083000,
      "post": true,
      "tags": ["正则表达式"],
      "title": "JavaScript 正则表达式学习整理",
      "titleEng": "regular-expression",
      "url": "https://lzxjack.top/post?title=regular-expression"
    },
    {
      "_id": "cd045e75614d260b109369f270ad55c6",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上 2021-9-24 的每日一题：<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\" target=\"_blank\">「430. 扁平化多级双向链表」</a>\n\n## 1. 题目描述\n\n多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。\n\n给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。\n\n\n\n**示例 1：**\n\n```\n输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n输出：[1,2,3,7,8,11,12,9,10,4,5,6]\n```\n\n输入的多级列表如下图所示：\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png)\n\n扁平化后的链表如下图：\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png)\n\n**示例 2：**\n\n```\n输入：head = [1,2,null,3]\n输出：[1,3,2]\n解释：\n\n输入的多级列表如下图所示：\n\n  1---2---NULL\n  |\n  3---NULL\n```\n\n\n\n## 2. 解答\n\n1. 创建虚拟节点`res`，最后返回虚拟节点的`next`，并将`res.next.prev`置空\n2. 头部节点入栈，用栈遍历链表节点，构造双向链表的连接\n3. 若遇到`next`和`child`，先进`next`，后进`child`，这样下一轮就可以先遍历`child`了\n\n```javascript\nconst flatten = head => {\n    if (!head) return head;\n    const res = new Node(-1, null, null, null);\n    // prev指针\n    let prev = res;\n    // 头部节点入栈\n    const stack = [head];\n    while (stack.length) {\n        // 栈顶元素出栈，当前指针指向栈顶元素\n        const cur = stack.pop();\n        // 双向连接\n        prev.next = cur;\n        cur.prev = prev;\n        // 栈先入后出，先进 next，后进child\n        if (cur && cur.next) {\n            stack.push(cur.next);\n        }\n        if (cur && cur.child) {\n            stack.push(cur.child);\n            // child要置空\n            cur.child = null;\n        }\n        // 更新上一节点\n        prev = cur;\n    }\n    // 将头部与res节点的prev断开\n    res.next.prev = null;\n    return res.next;\n};\n```\n\n\n\n\n***\n\n😄最近新创建了个开源仓库，总结 LeetCode 的每日一题，目前已有 C++、JavaScript 语言版本，欢迎大家提供其他语言版本！\n\n🖥️仓库地址：<a href=\"https://github.com/HDU-Coder-X/Daily-question-of-Leetcode\" target=\"_blank\">「每日一题系列」</a>",
      "date": 1632445938000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」扁平化多级双向链表",
      "titleEng": "lc-430",
      "url": "https://lzxjack.top/post?title=lc-430"
    },
    {
      "_id": "23b1deca64231383001bf88e30d99fbd",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "前端基础",
      "content": "|            |                  Cookie                  |                           Session                            |\n| :--------: | :--------------------------------------: | :----------------------------------------------------------: |\n| 存取值类型 |                  字符串                  |                          大多数类型                          |\n|  存取位置  |                  客户端                  |          服务端，sessionId非主动传参时，依赖Cookie           |\n|  存取方式  |                   文件                   |              文件、内存、关系或非关系型数据库等              |\n|    大小    |               受客户端限制               |                           自行配置                           |\n|  过期时间  | 写入时设置。若不设置，随客户端关闭被清除 |             自行配置，服务端自动清除过期Session              |\n|   兼容性   |          需浏览器开启，用户同意          |          不依赖Cookie时，通过Get或自定请求字段传入           |\n|  作用范围  |         可设置跨子域，不可跨主域         | 用户身份唯一标识符不变时，可跨域，跨服务器。默认受限于Cookie，仅限会话期间有效 |\n\n",
      "date": 1632365320000,
      "post": true,
      "tags": ["浏览器"],
      "title": "Cookie和Session区别的简单总结",
      "titleEng": "cookie-session",
      "url": "https://lzxjack.top/post?title=cookie-session"
    },
    {
      "_id": "fc8e64656423139706756e8103700698",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "HTTP 学习记录",
      "content": "# 1. HTTP-1.0\n\n**无状态**，**无连接**的应用层协议\n\n- 无法复用连接\n\n  每次发送请求，都要重新建立连接。\n\n- 队头阻塞\n\n  下个请求必须在上个请求响应到达后发送。如果上个请求响应丢失，则后面请求被**阻塞**。\n\n# 2. HTTP-1.1\n\nHTTP1.1 继承了 HTTP1.0 的简单，克服了 HTTP1.0 性能上的问题。\n\n- 长连接\n\n  新增`Connection: keep-alive`保持**长连接**。\n\n- 管道化\n\n  支持管道化请求，请求可以**并行传输**，但**响应顺序应与请求顺序相同**。实际场景中，浏览器采用建立多个TCP会话的方式，实现真正的并行，通过域名限制大会话数量。\n\n- 缓存处理\n\n  新增`Cache-control`，支持**强缓存**和**协商缓存**。\n\n- 断点续传\n\n- 主机头\n\n  新增`Host`字段，使得一个服务器创建多个站点。\n\n# 3. HTTP-2.0\n\nHTTP2.0进一步改善了传输性能。\n\n- 二进制分帧\n\n  在应用层和传输层间增加**二进制分帧层**。\n\n- 多路复用\n\n  建立双向字节流，帧头部包含所属流 ID，帧可以乱序发送，数据流可设优先级和依赖。从而实现一个 TCP 会话上进行任意数量的HTTP请求，真正的并行传输。\n\n- 头部压缩\n\n  压缩算法编码原来纯文本发送的请求头，通讯双方各自缓存一份头部元数据表，避免传输重复头。\n\n- 服务器推送\n\n  服务端可**主动向客户端推送资源**，无需客户端请求。\n\n# 4. HTTP-3.0\n\n当一个 TCP 会丢包时，整个会话都要等待重传，后面数据都被阻塞。这是由于 TCP 本身的局限性导致的。HTTP3.0 基于 UDP 协议，解决 TCP 的局限性。\n\n- 0-RTT\n\n  **缓存**当前会话上下文，下次恢复会话时，只需要将之前缓存传递给服务器，验证通过，即可传输数据。\n\n- 多路复用\n\n  一个会话的多个流间**不存在依赖**，丢包只需要重发包，**不需要重传整个连接**。\n\n- 更好的移动端表现\n\n  移动端 IP 经常变化，影响 TCP 传输，HTTP3.0 通过 ID 识别连接，只要 ID 不变，就能快速连接。\n\n- 加密认证的根文\n\n  TCP 协议头没有加密和认证，HTTP3.0 的包中几乎所有报文都要经过认证，主体经过加密，有效防窃听，注入和篡改。\n\n- 向前纠错机制\n\n  每个包还包含其他数据包的数据，少量丢包可通过**其他包的冗余数据直接组装**而无需重传。数据发送上限降低，但有效减少了丢包重传所需时间。\n\n\n\n***\n\n> 参考：\n>\n> <a href=\"https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/\" target=\"_blank\">《LeetBook》</a>",
      "date": 1632359236000,
      "post": true,
      "tags": ["网络基础"],
      "title": "HTTP各版本的特点（1.0/1.1/2.0/3.0）",
      "titleEng": "http-version",
      "url": "https://lzxjack.top/post?title=http-version"
    },
    {
      "_id": "0122a5876423139a0680b14862045a5e",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "HTTP 学习记录",
      "content": "# 1. 什么是HTTPS\n\nHTTPS （`Hyper Text Transfer Protocol over SecureSocket Layer`），基于安全套接字协议 SSL，是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过**传输加密**和**身份认证**保证了传输过程的**安全性**。 \n\n**HTTP2.0**和**HTTP3.0**都只用于HTTPS。\n\n# 2. HTTPS建立SSL连接\n\n![](https://img.lzxjack.top:99/20210916095657.png)\n\n① `Client Hello`：客户端将支持 SSL 版本、加密算法、密钥交换算法等发送服务端\n\n② `Server Hello`：服务端确定 SSL 版本、算法、会话 ID 发给客户端\n\n③ `Certificate`：服务端将携带公钥的数字证书发给客户端\n\n④ `Server Hello Done`：通知客户端版本和加密套件发完，准备交换密钥\n\n⑤ `Client Key Exchange`：客户端验证证书合法性，随机生成`premaster secret`用公钥加密发给服务端\n\n⑥ `Change Cipher Spec`：通知服务端后续报文采用协商好的密钥和加密套件\n\n⑦ `Finished`：**客户端**用密钥和加密套件计算已交互消息的`Hash`值发给**服务端**。**服务端**进行同样计算，与收到的**客户端**消息解密比较，相同则协商成功\n\n⑧ `Change Cipher Spec`：通知客户端后续报文采用协商好的密钥和加密套件\n\n⑨ `Finished`：**服务端**用密钥和加密套件计算已交互消息的`Hash`值发给**客户端**。**客户端**进行同样计算，与收到的**服务端**消息解密比较，相同则协商成功\n\n# 3. HTTPS和HTTP的区别\n\n- HTTP 协议以**明文方式**发送内容，数据都是未加密的，**安全性较差**。HTTPS 数据传输过程是加密的，**安全性较好**。\n- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。\n- HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。\n- HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。\n\n\n\n***\n\n> 参考：\n>\n> <a href=\"https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/\" target=\"_blank\">《LeetBook》</a>",
      "date": 1632357363000,
      "post": true,
      "tags": ["网络基础"],
      "title": "什么是HTTPS，与HTTP的区别？",
      "titleEng": "https",
      "url": "https://lzxjack.top/post?title=https"
    },
    {
      "_id": "14139e12614566ae0d73971559a4df86",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "站点搭建",
      "content": "最近写了一个<a href=\"https://lzxjack.top/\" target=\"_blank\">「个人博客系统」</a>，后台使用的是「腾讯云开发CloudBase」+「Webify自动部署」，本文简单记录一下我使用`Webify`部署个人博客的经历。\n\n## 1. 准备工作\n\n首先将个人博客系统的代码推送到「GitHub」或者「Gitee」等代码托管平台，并在<a href=\"https://console.cloud.tencent.com/tcb/env/\" target=\"_blank\">「云开发CloudBase」</a>上注册腾讯云帐号，开通CloudBase服务。\n\n## 2. 创建应用\n\n进入<a href=\"https://console.cloud.tencent.com/webify/new\" target=\"_blank\">「Webify」</a>，首先要添加「GitHub」或「Gitee」等平台的授权：\n\n![](https://img.lzxjack.top:99/20210918102055.png)\n\n然后选择从Git仓库导入应用，选择代码存放的仓库，进行导入即可：\n\n![](https://img.lzxjack.top:99/20210918102613.png)\n\n我的个人博客系统代码同时推送到了「GitHub」和「Gitee」，然后我导入的是「Gitee」仓库的代码，这样后面触发**自动部署**的稳定性会好一点。\n\n点击「导入」之后，进入到应用配置页面，系统检测到我使用的是「React脚手架」，自动选择了`React.js`，其余配置默认即可。\n\n点击「部署应用」。\n\n![](https://img.lzxjack.top:99/20210918102603.png)\n\n在弹出的对话框中选择「我已知晓」。\n\n![](https://img.lzxjack.top:99/20210918102956.png)\n\n随后应用便开始了第一次部署，等待3~5分钟就部署成功了。\n\n## 3. 部署成功\n\n这样就算部署成功了，以后如果本地修改好代码，只要提交到绑定的`Git`仓库，就会自动触发部署操作，非常方便。\n\n![](https://img.lzxjack.top:99/20210918120434.png)\n\n## 4. 绑定域名\n\n应用第一次构建成功后，可以看到，系统自动为我们分配了一个域名，使用这个默认域名即可访问到博客页面了！\n\n![](https://img.lzxjack.top:99/20210918103209.png)\n\n如果想要自定义域名，也是可以的，不过域名需要备案才可以。\n\n点击左侧的「应用列表」，进入刚刚新建的应用，点击「所属环境」对应的链接，进入到「云开发」的应用控制台页面。\n\n![](https://img.lzxjack.top:99/20210918103459.png)\n\n点击左侧的「静态页面托管」，可以看到，刚刚部署的React应用静态文件存放在这里。\n\n![](https://img.lzxjack.top:99/20210918103713.png)\n\n点击上方的「基础配置」，添加自定义域名，自定义域名需要备案，同时需要上传SSL证书：\n\n![](https://img.lzxjack.top:99/20210918103847.png)\n\n之后需要根据提示，在「域名解析」中添加相应的操作，因为我的自定义域名是在「阿里云」购买的，需要在阿里云域名解析页面添加记录：\n\n![](https://img.lzxjack.top:99/20210918104138.png)\n\n之后等待几分钟，自定义域名就生效了，可以通过自定义域名访问到应用。\n\n\n\n## 5. 一些踩坑记录\n\n### 1. React-router使用BrowserRouter后刷新出现404\n\n> 如果应用是使用`React`开发的，并使用了`BrowserRouter`，那么就会出现这个问题（反正我是遇到了），刷新页面后出现`404`，`Not Found`。\n\n这里我找到了两种解决方案：\n\n（1）使用`HashRouter`\n\n不使用`BrowserRouter`，改为使用`HashRouter`。\n\n```jsx\n<HashRouter>\n\t<App />\n</HashRouter>\n```\n\n（2）云开发添加「路由配置」\n\n继续使用`BrowserRouter`，但腾讯云 CloudBase 需要做一些设置。\n\n![](https://img.lzxjack.top:99/20210918104841.png)\n\n点击「静态网站托管」中的「基础配置」，在「路由配置」中添加一条重定向规则如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521122550767.png#pic_center)\n错误码`404`时重定向到`\t/index.html`即可解决问题。\n\n### 2. 部署后应用页面还是原来的版本\n\n点击「静态网站托管」中的「基础配置」，在「节点缓存配置」中设置缓存时间为`0`：\n\n![](https://img.lzxjack.top:99/20210918105217.png)\n\n在「浏览器缓存配置」中设置缓存时间为`不缓存`（时间为`0`）：\n\n![](https://img.lzxjack.top:99/20210918105300.png)\n\n### 3. React应用，如果有警告会部署失败\n\n在本地预览React应用时，就算有警告也是可以运行的，但是自动部署的时候就会报错，从而导致部署失败。\n\n建议在本地预览时，如果出现警告，就修改代码将警告去除。\n\n还有一个方案，在React应用的根目录下，打开`package.json`文件：\n\n找到`scripts`下的`build`，在其值之前加上`CI=false&&`。\n\n比如，原来的是：\n\n```json\n\"build\": \"react-app-rewired build\"\n```\n\n将其改为：\n\n```json\n\"build\": \"CI=false&&react-app-rewired build\"\n```\n\n## ",
      "date": 1631938121000,
      "post": true,
      "tags": ["Webify"],
      "title": "5分钟上线个人网站——使用Webify部署网站记录",
      "titleEng": "webify-blog",
      "url": "https://lzxjack.top/post?title=webify-blog"
    },
    {
      "_id": "2d44d6c26142d0fc0ceb2cc0659b9a4c",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "HTTP 学习记录",
      "content": "## 1. TCP是基于连接的协议\n\n传输控制协议（TCP，Transmission Control Protocol）是一种**面向连接**的、可靠的、基于字节流的传输层通信协议。所谓面向连接，是指通信双方在进行通信之前，事先在双方之间建立起一个完整的、可以彼此沟通的通道，这个通道就是连接。\n\nTCP是基于连接的协议，也就是说，在正式收发数据之前，必须和对方建立可靠的连接。一个TCP连接的建立要经过**三次握手**，释放连接一般需要**四次挥手**。\n\n## 2. 连接的建立\n\n**建立**连接的过程一般需要**三次握手**，如下图所示：\n\n![](https://img.lzxjack.top:99/20210916131039.jpg)\n\n在握手之前，主动打开连接的客户端结束`CLOSE`阶段，被动打开的服务器也结束`CLOSE`阶段，并进入`LISTEN`阶段。随后进入三次握手阶段：\n\n（1）首先客户端向服务器发送一个`SYN`包，并等待服务器确认\n\n- 标志位为`SYN`，表示请求建立连接\n- 序号为`Seq = x`（`x`一般为`1`）\n- 随后客户端进入`SYN-SENT`阶段\n\n（2）服务器接收到客户端发来的`SYN`包后，对该包进行确认后结束`LISTEN`阶段，并返回一段`TCP`报文\n\n- 标志位为`SYN`和`ACK`，表示确认客户端的报文`Seq`序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接\n- 序号为`Seq = y`\n- 确认号为`Ack = x + 1`，表示收到客户端的序号`Seq`并将其值加`1`作为自己确认号`Ack`的值，随后服务器端进入`SYN-RECV`阶段\n\n（3）客户端接收到发送的`SYN + ACK`包后，明确了从客户端到服务器的数据传输是正常的，从而结束`SYN-SENT`阶段。并返回最后一段报文\n\n- 标志位为`ACK`，表示确认收到服务器端同意连接的信号\n- 序号为`Seq = x + 1`，表示收到服务器端的确认号`Ack`，并将其值作为自己的序号值\n- 确认号为`Ack= y + 1`，表示收到服务器端序号`seq`，并将其值加`1`作为自己的确认号`Ack`的值\n- 随后客户端进入`ESTABLISHED`\n\n当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束`SYN-RECV`阶段，进入`ESTABLISHED`阶段，从而完成**三次握手**。\n\n> 为什么是「三」次握手？\n>\n> 因为**三**次是保证`client`和`server`端**均**让对方知道自己具备**发送**和**接收**能力的**最小次数**：\n>\n> - **client > server**：**client**具备**发送**能力\n> - **server > client**：**server**具备**接收**和**发送**能力\n> - **client > server**：**client**具备**接收**能力\n\n## 2. 连接的释放\n\n**释放**连接的过程一般需要**四次挥手**，如下图所示：\n\n![](https://img.lzxjack.top:99/20210916131013.png)\n\n这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束`ESTABLISHED`阶段，随后开始四次挥手：\n\n（1）首先客户端向服务器发送一段`TCP`报文表明其想要释放`TCP`连接\n\n- 标记位为`FIN`，表示**请求释放连接**\n- 序号为`Seq = u`\n- 随后客户端进入`FIN-WAIT-1`阶段，即**半关闭阶段**，并且停止向服务端发送通信数据\n\n（2）服务器接收到客户端请求断开连接的`FIN`报文后，结束`ESTABLISHED`阶段，进入`CLOSE-WAIT`阶段并返回一段`TCP`报文\n\n- 标记位为`ACK`，表示**接收到客户端释放连接的请求**\n- 序号为`Seq = v`\n- 确认号为`Ack = u + 1`，表示是在收到客户端报文的基础上，将其序号值加`1`作为本段报文确认号`Ack`的值\n- 随后服务器开始准备释放服务器端到客户端方向上的连接\n\n客户端收到服务器发送过来的`TCP`报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端进入`FIN-WAIT-2`阶段。\n\n（3）服务器端在发出`ACK`确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过`CLOSE-WAIT`阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段`TCP`报文\n\n- 标记位为`FIN`和`ACK`，表示**已经准备好释放连接了**\n- 序号为`Seq = w`\n- 确认号`Ack = u + 1`，表示是在收到客户端报文的基础上，将其序号`Seq`的值加`1`作为本段报文确认号`Ack`的值\n\n随后服务器端结束`CLOSE-WAIT`阶段，进入`LAST-ACK`阶段，并且**停止向客户端发送数据**。\n\n（4）客户端收到从服务器发来的`TCP`报文，确认了服务器已经做好释放连接的准备，于是进入`TIME-WAIT`阶段，并向服务器发送一段报文\n\n- 标记位为`ACK`，表示接收到服务器准备好释放连接的信号\n\n- 序号为`Seq= u + 1`，表示是在已收到服务器报文的基础上，将其确认号`Ack`值作为本段序号的值\n\n- 确认号为`Ack= w + 1`，表示是在收到了服务器报文的基础上，将其序号`Seq`的值作为本段报文确认号的值\n\n\n随后客户端开始在`TIME-WAIT`阶段等待`2 MSL`。服务器端收到从客户端发出的`TCP`报文之后进入`CLOSED`阶段，由此正式确认管关闭服务器端到客户端方向上的连接。客户端等待完`2 MSL`之后，进入`CLOSED`阶段，由此完成**四次挥手**。\n\n>为什么是「四」次挥手？\n>\n>因为`TCP`是一个**全双工协议**，必须单独拆除每一条信道，两个方向的**接收**、**发送**都需要单独关闭。\n\n\n\n***\n\n> 参考：\n>\n> <a href=\"https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/\" target=\"_blank\">《LeetBook》</a>",
      "date": 1631768616000,
      "post": true,
      "tags": ["网络基础"],
      "title": "TCP连接的建立和释放过程",
      "titleEng": "tcp-connect-break",
      "url": "https://lzxjack.top/post?title=tcp-connect-break"
    }
  ],
  "requestId": "f4b6fce6fc587"
}
