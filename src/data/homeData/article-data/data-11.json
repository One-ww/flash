{
  "data": [
    {
      "_id": "cd045e756124e80b0783378129a8cbe2",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "## 1. ==\n\n> 如果被比较的两个数据类型不一致，则会自动进行**类型转换**后再比较。\n\n判断`X == Y`：\n\n1. 判断两者类型是否相同。若相同，则比较**值**是否相等。\n\n2. 若类型不相等，先进行类型转换。\n\n3. 首先判断是否为`null == undefined`，若是，则返回`true`。\n\n4. 判断是否为`string === number`，若是，将`string`转化为`number`后再判断两者值是否相等。\n\n    `'123'` => `123`\n\n5. 判断是否出现`boolean`，若出现`boolean`，将`boolean`转化为`number`后再进行判断。\n\n    `true` => `1`，`false` => `0`\n\n6. 判断其中一方是否为 `object` 且另一方为 `string`、`number` 或者 `symbol`，是的话就会把 `object` 转为**原始类型**再判断。\n\n    `{ name: 'jack' }` => `'[object Object]'`\n\n判断流程总结如下图所示：\n\n![](https://img.lzxjack.top:99/20210605204534.png)\n\n## 2. ===\n\n> **不会**进行类型转换，直接判断两者**类型**、**值**是否都相同。\n\n## 3. 建议\n\n> 尽量使用`===`，不使用`==`。\n\n\n",
      "date": 1622867774000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 中 == 和 === 到底有什么区别？",
      "titleEng": "equal",
      "url": "https://lzxjack.top/post?title=equal"
    },
    {
      "_id": "cd045e7561264b1507bceba72409f256",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 数据结构与算法",
      "content": "## 1. 数字\n\n### 1. 获取整数位数\n\n```javascript\nlet length = 0;\nwhile (num >= 1) {\n    num /= 10;\n    length++;\n}\n```\n\n### 2. 获取整数各个位数\n\n```javascript\nconst num = 1234;\n// 个位\nlet g = Math.floor(num / Math.pow(10, 0)) % 10;\n// 十位\nlet s = Math.floor(num / Math.pow(10, 1)) % 10;\n// 百位\nlet b = Math.floor(num / Math.pow(10, 2)) % 10;\n// 千位\nlet q = Math.floor(num / Math.pow(10, 3)) % 10;\nconsole.log(g, s, b, q); // 4 3 2 1\n```\n\n若`num < 0`，可以先取反，再计算。\n\n### 3. 字符串转化为数字-parseInt\n\n第一个参数为要被解析的字符串。\n\n第二个参数表示要解析的数字的基数，**可选**。\n\n```javascript\nparseInt('100'); // 100\nparseInt('19', 10); // 19\nparseInt('101101', 2); // 45\nparseInt('17', 8); // 15\nparseInt('ff', 16); // 255\n```\n\n## 2. 数组\n\n### 1. 分隔数组-slice、splice\n\n-   `slice()`\n\n```javascript\nlet abc = [1, 2, 3, 4, 5, 6];\nconsole.log(abc.slice(1, 3)); // [ 2, 3 ]  前闭后开，取下标1，2\nconsole.log(abc.slice(1)); // [ 2, 3, 4, 5, 6 ] 取下标1开始，所有的子数组\nconsole.log(abc.slice(-2)); // [ 5, 6 ] 从倒数第二2个元素开始，取所有的子数组\n```\n\n`slice()`方法并不会修改数组，而是返回一个**子数组**。\n\n-   `splice()`\n\n```javascript\nlet abc = [1, 2, 3, 4, 5, 6];\nconsole.log(abc.splice(2, 2)); // [ 3, 4 ] 从下标2开始，删除2个，并返回被删除的元素\nconsole.log(abc); //  [ 1, 2, 5, 6 ] 改变了原数组\nconsole.log(abc.splice(3, 0, 9)); // 在下标3的位置插入9，后面的元素后移\nconsole.log(abc); // [ 1, 2, 5, 9, 6 ]\n```\n\n`splice()`方法会**直接**对数组进行修改。\n\n### 2. 数组连接为字符串-join\n\n```javascript\nlet arr = ['a', 'b', 'c'];\nconsole.log(arr.join('')); // abc\nconsole.log(arr.join('-')); // a-b-c\n```\n\n`join()`方法将数组连接为字符串。\n\n### 3. 填充数组元素-fill\n\n```javascript\nlet arr = [1, 2, 3, 4];\nconsole.log(arr.fill(9, 1, 3)); // [ 1, 9, 9, 4 ]\n```\n\n`fill()`方法用于将一个固定值替换数组的元素。\n\n|  参数   |                   描述                    |\n| :-----: | :---------------------------------------: |\n| `value` |             必需。填充的值。              |\n| `start` |           可选。开始填充位置。            |\n|  `end`  | 可选。停止填充位置 (默认为`array.length`) |\n\n### 4. 求数字数组中的最大值\n\n#### 1. Math.max\n\n```javascript\nconst arr = [3, 1, 5, 4, 8, 6, 3, 4];\n\nconst max1 = Math.max(...arr); // 8\nconst max2 = Math.max.apply(null, arr); // 8\n```\n\n#### 2. reduce\n\n```javascript\nconst arr = [3, 1, 5, 4, 8, 6, 3, 4];\nconst max = arr.reduce((pre, cur) => (cur > pre ? cur : pre)); // 8\n```\n\n#### 3. sort\n\n```javascript\nconst arr = [3, 1, 5, 4, 8, 6, 3, 4];\nconst max = arr.sort((a, b) => a - b)[arr.length - 1]; // 8\n```\n\n## 3. 字符串\n\n### 1. 遍历字符串，拿到单个字符\n\n```javascript\nlet str = 'abcde';\nfor (let i = 0; i < str.length; i++) {\n    console.log(str[i]);\n}\n```\n\n### 2. 查找字符串-indexOf\n\n```javascript\nlet str = 'abcde';\nconsole.log(str.indexOf('b')); // 1\nconsole.log(str.indexOf('g')); // -1\n```\n\n`indexOf()`方法可返回某个指定的字符串值在字符串中**首次**出现的位置。如果要检索的字符串值没有出现，则该方法返回`-1`。\n\n### 3. 分隔字符串-split\n\n```javascript\nlet str = 'abc-de';\nlet arr1 = str.split('-'); // [ 'abc', 'de' ]\nlet arr2 = str.split(''); // [ 'a', 'b', 'c', '-', 'd', 'e' ]\n```\n\n`split()`方法用于把一个字符串分割成字符串数组。该方法**不会改变**原字符串。\n\n### 4. 去除收尾空格-trim\n\n```javascript\nlet str = '   abc   ';\nlet str2 = str.trim();\nconsole.log(str2); // abc\n```\n\n`trim()`方法用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。\n\n`trim()`方法**不会改变**原始字符串。\n\n### 5. 数字转化为字符串-toString\n\n**参数可选**，表示数字的基数。若省略该参数，则使用基数 **10**。\n\n```javascript\nconst num = 101;\nconst str1 = num.toString(); // 101\nconst str2 = num.toString(2); // 1100101\nconst str3 = num.toString(8); // 145\n```\n\n### 6. 获得字符的Unicode编码charCodeAt\n\n参数必填，表示字符串中某个位置的数字，即字符在字符串中的**下标**。\n\n```javascript\nconst str = 'Jack';\nstr.charCodeAt(1); // 97\nstr.charCodeAt(-1); // NaN\nstr.charCodeAt(99); // NaN\n```\n\n### 7. Unicode编码转化为字符-String.fromCharCode\n\n```javascript\nconst char = String.fromCharCode(97);\nconsole.log(char); // a\n```\n\n## 4. 位运算、运算技巧\n\n### 1. 数除以2\n\n将二进制数**右移 1 位**，相当于将这个数**除以 2**：\n\n```javascript\nlet num1 = 6,\n    num2 = 7;\nnum1 = num1 >> 1;\nnum2 = num2 >> 1;\nconsole.log(num1, num2); // 3 3\n```\n\n而且还舍去了小数，相当于**地板除**的效果：\n\n```javascript\nlet num1 = 6,\n    num2 = 7;\nnum1 = Math.floor(num1 / 2);\nnum2 = Math.floor(num2 / 2);\nconsole.log(num1, num2); // 3 3\n```\n\n### 2. 去掉二进制最右边的1\n\n对于二进制数 n：`n = n & (n - 1) `可以去掉 n 最右边的一个 1。\n\n```javascript\nlet n = 0b1011010;\nn = n & (n - 1);\nconsole.log(n.toString(2)); // 1011000\n// 把最右边的1去除了\n```\n\n### 3. 异或\n\n1. 0和任何数**异或** = 任何数本身\n2. 任何数和自身**异或** = 0\n3. 异或运算支持**交换律**、**结合律**\n\n利用上面三条，得到一堆数据中**成单**的数：\n\n```javascript\nconst nums = [1, 1, 2, 2, 3, 3, 4];\nlet res = 0;\nfor (let i = 0; i < nums.length; i++) {\n    res ^= nums[i];\n}\nconsole.log(res); // 4\n```\n\n## 5. 其他\n\n### 1. 判断两个值是否为同一个值-Object.is\n\n```javascript\nObject.is('foo', 'foo'); // true\nObject.is('foo', 'bar'); // false\nObject.is([], []); // false\n\nconst foo = { a: 1 };\nconst bar = { a: 1 };\nObject.is(foo, foo); // true\nObject.is(foo, bar); // false\n\nObject.is(null, null); // true\n\n// 特例\nObject.is(0, -0); // false\nObject.is(0, +0); // true\nObject.is(-0, -0); // true\nObject.is(NaN, 0 / 0); // true\n```\n\n",
      "date": 1622594932000,
      "post": true,
      "tags": ["LeetCode"],
      "title": "JavaScript 刷题常用方法总结（持续更新...）",
      "titleEng": "programming-note",
      "url": "https://lzxjack.top/post?title=programming-note"
    },
    {
      "_id": "2d44d6c26124ac2106b72a9b1904cd31",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "Demo",
      "content": "> 😃😃😃 本人能力有限，欢迎大佬指正改进~\n现在聊天室后台经常挂掉，就没再打开过了😅😅\n今后会加以改进，重新上线！🤠\n\n## 1. 前言\n\n最近和后端同学<a href=\"https://blog.csdn.net/asdasdde\" target=\"_blank\">I'M 渣渣</a>一起完成了一个 Demo 级的多人聊天室应用，实现了聊天室的基本功能。\n\n采用**前后端分离**方案，我负责前端代码的编写，<a href=\"https://blog.csdn.net/asdasdde\" target=\"_blank\">I'M 渣渣</a>实现了后端的接口。\n\n前后端都部署到了自己的**阿里云服务器**上。\n\n预览地址：<a href=\"http://47.110.144.145:82/\" target=\"_blank\">多人聊天室</a>\n\n源码仓库：<a href=\"https://github.com/lzxjack/chat-room\" target=\"_blank\">[前端]</a>，<a href=\"https://github.com/dwnb/chat_web\" target=\"_blank\">[后端]</a>\n\n![](https://img.lzxjack.top:99/20210601203923.png)\n\n![](https://img.lzxjack.top:99/20210601203933.png)\n\n## 2. 应用简介\n\n### 1. 主要功能\n\n1. 用户注册\n2. 用户登录\n3. 发送、接收消息\n4. 退出功能\n\n### 2. 主要用到的技术\n\n**前端：**\n\n1. React 脚手架`Create-React-App`\n2. 状态管理`redux` + `react-redux`等\n3. 前端路由 `React-Router`、路由鉴权\n4. 少量使用 `AntD` 组件库 （`Icon` 图标、`Notification` 通知提醒框、`Message` 全局提示）\n\n这里仅记录了前端的相关技术，后端基于`TCP`/`HTTP`协议，采用 C/C++实现，详情请查看<a href=\"https://blog.csdn.net/asdasdde/article/details/117453045\" target=\"_blank\">基于阿里云用 C/C++做了一个 http 协议的 web 聊天室的服务器——《干饭聊天室》</a>。\n\n## 3. 主要功能实现\n\n### 1. 路由鉴权\n\n将用户的登录状态放入`redux`，默认为`false`未登录。\n\n当`App`组件挂载时，判断用户登录状态，若已经登录，则直接跳转到`聊天室页面`；若未登录，则跳转到`注册/登录页面`，让用户登录。\n\n```javascript\n<Switch>\n    {this.props.loginState ? (\n        <Fragment>\n            <Route path=\"/room\" component={Room} />\n            <Redirect to=\"/room\" />\n        </Fragment>\n    ) : (\n        <Fragment>\n            <Route path=\"/welcome\" component={Welcome} />\n            <Redirect to=\"/welcome\" />\n        </Fragment>\n    )}\n</Switch>\n```\n\n### 2. 用户注册\n\n需要验证用户填写的用户名、密码是否符合规范，若不符合规范给出提示并直接`return`，若符合规范才发送注册请求给服务器。\n\n```javascript\n// 点击按钮，登录\nregister = () => {\n    // 数字字母组合，字母开头\n    const unameReg = /^[a-zA-Z][a-zA-Z0-9]{2,9}$/;\n    const uname = this.uname.value;\n    const pwd = this.pwd.value;\n    const pwdAgian = this.pwdAgian.value;\n    // 判断用户名是否符合规则\n    if (!unameReg.test(uname)) {\n        this.openUnameError();\n        return;\n    }\n    // 判断密码长度\n    if (!(pwd.length >= 6 && pwd.length <= 16)) {\n        this.openPwdError();\n        return;\n    }\n    // 判断两次输入的密码是否一致\n    if (pwd !== pwdAgian) {\n        this.openPwdUnEqual();\n        return;\n    }\n    // 调用接口，发送注册请求\n    const url = `${constUrl}/register`;\n    axios({\n        method: 'get',\n        url,\n        params: {\n            name: uname,\n            pwd,\n        },\n    })\n        .then(res => {\n            // 注册成功\n            if (res.data.register === 0) {\n                this.openRegisterSuccess();\n                this.uname.value = '';\n                this.pwd.value = '';\n                this.pwdAgian.value = '';\n                // 跳转到登录页\n                this.props.history.replace(`/welcome/login`);\n            } else {\n                // 注册失败，打开相应的提示框\n                switch (res.data.error) {\n                    case 0: {\n                        this.openUnameReuse();\n                        return;\n                    }\n                    default: {\n                        this.openOtherError();\n                        return;\n                    }\n                }\n            }\n        })\n        .catch(err => console.error(err));\n};\n```\n\n### 3. 用户登录\n\n登录功能没什么好说的，收集参数并发送请求就可以了，若登录成功，则给出提示，并更改`redux`中的登录状态为`true`，页面自动会跳转到聊天室页面。若登陆失败，则根据服务器返回的数据，给出相应提示。\n\n```javascript\nlogin = async () => {\n    const url = `${constUrl}/login`;\n    const name = this.inputUname.value;\n    const pwd = this.inputPwd.value;\n    axios({\n        method: 'get',\n        url,\n        params: {\n            name,\n            pwd,\n        },\n    })\n        .then(res => {\n            if (res.data.login === 0) {\n                this.props.login(name);\n                this.openLoginSuccess();\n                return;\n            }\n            switch (res.data.error) {\n                case 0: {\n                    this.openUnameNotFound();\n                    this.props.logout();\n                    return;\n                }\n                case 1: {\n                    this.openPwdError();\n                    this.props.logout();\n                    return;\n                }\n                case 2: {\n                    this.openOtherError();\n                    this.props.logout();\n                    return;\n                }\n                default:\n                    return;\n            }\n        })\n        .catch(err => console.error(err));\n```\n\n### 4. 接收消息\n\n接受消息功能，同样也是向服务器发送请求，获得所需消息，并展示在页面上。\n\n这里需要将展示聊天记录容器的滚动条自动调整到底部，详情见<a href=\"https://blog.csdn.net/Jack_lzx/article/details/117444212\" target=\"_blank\">JavaScript 实现容器滚动条默认出现在底部位置</a>。\n\n由于发送一次接收消息的请求，只能得到一次消息，所以我在`componentDidMount()`生命周期函数中，开启了一个定时器，每隔 1 秒就发送一次请求，获得所有消息，展示到页面上。由于 React 的`diff`算法，即使没有新的消息，频繁地发送请求，也不会有浪费太多性能。记得在`componentWillUnmount()`中，清除定时器。\n\n```javascript\ncomponentDidMount() {\n    this.getMsg();\n    this.msgUpdate = setInterval(() => {\n        this.getMsg();\n    }, 1000);\n}\ncomponentWillUnmount() {\n    // 清除定时器\n    clearInterval(this.msgUpdate);\n}\n```\n\n```javascript\n// 获取所需消息\ngetMsg = () => {\n    const url = `${constUrl}/information`;\n    const name = this.props.name;\n    axios({\n        method: 'get',\n        url,\n        params: { name },\n        // responseType: 'blob',\n    })\n        .then(res => {\n            console.log(res);\n            // 获取人数\n            const userCount = res.data.userCount;\n            this.setState({ userCount });\n            // 获取新数据\n            const newMsg = res.data.msg;\n            // 获取原数据\n            const oldMsg = this.state.msg;\n            if (res.data.information === 0) {\n                this.setState({ msg: [...oldMsg, ...newMsg] }, () => {\n                    // 滚动条自动到底部\n                    this.messageBox.scrollTop = this.messageBox.scrollHeight;\n                });\n            }\n        })\n        .catch(err => console.error(err));\n};\n```\n\n### 5. 发送消息\n\n发送请求之前，先判断输入框是否为空。不为空，再进行下一步，发送请求。\n\n成功发送消息后，调用一次`接收消息`函数，获得所有消息，即可将刚刚发送的消息立即展示到页面。\n\n```javascript\n   // 发送消息\n   sendMsg = () => {\n    const msg = this.editMsg.value;\n    const name = this.props.name;\n    if (msg === '') {\n        message.warning('请输入消息！');\n        return;\n    }\n    const url = `${constUrl}/information`;\n    axios({\n        method: 'post',\n        url,\n        params: {\n            msg,\n            name,\n            time: new Date().getTime(),\n            id: nanoid(),\n        },\n    })\n        .then(res => {\n            // console.log(res);\n            if (res.data.msg === 0) {\n                this.editMsg.value = '';\n                message.success('发送成功！');\n                // 调用获取所有消息函数\n                this.getMsg();\n            }\n        })\n        .catch(err => console.error(err));\n```\n\n### 6. 退出功能\n\n退出时，发送请求给服务器，告诉服务器有用户退出了、哪个用户退出了，主要用于展示当前在线人数。\n\n将`redux`中的登录状态改为`false`，页面自动跳转到`注册/登录`页面。\n\n```javascript\nlogout = () => {\n    const url = `${constUrl}/logout`;\n    const name = this.props.name;\n    axios({\n        method: 'get',\n        url,\n        params: {\n            name,\n        },\n    });\n    this.openLogout();\n    this.props.logout();\n};\n```\n\n## 4. 前端部署\n\n前端应用经过`React`脚手架打包后，部署到了阿里云服务器上。\n\n采用`nginx`服务器配置，配置如下：\n\n```c\nserver{\n        listen    80;\n        root /home/www/chatRoom;\n        server_name 47.110.144.145;\n        error_page 404 /index.html;\n\n        location /{}\n}\n```\n\n## 5. Todo\n\n由于本人能力有限，本 Demo 还有一些`BUG`没有解决：\n\n1. 当前在数人数显示模块没有正常工作，若用户不点击`退出`按钮，直接关闭浏览器页面，没有监听到用户的退出动作。\n2. 接收到的消息中，`空格`、`?`、`=`、`#`等字符会显示其编码，无法正常显示。\n\n**将来可能添加的功能：**\n\n1. 采用`token`验证用户身份\n\n2. 自定义背景图片切换\n\n3. 支持黑暗模式\n\n4. 适配移动端\n\n5. 支持上传头像\n\n6. 支持发送图片\n\n    ...\n\n\n",
      "date": 1622535486000,
      "post": true,
      "tags": ["React", "AntD", "HTTP", "Cpp"],
      "title": "基于React、C/C++，使用TCP/HTTP协议的多人聊天室Web应用",
      "titleEng": "chat-room",
      "url": "https://lzxjack.top/post?title=chat-room"
    },
    {
      "_id": "2d44d6c2612e121a0855649b3a7d1f60",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "默认情况下，设置父盒子有滚动条，若父盒子中的内容超出容器的高度时，滚动条默认在顶部，如图所示：\n\n![](https://img.lzxjack.top:99/20210601152209.gif)\n\n想要出现滚动条时，滚动条默认在底部，显示最新的内容，效果如下：\n\n![](https://img.lzxjack.top:99/20210601152303.gif)\n\n只需在**按钮**的单击事件里，添加一行代码即可：`div.scrollTop = div.scrollHeight`。\n\n完整代码：\n\n```html\n<div id=\"textBox\"></div>\n<button id=\"btn\">插入文字</button>\n<script>\n    const btn = document.getElementById('btn');\n    const div = document.getElementById('textBox');\n    btn.addEventListener('click', () => {\n        const time = new Date();\n        div.innerHTML = div.innerHTML + time + '</br>';\n        // 更改滚动条距离顶部的高度\n        div.scrollTop = div.scrollHeight;\n    });\n</script>\n```\n\n\n",
      "date": 1622533596000,
      "post": true,
      "tags": ["JavaScript", "CSS"],
      "title": "JavaScript 实现容器滚动条默认出现在底部位置",
      "titleEng": "scroll-bottom",
      "url": "https://lzxjack.top/post?title=scroll-bottom"
    },
    {
      "_id": "8937eaa9612e1fb6078b035006e4c863",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "杂七杂八",
      "content": "最近学习了 Linux 下的`TCP`网络编程，想实践一下，于是写了利用`TCP`协议、传输文件到阿里云服务器的**客户端程序**和**服务端程序**。\n\n首先来看看实现的效果。\n\n## 1. 实现一次传输\n\n虚拟机`Ubuntu`的`/桌面/TCP_File` 目录下，有如下文件：\n\n![](https://img.lzxjack.top:99/20201230205653.png)\n\n将其发送到自己的阿里云服务器的`/home/www/website/`目录下。\n\n首先在云服务器端运行`server`：\n\n![](https://img.lzxjack.top:99/20201230165517.png)\n\nUbuntu 系统运行`client`，并输入相应的参数（云服务器地址、文件目录/文件名）：\n\n![](https://img.lzxjack.top:99/20201230165750.png)\n\n按下回车后，各界面上的响应：\n\n-   客户端:\n\n    ![](https://img.lzxjack.top:99/20201230171027.png)\n\n-   服务端\n\n![](https://img.lzxjack.top:99/20201230171056.png)\n\n查看服务器端，文件已传输完成：\n\n![](https://img.lzxjack.top:99/20201230171213.png)\n\n## 2. 程序流程\n\n-   客户端\n\n    ![](https://img.lzxjack.top:99/20210103230607.png)\n\n-   服务端\n\n    ![](https://img.lzxjack.top:99/20210103230634.png)\n\n## 3. 文件传输源代码\n\n### 1. 客户端client.c\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n\n// 端口号6666\n#define PORT 6666\n// 定义buffer大小\n#define BUF_SIZE 1024\n// #define LISTEN_LENGTH 20\n\nint main(int argc, char *argv[])\n{\n    printf(\"客户端启动...\\n\");\n\n    // 简单判断用户输入的命令行参数，若不符合规范则给出提示\n    if (argc != 3)\n    {\n        // argv[0]是输入的第一个参数\n        printf(\"请输入正确的参数！\\n\");\n        printf(\"格式: %s 服务器主机地址 目录/文件名 \\n\", argv[0]);\n        printf(\"举例: %s 47.110.144.145 XXX.txt \\n\", argv[0]);\n        // exit(1)表示异常退出\n        exit(1);\n    }\n\n    int sockfd, fp;\n    // int fp;\n    int recvBytes, sendBytes, readBytes;\n    // 定义buffer\n    unsigned char buffer[BUF_SIZE];\n    // 定义sockaddr_in结构体\n    struct sockaddr_in serv_addr;\n    struct hostent *host;\n\n    // 打开要发送的文件\n    // argv[2]是输入的第三个参数\n    // 打开文件方式为O_RDONLY只读方式\n    if ((fp = open(argv[2], O_RDONLY)) == -1)\n    {\n        printf(\"打开%s文件失败！\\n\", argv[2]);\n        exit(1);\n    }\n\n    printf(\"打开%s文件成功！\\n\", argv[2]);\n\n    // 解析hostname\n    // argv[1]是输入的第二个参数\n    if ((host = gethostbyname(argv[1])) == NULL)\n    {\n        printf(\"hostname错误！\\n\");\n        exit(1);\n    }\n\n    // 创建socket流式套接字\n    // AF_INET允许与远程主机通信\n    // SOCK_STREAM代表流式套接字，采用TCP协议\n    // 失败返回-1\n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        printf(\"创建socket失败！\\n\");\n        exit(1);\n    }\n    printf(\"创建socket成功！\\n\");\n\n    // 请求连接服务器\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n    serv_addr.sin_addr = *((struct in_addr *)host->h_addr);\n    // 将sin_zero清零\n    bzero(&(serv_addr.sin_zero), 8);\n    // 调用connect(),失败返回-1\n    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) == -1)\n    {\n        printf(\"连接服务器失败！\\n\");\n        exit(1);\n    }\n    printf(\"连接服务器成功！\\n\");\n\n    // ------------------通信阶段------------------\n\n    // 1.发送文件名\n    // 将buffer清零\n    memset(buffer, 0, sizeof(buffer));\n    // argv[2]是输入的第三个参数，文件名\n    strcpy(buffer, argv[2]);\n    // 调用send()\n    send(sockfd, buffer, strlen(buffer) + 1, 0);\n    printf(\"发送文件名完成！\\n\");\n\n    // 将buffer清零\n    memset(buffer, 0, sizeof(buffer));\n    // 调用recv()\n    recvBytes = recv(sockfd, buffer, sizeof(buffer), 0);\n\n    // 2.发送数据\n    // 将buffer清零\n    memset(buffer, 0, sizeof(buffer));\n    printf(\"开始发送数据...\\n\");\n    // 读文件，读取的字节数为buffer的长度\n    // 成功返回当前读取的字节数\n    // 如果返回值大于0，说明可能还没读取完毕，则继续执行一次\n    while ((readBytes = read(fp, buffer, BUF_SIZE)) > 0)\n    {\n        // 调用send(),将这次读取的数据发送\n        // readBytes 为这次读取的字节数\n        sendBytes = send(sockfd, buffer, readBytes, 0);\n        // 如果出错，返回-1，给出提示并退出\n        if (sendBytes < 0)\n        {\n            printf(\"× 发送文件失败！\\n\");\n            exit(1);\n        }\n        // 将buffer清零\n        memset(buffer, 0, sizeof(buffer));\n    }\n    printf(\"√ 发送文件成功！\\n\");\n\n    // 关闭文件\n    close(fp);\n    // 关闭套接字\n    close(sockfd);\n    printf(\"客户端退出...\\n\");\n}\n```\n\n### 2. 服务端server.c\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n\n// 端口号6666\n#define PORT 6666\n// 定义buffer大小\n#define BUF_SIZE 1024\n#define Name 100\n// 定义listen中请求队列的大小\n#define LISTEN_LENGTH 20\n\nvoid main()\n{\n    // 定义sockaddr_in结构体\n    struct sockaddr_in server_sockaddr, client_sockaddr;\n    int size, recvBytes, writeBytes, fp;\n    int sockfd, listenfd;\n    int i = 0;\n\n    unsigned char filePath[Name], filePath1[Name], filePath2[Name];\n    // unsigned char filePath1[Name], filePath2[Name];\n    // 定义buffer\n    unsigned char buffer[BUF_SIZE];\n\n    printf(\"服务端启动...\\n\");\n\n    // 创建socket流式套接字,失败返回-1\n    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n    {\n        printf(\"socket创建失败！\\n\");\n        exit(1);\n    }\n    printf(\"socket创建成功！listenfd=%d\\n\", listenfd);\n\n    // 绑定地址及端口\n    server_sockaddr.sin_family = AF_INET;\n    server_sockaddr.sin_port = htons(PORT);\n    server_sockaddr.sin_addr.s_addr = INADDR_ANY;\n    // 将sin_zero清零\n    bzero(&(server_sockaddr.sin_zero), 8);\n    // 调用bind()，失败返回-1\n    if ((bind(listenfd, (struct sockaddr *)&server_sockaddr, sizeof(struct sockaddr))) == -1)\n    {\n        printf(\"绑定失败！\\n\");\n        exit(1);\n    }\n    printf(\"绑定成功！\\n\");\n\n    // 监听客户端请求\n    // 调用listen(),失败返回-1\n    if (listen(listenfd, LISTEN_LENGTH) == -1)\n    {\n        printf(\"监听失败！\\n\");\n        exit(1);\n    }\n    printf(\"监听连接请求...\\n\");\n\n    // 接收连接\n    size = sizeof(client_sockaddr);\n    // 调用accept()，接收请求\n    sockfd = accept(listenfd, (struct sockaddr *)&client_sockaddr, &size);\n    if (sockfd == -1)\n    {\n        printf(\"连接失败！\\n\");\n        exit(1);\n    }\n    printf(\"连接成功！\\n\");\n\n    // ------------------通信阶段------------------\n    // 1.传输文件名\n    // 将buffer清零\n    bzero(buffer, BUF_SIZE);\n    // 调用recv()，接受数据保存在buffer\n    recvBytes = recv(sockfd, buffer, BUF_SIZE, 0);\n    // 把buffer中的数据复制到filePath\n    strcpy(filePath, buffer);\n\n    // 将buffer清零\n    memset(buffer, 0, sizeof(buffer));\n    // 将反馈信息放入buffer\n    strcpy(buffer, \"文件名接收成功！\\n\");\n    // 应答\n    send(sockfd, buffer, strlen(buffer) + 1, 0);\n\n    // 2.编辑文件名编辑，去除带'/'的路径\n    // 判断是否输入了目录\n    if (strchr(filePath, '/') != NULL)\n    {\n        // 输入了目录，作处理，去掉'/'\n        strcpy(filePath1, strrchr(filePath, '/'));\n        for (i = 1; filePath1[i] != '\\0'; i++)\n        {\n            filePath2[i - 1] = filePath1[i];\n            filePath2[i] = '\\0';\n        }\n    }\n    else\n        // 没有输入目录，直接赋值\n        strcpy(filePath2, filePath);\n\n    // 3.服务端创建文件\n    // 创建文件，并以读写方式打开\n    // 0777表示所有者、组成员和其他用户都有读、写和执行权限\n    fp = open(filePath2, O_CREAT | O_RDWR, 0777);\n    // 创建失败返回-1\n    if (fp == -1)\n    {\n        printf(\"%s文件创建失败！\\n\", filePath2);\n        exit(1);\n    }\n    printf(\"%s文件创建成功！\\n\", filePath2);\n\n    // 4.传输文件的数据\n    // 将buffer清零\n    bzero(buffer, BUF_SIZE);\n    printf(\"开始接收数据...\\n\");\n\n    // 调用recv(),成功时返回成功接受的字节个数\n    // 如果返回值大于0，则可能还没有接收完毕，继续重复执行\n    // 接受的数据放入buffer\n    while (recvBytes = recv(sockfd, buffer, BUF_SIZE, 0))\n    {\n        // 接收过程出现错误，给出提示\n        if (recvBytes < 0)\n        {\n            printf(\"接收文件失败！\\n\");\n            break;\n        }\n        // 将接受的数据写入文件中，写的个数为接受的字节数\n        // 成功时返回实际写入的数据\n        writeBytes = write(fp, buffer, recvBytes);\n\n        // 实际写入数据 < 接受的数据，则传输错误\n        if (writeBytes < recvBytes)\n        {\n            printf(\"传输数据失败！\\n\");\n            break;\n        }\n        // 将buffer清零\n        bzero(buffer, BUF_SIZE);\n    }\n    printf(\"√ 接收文件成功！\\n\");\n\n    // 关闭文件\n    close(fp);\n    // 关闭连接套接字\n    close(sockfd);\n    // 关闭监听套接字\n    close(listenfd);\n    printf(\"服务端退出...\\n\");\n}\n```\n\n\n",
      "date": 1621842489000,
      "post": true,
      "tags": ["TCP", "Linux"],
      "title": "C语言：实现Linux系统下利用TCP协议传输文件到阿里云服务器",
      "titleEng": "tcp",
      "url": "https://lzxjack.top/post?title=tcp"
    },
    {
      "_id": "2d44d6c26124bbda06b999a323e959bc",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "Demo",
      "content": "> 😃😃😃 本人能力有限，欢迎大佬指正改进~\n\n\n## 1. 前言\n\n最近写了一款基于`React`脚手架开发的 TodoList 网页应用，主要记录自己的代办事务，方便查看、管理、安排时间，提升效率。\n\nPC Web 端 + 移动端 + 黑暗模式，可日常使用。\n\n没有复杂的界面，没有繁琐的设置，开箱即用，专注于任务管理。\n\n😛**应用网址**：<a href=\"https://lzxtodo.top\" target=\"_blank\">TodoList</a>\n\n😜**源码仓库**：<a href=\"https://github.com/lzxjack/React-TodoList\" target=\"_blank\">[GitHub]</a>\n\n![](https://img.lzxjack.top:99/20210602113432.png)\n\n![](https://img.lzxjack.top:99/20210602113848.png)\n\n## 2. 食用指南\n\n`fork`本项目后，需要在<a href=\"https://console.cloud.tencent.com/tcb/env\" target=\"_blank\">腾讯云开发 CloudBase</a>创建一个云开发环境，选择`空模板`即可：\n\n![](https://img.lzxjack.top:99/20210602191232.png)\n\n![](https://img.lzxjack.top:99/20210602191349.png)\n\n创建完成后，获取到云环境的`环境id`，填入到项目的相应位置：\n\n![](https://img.lzxjack.top:99/20210602191546.png)\n\n在`登录授权`模块中，打开`邮箱登录`和`用户名密码登录`，并根据提示，**配置邮箱登录**：\n\n![](https://img.lzxjack.top:99/20210602191714.png)\n\n为了能在**React 脚手架**中本地预览项目，需要将`localhost:3000`添加到`安全配置`中的`WEB安全域名`中。如果有自定义域名，也将自定义域名添加进来。否则会产生跨域问题。\n\n![](https://img.lzxjack.top:99/20210602192040.png)\n\n这样下来，就可以`yarn start`或者`npm start`启动项目啦~\n\n## 3. 应用简介\n\n### 1. 主要功能\n\n-   邮箱注册、登录\n-   注册邮箱地址、密码的验证\n-   邮箱登录后，可绑定用户名，选择使用用户名登录同一账号\n-   退出功能\n-   页脚显示一句诗词（<a href=\"https://www.jinrishici.com/\" target=\"_blank\">今日诗词</a>）\n-   实时时间显示\n-   黑暗模式、白天模式切换，下次登录自动切换上次应用的模式\n-   用户累计完成的任务计数\n-   上传用户头像、显示头像\n-   修改用户昵称、显示昵称\n-   根据时间段显示不同的欢迎语句\n-   添加、修改近期任务、长期任务\n-   完成任务\n-   删除任务\n-   近期任务转为长期任务\n-   长期任务转为近期任务\n-   清空所有已完成任务\n-   按钮提示功能\n-   适配移动端\n-   移动端可将网页添加到主屏幕，实现类似 App 效果\n\n### 2. 主要用到的技术\n\n**前端**：\n\n-   `React`脚手架`Create-React-App`\n-   状态集中管理工具`Redux`\n-   前端路由`React-Router`、集中式路由管理`react_router_config`、路由鉴权\n-   少量使用`AntD`组件库 （`Icon`图标、`Tooltip`文字提示、`Notification`通知提醒框、`Message`全局提示）\n-   `LocalStorage`客户端存储\n\n**后端**：\n\n后端使用腾讯云`CloudBase`云端一体化后端云服务，包括：\n\n-   用户管理：注册、登录\n-   数据库：存放用户任务数据\n-   云存储：存放用户上传的头像\n-   网站托管\n\n## 4. 主要功能实现\n\n### 1. 登录前后的路由鉴权\n\n未登录的用户只能访问到登录/注册页面，已登录的用户自动跳转到任务管理页面。用户的登录信息保存在客户端`LocalStorage`，整个应用初始化时，首先判断用户是否登录，将是否登录的信息保存在`redux`中。应用根据`redux`中的状态渲染`登录/注册组件`or`任务管理组件`，其中`任务管理组件`必须已登录才会渲染。\n\n登录时，调用`CloudBase`的用户管理接口；退出时，清空`LocalStorage`中的数据即可。用户成功登录、退出，分别更新`redux`状态。\n\n### 2. 任务列表展示\n\n用户成功登录时，向数据库发起请求，获取用户的所有任务，保存在`redux`中。各个组件根据`redux`中任务的不同属性、分别渲染`近期任务`、`长期任务`、`已完成任务`即可。\n\n### 3. 任务添加、编辑、删除\n\n添加新任务时，获取到用户输入的内容。向服务器发起请求，添加新任务，返回的数据中拿到数据的`ID`，将输入的内容、`ID`组成一条数据，添加到`redux`状态中，状态变化，驱动页面更新。\n\n编辑、删除任务时，只要获取到用户编辑数据的`ID`，先在`redux`中完成修改，可以较快地更新页面，提升用户体验。再向服务器发起请求，执行同样的操作。\n\n完成任务实际上也是编辑任务，只是修改了任务对象的属性值。\n\n### 4. 累计完成任务计数、黑暗模式数据\n\n用户登录成功时，向数据库发送请求，查找是否有存放用户数据的文档。若无，则代表是第一次登录，则创建一条新文档，用于存放用户的累计任务完成数、是否黑暗模式数据，同时初始化`redux`；若有，则不是第一次登陆，读取数据库中的累计任务完成数、是否黑暗模式数据，放入`redux`中。页面根据`redux`中的数据，显示用户的累计任务完成数，并展示黑暗模式或白天模式。\n\n### 5. 上传、修改头像\n\n使用`<input />`标签选择文件，触发`onChange`后，验证选择的文件类型、大小等数据，满足一定条件后，才能将图片上传到`CloudBase`的云存储，返回图片的链接，放入`redux`，页面根据链接展示头像，实现预览功能。用户满意后，再点击`上传`按钮，发送网络请求，将头像链接保存在`CloudBase`的用户信息中。\n\n每次成功登录后，都会发送网络请求，获得用户的头像链接，保存在`redux`，页面根据链接展示用户头像。\n\n## 5. 未来计划\n\n由于本人能力有限，应用还有很多可以再完善的地方，将来可能实现的计划（功能）：\n\n1. 使用`electron`技术，将应用做成 PC 客户端\n\n2. 利用`React Native`，将应用做成移动端应用\n\n3. 开发微信小程序端\n\n4. 添加自定义分类功能\n\n5. 添加自定义更换背景图片\n\n6. 完成`TypeScript`重构\n\n    ...\n\n\n",
      "date": 1621675668000,
      "post": true,
      "tags": ["React", "AntD", "CloudBase"],
      "title": "一款使用React、腾讯云开发的TodoList待办事项Web应用",
      "titleEng": "todolist",
      "url": "https://lzxjack.top/post?title=todolist"
    },
    {
      "_id": "8937eaa96124f71f061bdc440be9852d",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。\n\n通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是**周期性**的，即垃圾回收程序**每隔一定时间**就会自动运行。\n\n垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何**标记**未使用的变量也许有不同的实现方式。常见两种主要的**标记策略**：**标记清理**和**引用计数**。\n\n## 1. 标记清理\n\nJavaScript 最常用的垃圾回收策略是**标记清理**（mark-and-sweep）。当变量进入上下文，会被加上**存在于上下文中**的标记。当变量离开上下文时， 也会被加上**离开上下文**的标记。但给变量加标记的方式有很多种，标记过程不重要，关键是策略。\n\n垃圾回收程序运行的时候，**标记**内存中存储的所有变量。然后，它会**将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。**在此之后**再被加上标记的变量就是待删除的了**，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。\n\n## 2. 引用计数\n\n另一种没那么常用的垃圾回收策略是**引用计数**（reference counting）。思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到这个值了，可以安全地收回其内存了。垃圾回收程序**下次运行**的时候就会**释放引用数为 0 的值的内存**。\n\n但引用计数在循环引用时，会有严重的问题。如果两个对象通过各自的属性相互引用，那么他们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。\n\n把变量设置为`null`会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时， 这些值就会被删除，内存也会被回收。\n\n## 3. 性能\n\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。\n\n因此最好的办法是：**无论什么时候开始收集垃圾，都能让它尽快结束工作。**\n\n在某些浏览器中是可以主动触发垃圾回收的，但不推荐。\n\n## 4. 内存管理\n\n将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是**保证在执行代码时只保存必要的数据**。如果数据不再必要，那么把它设置为`null`，从而**释放其引用**。这也可以叫作**解除引用**。这个建议最适合**全局变量**和**全局对象的属性**。因为局部变量在超出作用域后会被**自动**解除引用。\n\n不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于**确保相关的值已经不在上下文里了**，因此它在**下次垃圾回收时**会被回收。\n\n### 1. 通过const和let声明提升性能\n\n**在块作用域比函数作用域更早终止的情况下**，`const`和`let`相比于使用`var`，使用这两个新关键字会更早地让垃圾回收程序介入，尽早回收应该回收的内存。\n\n### 2. 隐藏类和删除操作\n\nV8 在将解释后的 JavaScript 代码编译为实际的机器码时会利用`隐藏类`。能够共享相同隐藏类的对象性能会更好。\n\n如下代码：\n\n```javascript\nfunction Article() {\n    this.title = 'Inauguration Ceremony Features Kazoo Band';\n}\nlet a1 = new Article();\nlet a2 = new Article();\n```\n\n两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。\n\n如果加了下面一行代码：\n\n```javascript\na2.author = 'Jake';\n```\n\n此时两个`Article`实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能**对性能产生明显影响**。\n\n解决方案就是避免 JavaScript 的先创建再补充（ready-fire-aim）式的动态属性赋值，并 构造函数中一次性声明所有属性：\n\n```javascript\nfunction Article(opt_author) {\n    this.title = 'Inauguration Ceremony Features Kazoo Band';\n    this.author = opt_author;\n}\nlet a1 = new Article();\nlet a2 = new Article('Jake');\n```\n\n这样，两个实例可以共享一个隐藏类，带来潜在的性能提升。\n\n使用`delete`关键字，动态删除属性与动态添加属性导致的后果一样：\n\n```javascript\nfunction Article() {\n    this.title = 'Inauguration Ceremony Features Kazoo Band';\n    this.author = 'Jake';\n}\nlet a1 = new Article();\nlet a2 = new Article();\ndelete a1.author;\n```\n\n即使两个实例使用了同一个构造函数，它们也**不再共享一个隐藏类**。最佳实践是把不想要的属性设置为`null`。这样可以保**持隐藏类不变**和**继续共享**，同时也能达到删除引用值供垃圾回收程序回收的效果。\n\n```javascript\na1.author = null;\n```\n\n### 3. 内存泄漏\n\n（1）意外声明全局变量\n\n```javascript\nfunction setName() {\n    name = 'Jack';\n}\n```\n\n解释器会把变量`name`当作`window`的属性来创建（相当于`window.name = 'Jack'`）。 可想而知，在`window`对象上创建的属性，只要`window`本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上`var`、`let`或`const`关键字即可。\n\n（2）定时器\n\n```javascript\nlet name = 'Jake';\nsetInterval(() => {\n    console.log(name);\n}, 100);\n```\n\n定时器的回调通过**闭包**引用了外部变量，只要定时器一直运行，回调函数中引用的`name`就会一直占用内存。\n\n（3）闭包\n\n```javascript\nlet outer = function () {\n    let name = 'Jake';\n    return function () {\n        return name;\n    };\n};\n```\n\n调用`outer()`会导致分配给`name`的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理`name`，因为闭包一直在引用着它。\n\n### 4. 静态分配与对象池\n\n为了提升 JavaScript 性能，一个关键问题就是如何减少浏览器执行**垃圾回收的次数**。如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。\n\n浏览器决定何时运行垃圾回收程序的一个标准就是**对象更替的速度**。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。\n\n使用对象池，在初始化的某一时刻，创建一个对象池，用来管理一组可回收的对象。 应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。\n\n避免动态分配操作，避免先删除再创建的操作，使用**静态分配**。\n\n\n",
      "date": 1621402854000,
      "post": true,
      "tags": ["JavaScript", "性能优化"],
      "title": "浅谈JavaScript中的垃圾回收机制",
      "titleEng": "garbage-collection",
      "url": "https://lzxjack.top/post?title=garbage-collection"
    },
    {
      "_id": "8937eaa96124bc9506138e2717d16c66",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "`HTTP cookie`通常也叫作`cookie`，最初用于在客户端存储会话信息。这个规范要求服务器在响应`HTTP`请求时，通过发送`Set-Cookie HTTP`头部包含会话信息。\n\n这些发送回服务器的额外信息可用于**唯一标识**发送请求的客户端。\n\n## 1. 限制\n\n`cookie`是与特定域绑定的。设置`cookie`后，它会与请求一起发送到创建它的域。这个限制能保证`cookie`中存储的信息只对被认可的接收者开放，不被其他域访问。\n\n因为`cookie`存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，`cookie`也不会占用太多磁盘空间。\n\n只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：\n\n-   不超过 300 个`cookie`\n-   每个`cookie`不超过 4096 字节\n-   每个域不超过 20 个`cookie`\n-   每个域不超过 81920 字节\n\n如果`cookie`总数超过了单个域的上限，浏览器就会删除之前设置的`cookie`。\n\n## 2. 构成\n\n`cookie`在浏览器中是由以下参数构成的：\n\n-   名称\n\n    `cookie`名称不区分大小写。必须经过`URL`编码。\n\n-   值\n\n    必须经过`URL`编码。\n\n-   域\n\n    `cookie`有效的域。\n\n-   路径\n\n    请求`URL`中包含这个路径才会把`cookie`发送到服务器。\n\n-   过期时间\n\n    默认情况下， 浏览器会话结束后会删除所有`cookie`。不过，也可以设置删除`cookie`的时间。把过期时间设置为过去的时间会立即删除`cookie`。\n\n-   安全标志\n\n    设置之后，只在使用`SSL`安全连接的情况下才会把`cookie`发送到服务器。\n\n但是，**域**、**路径**、**过期时间**和**安全标志**用于告诉浏览器什么情况下应该在请求中包含`cookie`。 这些参数并不会随请求发送给服务器，实际发送的只有`cookie`的名称、值。\n\n## 3. 子cookie\n\n为绕过浏览器对每个域`cookie`数的限制，有些开发者提出了子`cookie`的概念。\n\n子`cookie`是使用`cookie`的值在单个`cookie`中存储多个`名/值`对。\n\n## 4. 注意事项\n\n因为所有`cookie`都会作为请求头部由浏览器发送给服务器，所以在`cookie`中保存大量信息可能会影响特定域浏览器请求的性能。保存的`cookie`越大，请求完成的时间就越长。\n\n另外，不要在`cookie`中存储重要或敏感的信息。\n\n\n",
      "date": 1621394474000,
      "post": true,
      "tags": ["浏览器"],
      "title": "客户端存储cookie详解",
      "titleEng": "cookie",
      "url": "https://lzxjack.top/post?title=cookie"
    }
  ],
  "requestId": "d56603cebf5b1"
}
