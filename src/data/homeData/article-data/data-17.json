{
  "data": [
    {
      "_id": "8937eaa961262ec30644c7a92a1fdf32",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 数据结构与算法",
      "content": "## 1. 概念\n\n字典也是一种存储**唯一值**的数据结构，但它是以**键值对**的形式来存储。\n\n字典的常用操作：增、删、改、查。\n\n## 2. 实现\n\nJavaScript 中可用`Map()`表示字典：\n\n```javascript\nconst m = new Map();\n\n// 增\nm.set('a', 'aaa');\nm.set('b', 'bbb');\nm.set('c', 'ccc');\n// Map(3) { 'a' => 'aaa', 'b' => 'bbb', 'c' => 'ccc' }\n\n// 删\nm.delete('b');\n// Map(2) { 'a' => 'aaa', 'c' => 'ccc' }\nm.clear();\n// Map(0) {}\n\n// 改\nm.set('a', 'aaa');\nm.set('b', 'bbb');\nm.set('a', '11111');\n// Map(2) { 'a' => '11111', 'b' => 'bbb' }\n\n// 查\nconsole.log(m.get('a'));\n// 11111\n```\n\n\n",
      "date": 1615607450000,
      "post": true,
      "tags": ["JavaScript", "数据结构"],
      "title": "JavaScript 数据结构 —— 字典",
      "titleEng": "map",
      "url": "https://lzxjack.top/post?title=map"
    },
    {
      "_id": "8937eaa961262e590644b4fb569f895b",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 数据结构与算法",
      "content": "## 1. 概念\n\n链表是多个元素组成的列表，元素存储**不连续**， 用`next`指针连在一起。\n\n![](https://img.lzxjack.top:99/20210313203615.png)\n\n## 2. 实现\n\n在 JavaScript 中可以用`Object`模拟链表：\n\n```javascript\nconst a = { val: 'a' };\nconst b = { val: 'b' };\nconst c = { val: 'c' };\nconst d = { val: 'd' };\na.next = b;\nb.next = c;\nc.next = d;\n\n// 遍历链表\nlet p = a; // 声明指针 指向链表头部\nwhile (p) {\n    console.log(p.val);\n    p = p.next;\n}\n\n// 插入(c、d之间插入e)\nconst e = { val: 'e' };\nc.next = e;\ne.next = d;\n\n// 删除e\nc.next = d;\n```\n\n\n",
      "date": 1615603721000,
      "post": true,
      "tags": ["JavaScript", "数据结构"],
      "title": "JavaScript 数据结构 —— 链表",
      "titleEng": "linked-list",
      "url": "https://lzxjack.top/post?title=linked-list"
    },
    {
      "_id": "14139e126124f48706ba59ca7cd613bc",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "## 问题及原因\n\n在 JavaScript 中，如果判断`0.1 + 0.2 === 0.3`，结果是`false`，就像这样：\n\n```javascript\nconsole.log(0.1 + 0.2 === 0.3); // false\nconsole.log(0.1 + 0.2); // 0.30000000000000004\n```\n\n这是怎么回事呢？`0.1 + 0.2`竟然不等于`0.3`？是程序出问题了吗？\n\n原来 JavaScript 采用的是`IEEE754的64位双精度`版本，由三部分组成：\n\n- 1 位数符：标记正负，0 为正，1 为负\n- 11 位阶码：数字的整数部分\n- 52 位尾数：数字的小数部分\n\n`0.1`的二进制表示为：\n\n```javascript\n0.1 = 0.0(0011)(0011)(0011)(0011)(0011)....\n```\n\n是无限循环小数，而在 JavaScript 中只能存储 52 位小数，那么`0.1`的小数位在第 52 位时就需要判读进位（第 53 位为 1 就+1，为 0 则不进位），则`0.1`在 JavaScript 中存储的实际为：\n\n```javascript\n0.1 = 0.0(0011)(0011)...(0011)010\n```\n\n第 52 位进位了。\n\n同理`0.2`在 JavaScript 中存储的为：\n\n```javascript\n0.2 = 0.(0011)(0011)...(0011)\n```\n\n不需要进位。\n\n那么将`0.1`和`0.2`在 JavaScript 中存储的表示值相加得到：\n\n```javascript\n0.000110011001100110011001100110011001100110011001101 + 0.0011001100110011001100110011001100110011001100110011;\n-----------------------------------------------------------0.0100110011001100110011001100110011001100110011001101;\n```\n\n`0.0100110011001100110011001100110011001100110011001101`这个**二进制**数刚好等于**十进制**的`0.30000000000000004`：\n\n![](https://img.lzxjack.top:99/20210313095537.png)\n\n这样看来，程序并没有出问题，这是由于浮点数精度问题造成的，不仅是 JavaScript，所有采用`IEEE754的64位双精度`的语言都是如此。\n\n## 解决办法\n\n在 JavaScript 中，可用`Number.EPSILON`解决。\n\n`Number.EPSILON`表示`1`与`Number`可表示的大于`1`的**最小的浮点数**之间的差值。\n\n`Number.EPSILON`的值为`2^-52`。\n\n判断方法：\n\n```javascript\nconst num = 0.1 + 0.2;\nconsole.log(num - 0.3 <= Number.EPSILON); // true\n```\n\n\n",
      "date": 1615601720000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript中为什么0.1+0.2!=0.3？附解决办法！",
      "titleEng": "float",
      "url": "https://lzxjack.top/post?title=float"
    },
    {
      "_id": "cd045e75611f6c9f06cd2b060dba8b3e",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "Hexo 博客相关",
      "content": ">从**2021-8-20**开始，此**网站博客**为自己写的**React前后台博客系统**。以下内容是本人之前的解决方案，现在**可能**不适用。\n\n## 1. 本地电脑\n\n### 1. 安装nodeJS\n\n浏览器进入<a href=\"https://nodejs.org/en/\" target=\"_blank\">NodeJS 官网</a>，安装 LTS（Long Term Support）版本。\n\n![](https://img.lzxjack.top:99/20201214153754.png)\n\n按住`win+R`，输入`cmd`，进入 cmd 命令行工具，输入`node -v`查看 node 版本，\n\n![](https://img.lzxjack.top:99/20201214153948.png)\n\n若出现版本信息，则说明 node 安装成功。\n\n### 2. 安装Hexo\n\n在 cmd 命令行中输入`npm install hexo-cli -g`，安装 hexo。完成后输入`hexo -v`查看版本信息，确认安装成功。\n\n![](https://img.lzxjack.top:99/20201214162153.png)\n\n-   初始化根目录\n\n    创建文件夹`Hexo-Blog`，在 cmd 命令行中进入该目录，输入`hexo init`初始化根目录。\n\n    ![](https://img.lzxjack.top:99/20201214161509.png)\n\n-   本地查看\n\n    输入`hexo g&&hexo s`（生成静态文件，并开启本地服务器）\n\n    ![](https://img.lzxjack.top:99/20201214161646.png)\n\n    根据提示，在浏览器中打开`http://localhost:4000`，即可看到初始的博客页面。\n\n    ![](https://img.lzxjack.top:99/20201214161919.png)\n\n-   美化\n\n对自己的博客进行更改样式、美化、增删功能、发布文章等操作，就不展开介绍了。\n\n## 2. 购买域名\n\n-   购买域名\n\n    在阿里云上以学生认证优惠购买了`lzxjack.top`这个域名。\n\n    ![](https://img.lzxjack.top:99/20201218140113.png)\n\n-   域名备案\n\n    域名绑定国内的服务器，必须要进行备案操作，否则将无法访问。\n\n    ![](https://img.lzxjack.top:99/20201218140217.png)\n\n    ![](https://img.lzxjack.top:99/20201218140337.png)\n\n    从提交备案信息，到管局审核通过，备案号下来一共花了不到 10 天的时间。\n\n-   域名解析\n\n    域名解析是把域名指向网站空间 IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP 地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替 IP 地址标识站点地址。\n\n    ![](https://img.lzxjack.top:99/20201218141015.png)\n\n    -   主机记录中，`www`代表域名前加`www.`，如`www.lzxjack.top`，`@`就代表`lzxjack.top`，这样两个地址都能访问到服务器了\n    -   记录类型`A`是指，将域名指向一个`IPV4`地址\n    -   记录值就是服务器的公网 IP\n\n## 3. 服务器端\n\n### 1. 购买服务器\n\n为了让其他用户在自己的客户端访问到自己的博客，就需要将博客部署到服务器上，其他用户通过访问服务器的公网 IP 来访问到服务器上的资源。若绑定了域名，还可以通过域名访问。\n\n通过<a href=\"https://developer.aliyun.com/plan/grow-up\" target=\"_blank\">阿里云开发者成长计划</a>，购买了`轻量应用服务器`。在系统的选择上，作为服务器系统，CentOS 稳定、强大，所以系统镜像选择了 Linux 系统的 CentOS 7.3 版本。\n\n![](https://img.lzxjack.top:99/20201214163538.png)\n\n### 2. 配置端口\n\n点击云服务器管理页面的`防火墙`，再点击`添加规则`。\n\n![](https://img.lzxjack.top:99/20210301193255.png)\n\n要使用 HTTP 协议访问服务器，需要在服务器端监听 80 端口，因为 80 端口是服务器的默认端口号。而阿里云服务器默认关闭 80 端口，则需要我们手动打开监听 80 端口。另外，服务器端配置 Git 时需要使用 SSH 协议进行本地与服务器的连接，需要服务器监听 22 端口，也需要手动打开。\n\n![](https://img.lzxjack.top:99/20201215122715.png)\n\n### 3. 服务器环境搭建\n\n此步骤需要在云服务器上完成，具体方法可以使用远程连接，也可以使用 Xshell 客户端进行连接。\n\n![](https://img.lzxjack.top:99/20210301193413.png)\n\n-   安装 nginx\n\n    1. 切换到 root 帐号\n\n        ```\n        sudo su root\n        ```\n\n        ![](https://img.lzxjack.top:99/20201210215126.png)\n\n    2. 需要使用 nginx 作为 Web 服务器，所以我们首先要安装 nginx。可以使用 yum 命令直接进行安装。\n\n        ```\n        yum install -y nginx\n        ```\n\n        ![](https://img.lzxjack.top:99/20201210215244.png)\n\n    3. 安装完成后启动 nginx 服务器\n\n        ```\n        systemctl start nginx\n        ```\n\n        ```\n        systemctl enable nginx\n        ```\n\n        ![](https://img.lzxjack.top:99/20201210215400.png)\n\n-   建立博客根目录\n\n    将博客的页面文件放在`/home/www/website/`路径下，需要先创建这些文件。\n\n    ```\n    cd /home\n    mkdir www\n    cd www\n    mkdir website\n    ```\n\n    查看创建的文件：\n    ![](https://img.lzxjack.top:99/20201215170011.png)\n\n-   配置 nginx 路由\n\n    建立了博客的根目录后，需要将 nginx 服务器指向这个根目录地址，才能访问到博客页面，所以需要修改 nginx 的配置文件。\n\n    阿里云默认的库下载的是基于 fedora 的 nginx，查阅资料发现，默认配置文件位于` etc/nginx/`下的`nginx.conf `。\n\n    查看 nginx 的默认配置文件：\n\n    ```\n    cd ~\n    cd /etc/nginx\n    ls\n    ```\n\n    ![](https://img.lzxjack.top:99/20201215125019.png)\n\n    文件中的`nginx.conf`就是默认配置文件。\n\n    但不采用直接修改 nginx 配置文件的方式，而是新建一个文件夹，将自己的配置写在新建的**文件夹**中。再利用`include`，在配置文件`nginx.conf`中将文件夹引入进来即可。这样若有新的需求时，只需在文件夹中添加新需求的配置文件即可，不会再次修改配置文件`nginx.conf`，提高效率。\n\n    切换`/etc/nginx/`目录，在此目录下创建一个文件夹`vhost`：\n\n    ```\n    cd /etc/nginx\n    mkdir vhost\n    cd vhost\n    ```\n\n    ![](https://img.lzxjack.top:99/20201210215654.png)\n\n    输入`vim blog.conf`新建`blog.conf`文件并编辑内容：\n\n    ```\n    server{\n            listen    80;\n            root /home/www/website;\n            server_name lzxjack.top;\n            location /{\n            }\n    }\n    ```\n\n    ![](https://img.lzxjack.top:99/20201230193405.png)\n\n    其中，`listen`代表监听 80 端口。`root`是博客的根目录，页面存放的地址。`server_name`是服务器名称，填域名`lzxjack.top`，将**域名**和博客的**页面根目录**绑定。\n\n    为了让`http://www.lzxjack.top/`也能访问到博客页面，再新建一个配置文件`wwwblog.conf`，将`server_name`设置为`www.lzxjack.top`：\n\n    ![](https://img.lzxjack.top:99/20201230193623.png)\n\n    这样，`/etc/nginx/vhost`目录下就有两个配置文件，`blog.conf`和`wwwblog.conf`：\n\n    ![](https://img.lzxjack.top:99/20201230193829.png)\n\n    打开`/etc/nginx/`目录下的`nginx.conf`文件，添加下面一行代码，将刚才新建的配置文件引入进来。`*.conf`的意思是将`vhost`文件夹下的所有`.conf`后缀的文件都引入了进来。**注意：要写在`http{}`的里面。**\n\n    ```\n    include /etc/nginx/vhost/*.conf;\n    ```\n\n    ![](https://img.lzxjack.top:99/20201211120654.png)\n\n    至此，完成了 nginx 路由的配置，将域名和云服务器指定路径进行了绑定。\n\n### 4. 安装nodeJS\n\n```\ncurl -sL https://rpm.nodesource.com/setup_10.x | bash -\nyum install -y nodejs\n```\n\n![](https://img.lzxjack.top:99/20201210220802.png)\n\n![](https://img.lzxjack.top:99/20201210220951.png)\n\n![](https://img.lzxjack.top:99/20201210221033.png)\n\n![](https://img.lzxjack.top:99/20201210224206.png)\n\n安装完成后执行 node -v 和 npm -v 如果打印版本号则安装成功\n\n![](https://img.lzxjack.top:99/20201210224901.png)\n\n## 4. 配置服务端Git\n\n这一部分主要目的是本地电脑可以通过`ssh`方式连接到云服务器，然后就可以通过命令行方式将博客传到服务器上。\n\n### 1. 安装Git\n\n```\nyum install git\n```\n\n![](https://img.lzxjack.top:99/20201210225136.png)\n\n![](https://img.lzxjack.top:99/20201210225200.png)\n\n### 2. 配置Git用户\n\n输入以下添加 Git 用户：\n\n```\nadduser git\n```\n\n![](https://img.lzxjack.top:99/20201228213709.png)\n\n修改用户权限：\n\n```\nchmod 740 /etc/sudoers\n```\n\n打开/etc/sudoers：\n\n```\nvi /etc/sudoers\n```\n\n在这个位置添加语句：\n\n```\ngit ALL=(ALL) ALL\n```\n\n![](https://img.lzxjack.top:99/20201210225456.png)\n\n保存退出后，将`sudoers`文件权限改回原样：\n\n```\nchmod 400 /etc/sudoers\n```\n\n设置 Git 用户的密码：\n\n```\nsudo passwd git\n```\n\n![](https://img.lzxjack.top:99/20201210225652.png)\n\n切换到 git 用户，然后在`~`目录下创建`.ssh`文件夹\n\n```\nsu git\ncd ~\nmkdir .ssh\ncd .ssh\n```\n\n![](https://img.lzxjack.top:99/20201210225755.png)\n\n### 3. 配置Git密钥\n\n生成公钥密钥文件：\n\n```\nssh-keygen\n```\n\n**输入后都按回车即可！！！**\n\n此时在目录下就会有两个文件，分别是`id_rsa`和`id_rsa.pub`，其中`id_rsa.pub`就是公钥文件，复制一份：\n\n```\ncp id_rsa.pub authorized_keys\n```\n\n![](https://img.lzxjack.top:99/20201211113959.png)\n\n这样目录下就会有一个`authorized_keys`文件，修改它的权限：\n\n```\nchmod 600 ~/.ssh/authorized_keys\nchmod 700 ~/.ssh\n```\n\n![](https://img.lzxjack.top:99/20201211114203.png)\n\n客户端生成密钥：\n\n在**本地电脑**的`CMD`命令行工具中输入`ssh-keygen -t rsa`，都按回车即可！会在本地电脑的用户文件夹下生成密钥：\n\n![](https://img.lzxjack.top:99/20210301194118.png)\n\n接着，将本地电脑的`id_rsa.pub`文件的内容拷贝到云服务器的`authorized_keys`文件的**末尾**！！！！可采用的方法有：\n\n-   直接复制内容\n-   通过`Xftp`文件传输工具，先将本地电脑的`id_rsa.pub`文件传输到云服务器某位置，再在云服务器上**该位置**执行`cat id_rsa.pub >> ~/.ssh/authorized_keys`即可\n\n然后我们在本地电脑上，打开 cmd，使用`ssh`方式连接云服务器，输入：\n\n```\nssh -v git@云服务器的公网IP\n```\n\n![](https://img.lzxjack.top:99/20210301213333.png)\n\n![](https://img.lzxjack.top:99/20210301194637.png)\n\n最后提示`Welcome to Alibaba Cloud Elastic Compute Service !`，说明**不用输入密码**也登录成功了，即配置 Git 密钥成功，以后更新博客部署的时候不用输入 Git 密码了！\n\n### 4. 创建Git仓库\n\n创建一个 Git 的仓库，并且新建一个`post-receive`文件\n\n```\ncd ~\ngit init --bare blog.git\nvi ~/blog.git/hooks/post-receive\n```\n\n![](https://img.lzxjack.top:99/20201211114620.png)\n\n输入以下内容：\n\n```\ngit --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f\n```\n\n![](https://img.lzxjack.top:99/20201211114552.png)\n\n保存退出并授予该文件可执行权限\n\n```\nchmod +x ~/blog.git/hooks/post-receive\n```\n\n![](https://img.lzxjack.top:99/20201211114656.png)\n\n到此服务端配置完成。\n\n## 5. 配置Hexo并部署发布\n\n本地电脑和服务端配置都完成后，**在本地电脑的 Hexo 根目录下**，输入以下安装插件：\n\n```\nnpm install hexo-deployer-git --save\nnpm install hexo-server\n```\n\n打开`_config.yml`文件，修改`deploy`项目如下：\n\n```\ndeploy:\n  type: git\n  repo: git@云服务器公网IP:/home/git/blog.git\n  branch: master\n```\n\n其中，`type`项表示部署类型为`git`，仓库`repo`地址为`git@云服务器公网IP:/home/git/blog.git`，分支`branch`为`master`主分支。\n\n对博客进行的美化、功能添加、文章拟写等完毕后，命令行输入`hexo clean`清除本地缓存，输入`hexo g -d`生成静态文件，并部署到远程仓库。\n\n此时本地的博客页面已经部署到了服务器的`/home/www/website`目录下：\n\n![](https://img.lzxjack.top:99/20201228214311.png)\n\n部署完成后，若打开页面没变化，可以在云服务器输入以下重启`nginx`即可：\n\n```\nnginx -s reload\n```\n\n到此，通过 hexo 搭建博客并部署到阿里云服务器总算完成啦！\n\n\n",
      "date": 1614605952000,
      "post": true,
      "tags": ["实用技巧"],
      "title": "建站过程：搭建Hexo博客并部署阿里云服务器",
      "titleEng": "hexo-blog",
      "url": "https://lzxjack.top/post?title=hexo-blog"
    },
    {
      "_id": "0122a587642313e80680c9bb1e20162d",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "前端基础",
      "content": "# 1. webpack概述\n\n`webpack`是一个流行的**前端项目构建工具**（打包工具），可以解决当前`web`开发中所面临的困境。`webpack`提供了**友好的模块化支持**，以及**代码压缩混淆**、**处理`js`兼容问题**、**性能优化**等强大的功能，从而让程序员把工作的重心放到具体的功能实现上，提高了**开发效率**和项目的**可维护性**。\n\n![](https://img.lzxjack.top:99/20201210200331.png)\n\n# 2. webpack基本使用\n\n## 1. 创建列表隔行变色案例\n\n1. 新建项目空白目录，并运行`npm init –y`命令，初始化包管理配置文件`package.json`\n2. 新建`src`源代码目录\n3. 新建`src -> index.html`首页\n4. 初始化首页基本的结构\n5. 运行`npm install jquery –S`命令，安装`jQuery`\n6. 通过模块化的形式，实现列表隔行变色效果\n\n## 2. 在项目中安装和配置webpack\n\n1. 运行`npm install webpack webpack-cli –D`命令，安装`webpack`相关的包\n2. 在项目根目录中，创建名为`webpack.config.js`的`webpack`配置文件\n3. 在`webpack`的配置文件中，初始化如下基本配置：\n\n```javascript\nmodule.exports = {\n    mode: 'development', // mode 用来指定构建模式\n};\n```\n\n4. 在`package.json`配置文件中的`scripts`节点下，新增`dev`脚本如下：\n\n```json\n\"scripts\": {\n    \"dev\": \"webpack\" // script 节点下的脚本，可以通过 npm run 执行\n}\n```\n\n5. 在终端中运行`npm run dev`命令，启动`webpack`进行项目打包\n\n## 3. 配置打包的入口与出口\n\n`webpack`的 4.x 版本中默认约定：\n\n-   打包的**入口文件**为 `src -> index.js`\n-   打包的**输出文件**为 `dist -> main.js`\n\n如果要修改打包的入口与出口，可以在`webpack.config.js`中新增如下配置信息：\n\n```javascript\nconst path = require('path'); // 导入 node.js 中专门操作路径的模块\nmodule.exports = {\n    entry: path.join(__dirname, './src/index.js'), // 打包入口文件的路径\n    output: {\n        path: path.join(__dirname, './dist'), // 输出文件的存放路径\n        filename: 'bundle.js', // 输出文件的名称\n    },\n};\n```\n\n## 4. 配置webpack的自动打包功能\n\n1. 运行`npm install webpack-dev-server –D`命令，安装支持项目自动打包的工具\n2. 修改`package.json -> scripts`中的`dev`命令如下：\n\n```json\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\" // script 节点下的脚本，可以通过 npm run 执行\n}\n```\n\n3. 将`src -> index.html`中，`script`脚本的引用路径，修改为`\"/buldle.js“ `\n4. 运行`npm run dev`命令，重新进行打包\n5. 在浏览器中访问`http://localhost:8080`地址，查看自动打包效果\n\n**注意**：\n\n-   `webpack-dev-server`会启动一个实时打包的`http`服务器\n-   `webpack-dev-server`打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的\n\n## 5. 配置html-webpack-plugin生成预览页面\n\n1. 运行`npm install html-webpack-plugin –D`命令，安装生成预览页面的插件\n2. 修改`webpack.config.js`文件头部区域，添加如下配置信息：\n\n```javascript\n// 导入生成预览页面的插件，得到一个构造函数\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst htmlPlugin = new HtmlWebpackPlugin({\n    // 创建插件的实例对象\n    template: './src/index.html', // 指定要用到的模板文件\n    filename: 'index.html', // 指定生成的文件的名称，该文件存在于内存中，在目录中不显示\n});\n```\n\n3. 修改`webpack.config.js`文件中向外暴露的配置对象，新增如下配置节点：\n\n```javascript\nmodule.exports = {\n    plugins: [htmlPlugin], // plugins 数组是 webpack 打包期间会用到的一些插件列表\n};\n```\n\n## 6. 配置自动打包相关的参数\n\n```json\n // package.json中的配置\n // --open 打包完成后自动打开浏览器页面\n // --host 配置 IP 地址\n // --port 配置端口\n \"scripts\": {\n     \"dev\": \"webpack-dev-server --open --host 127.0.0.1 --port 8888\"\n },\n```\n\n# 3. webpack中的加载器\n\n## 1. 通过loader打包非JS模块\n\n在实际开发过程中，`webpack`默认只能打包处理以`.js`后缀名结尾的模块，其他非`.js`后缀名结 尾的模块，`webpack`默认处理不了，需要调用`loader`加载器才可以正常打包，否则会报错！\n\n`loader`加载器可以协助`webpack`打包处理特定的文件模块，比如：\n\n-   `less-loader`可以打包处理`.less`相关的文件\n-   `sass-loader`可以打包处理`.scss`相关的文件\n-   `url-loader`可以打包处理`css`中与`url`路径相关的文件\n\n## 2. loader的调用过程\n\n![](https://img.lzxjack.top:99/20201210202453.png)\n\n## 3. webpack中加载器的基本使用\n\n### 1. 打包处理css文件\n\n1. 运行`npm i style-loader css-loader -D`命令，安装处理`css 文件的 loader`\n2. 在`webpack.config.js`的`module -> rules`数组中，添加`loader`规则如下：\n\n```json\n// 所有第三方文件模块的匹配规则\nmodule: {\n    rules: [\n        { test: /\\.css$/, use: ['style-loader', 'css-loader'] }\n    ]\n}\n```\n\n其中，`test`表示匹配的文件类型，`use`表示对应要调用的`loader`，**从后往前**执行\n\n**注意**：\n\n-   `use`数组中指定的`loader`顺序是固定的\n-   多个`loader`的调用顺序是：**从后往前**调用\n\n### 2. 打包处理less文件\n\n1. 运行`npm i less-loader less -D`命令\n2. 在`webpack.config.js`的`module -> rules`数组中，添加`loader`规则如下：\n\n```json\n // 所有第三方文件模块的匹配规则\n module: {\n     rules: [\n         { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] }\n     ]\n }\n```\n\n### 3. 打包处理scss文件\n\n1. 运行`npm i sass-loader node-sass -D`命令\n2. 在`webpack.config.js`的`module -> rules`数组中，添加`loader`规则如下：\n\n```json\n // 所有第三方文件模块的匹配规则\n module: {\n     rules: [\n         { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }\n     ]\n }\n```\n\n### 4. 配置postCSS自动添加css的兼容前缀\n\n1. 运行`npm i postcss-loader autoprefixer -D`命令\n2. 在项目根目录中创建`postcss`的配置文件`postcss.config.js`，并初始化如下配置：\n\n```javascript\nconst autoprefixer = require('autoprefixer'); // 导入自动添加前缀的插件\nmodule.exports = {\n    plugins: [autoprefixer], // 挂载插件\n};\n```\n\n3. 在`webpack.config.js`的`module -> rules`数组中，修改`css`的`loader`规则如下：\n\n```javascript\nmodule: {\n    rules: [{ test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] }];\n}\n```\n\n### 5. 打包样式表中的图片和字体文件\n\n1. 运行`npm i url-loader file-loader -D`命令\n2. 在`webpack.config.js`的`module -> rules`数组中，添加`loader`规则如下：\n\n```json\nmodule: {\n    rules: [{\n        test: /\\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/,\n        use: 'url-loader?limit=16940'\n    }]\n}\n```\n\n**注意**：\n\n-   其中`?`之后的是`loader`的参数项\n-   `limit`用来指定图片的大小，单位是字节(`byte`),只有小于`limit`大小的图片，才会被转为`base64`图片\n\n### 6. 打包处理JS文件中的高级语法\n\n1. 安装`babel`转换器相关的包：`npm i babel-loader @babel/core @babel/runtime -D`\n2. 安装`babel`语法插件相关的包：`npm i @babel/preset-env @babel/plugin-transformruntime @babel/plugin-proposal-class-properties –D`\n3. 在项目根目录中，创建`babel`配置文件`babel.config.js`并初始化基本配置如下：\n\n```javascript\nmodule.exports = {\n    presets: ['@babel/preset-env'],\n    plugins: ['@babel/plugin-transform-runtime', '@babel/plugin-proposalclass-properties'],\n};\n```\n\n4. 在`webpack.config.js`的`module -> rules`数组中，添加`loader`规则如下：\n\n```javascript\n// exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件\n{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }\n```\n\n\n",
      "date": 1609641200000,
      "post": true,
      "tags": ["Webpack"],
      "title": "初学 Webpack 相关配置",
      "titleEng": "webpack",
      "url": "https://lzxjack.top/post?title=webpack"
    },
    {
      "_id": "cd045e75612639a907b9b7e05c8ac22f",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. ES6模块化（大一统的模块化规范）\n\n在`ES6`模块化规范诞生之前，`Javascript`社区已经尝试并提出了`AMD`、`CMD`、`CommonJS`等模块化规范。\n\n但是，这些社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准，例如：\n\n-   `AMD`和`CMD`适用于浏览器端的`Javascript`模块化\n\n-   `CommonJS`适用于服务器端的`Javascript`模块化\n\n因此，`ES6`语法规范中，在语言层面上定义了`ES6`模块化规范，是**浏览器端**与**服务器端**通用的模块化开发规范。\n\n`ES6`模块化规范中定义：\n\n-   每个`js`文件都是一个**独立的模块**\n-   **导入模块成员**使用`import`关键字\n-   **暴露模块成员**使用`export`关键字\n\n## 2. ES6模块化的基本语法\n\n### 1. 默认导出、默认导入\n\n-   默认导出语法：`export default 默认导出的成员`\n-   默认导入语法：`import 接收名称 from 模块标识符`\n\n```javascript\n// 当前文件模块为 m1.js\n\n// 定义私有成员 a 和 c\nlet a = 10;\nlet c = 20;\n// 外界访问不到变量 d ,因为它没有被暴露出去\nlet d = 30;\n\nfunction show() {}\n// 将本模块中的私有成员暴露出去，供其它模块使用\nexport default {\n    a,\n    c,\n    show,\n};\n```\n\n```javascript\n// 导入模块成员\nimport m1 from './m1.js';\n\nconsole.log(m1);\n// 打印输出的结果为：\n// { a: 10, c: 20, show: [Function: show] }\n```\n\n**注意**：每个模块中，只允许使用唯一的一次`export default`，否则会报错！\n\n### 2. 按需导出、按需导入\n\n-   **按需导出**语法： `export let s1 = 10`\n\n-   **按需导入**语法： `import { s1 } from '模块标识符' `\n\n```javascript\n// 当前文件模块为 m1.js\n\n// 向外按需导出变量 s1\nexport let s1 = 'aaa';\n// 向外按需导出变量 s2\nexport let s2 = 'ccc';\n// 向外按需导出方法 say\nexport function say = function() {};\n```\n\n```javascript\n// 导入模块成员\nimport { s1, s2 as ss2, say } from './m1.js';\n\nconsole.log(s1); // 打印输出 aaa\nconsole.log(ss2); // 打印输出 ccc\nconsole.log(say); // 打印输出 [Function: say]\n```\n\n**注意**：每个模块中，可以使用**多次**按需导出\n\n### 3. 直接导入并执行模块代码\n\n有时候，我们只想**单纯执行某个模块中的代码**，并不需要得到模块中向外暴露的成员，此时，可以**直接导入并执行模块代码**\n\n```javascript\n// 当前文件模块为 m2.js\n\n// 在当前模块中执行一个 for 循环操作\nfor (let i = 0; i < 3; i++) {\n    console.log(i);\n}\n```\n\n```javascript\n// 直接导入并执行模块代码\nimport './m2.js';\n```\n\n\n",
      "date": 1609588339000,
      "post": true,
      "tags": ["模块化"],
      "title": "前端模块化相关规范",
      "titleEng": "module",
      "url": "https://lzxjack.top/post?title=module"
    },
    {
      "_id": "14139e12612e21ae0852140576ffa14b",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "当执行 `JS` 代码时，会生成**执行环境**。\n\n如果代码写在函数中，会产生**函数执行环境**，否则就是在**全局执行环境**中。只有这两种执行环境。\n\n看下面一段代码：\n\n```javascript\nb(); // call b\nconsole.log(a); // undefined\n\nvar a = 'Hello world';\n\nfunction b() {\n    console.log('call b');\n}\n```\n\n这是因为函数和变量提升的原因，通常提升的解释是说将声明的代码移动到了顶部。\n\n但更准确的解释是，在生成**执行环境**时，会有两个阶段：\n\n第一个阶段是**创建**的阶段，`JS` 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间。若是函数，则将整个函数存入内存中。变量**只声明**并且赋值为 `undefined`。\n\n在第二个阶段，也就是**代码执行**阶段，我们可以直接提前使用。\n\n在提升的过程中，相同的函数会**覆盖上一个函数**，并且**函数优先于变量**提升：\n\n```javascript\nb(); // call b second\n\nfunction b() {\n    console.log('call b fist');\n}\n\nfunction b() {\n    console.log('call b second');\n}\nvar b = 'Hello world';\n```\n\n因为`var` 会产生很多错误，所以在`ES6`中引入了 `let`。`let`不能在声明前使用，但是这**并不是**常说的 `let` 不会提升。\n\n`let`**提升了**，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了**并不能在声明前使用**。\n\n\n",
      "date": 1609231105000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 中的变量提升",
      "titleEng": "variable-up",
      "url": "https://lzxjack.top/post?title=variable-up"
    },
    {
      "_id": "14139e12612e1327084f0a7101c89111",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 手撕代码",
      "content": "## 1. 实现效果\n\n实现一个`sleep()`延迟函数，例如，`sleep(2000)`表示等待`2000`毫秒，再执行函数里面的操作。\n\n## 2. 实现过程\n\n利用`Promise`：\n\n```javascript\nconst sleep = time => {\n    return new Promise(resolve => setTimeout(resolve, time));\n};\n```\n\n## 3. 验证\n\n```javascript\nconsole.log(1);\n\nsleep(2000).then(() => {\n    console.log(2);\n});\n\nconsole.log(3);\n```\n\n![](https://img.lzxjack.top:99/20201220182046.gif)\n\n\n",
      "date": 1608459760000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 实现一个sleep()延迟函数",
      "titleEng": "sleep",
      "url": "https://lzxjack.top/post?title=sleep"
    }
  ],
  "requestId": "d880c4377e116"
}
