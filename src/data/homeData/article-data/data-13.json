{
  "data": [
    {
      "_id": "cd045e756128f91a0846e36e3643be53",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 路由的基本使用\n\n1. 明确好界面中的导航区、展示区\n\n2. 导航区的`a`标签改为`Link`标签\n\n    `<Link to=\"/xxxxx\">Demo</Link>`\n\n    ```javascript\n    <Link to=\"/home\">Home</Link>\n    <Link to=\"/about\">About</Link>\n    ```\n\n3. 展示区写`Route`标签进行路径的匹配\n\n    `<Route path='/xxxx' component={Demo}/>`\n\n    ```javascript\n    <Route path=\"/home\" component={Home} />\n    <Route path=\"/about\" component={About} />\n    ```\n\n4. `<App>`的最外侧包裹一个`<BrowserRouter>`或`<HashRouter>`\n\n    ```javascript\n    ReactDOM.render(\n        <BrowserRouter>\n            <App />\n        </BrowserRouter>,\n        document.getElementById('root')\n    );\n    ```\n\n## 2. 路由组件与一般组件区别\n\n1. 写法不同\n\n    - 一般组件：`<Demo/>`\n    - 路由组件：`<Route path=\"/demo\" component={Demo}/>`\n\n2. 存放位置不同\n\n    - 一般组件：`components/`\n    - 路由组件：`pages/`\n\n3. 接收到的`props`不同\n\n    - 一般组件：写组件标签时传递了什么，就能收到什么\n\n    - 路由组件：接收到三个固定的属性\n\n        ```js\n        history:\n        \tgo: ƒ go(n)\n        \tgoBack: ƒ goBack()\n        \tgoForward: ƒ goForward()\n        \tpush: ƒ push(path, state)\n        \treplace: ƒ replace(path, state)\n        location:\n        \tpathname: \"/about\"\n        \tsearch: \"\"\n        \tstate: undefined\n        match:\n        \tparams: {}\n        \tpath: \"/about\"\n        \turl: \"/about\"\n        ```\n\n## 3. NavLink的使用\n\n`NavLink`可以实现路由链接的高亮，通过`activeClassName`指定样式名。\n\n```javascript\n<NavLink activeClassName=\"demo\" to=\"/home\">Home</NavLink>\n<NavLink activeClassName=\"demo\" to=\"/about\">About</NavLink>\n```\n\n## 4. 二次封装NavLink\n\n```javascript\nexport default class MyNavLink extends Component {\n    render() {\n        return <NavLink activeClassName=\"active\" {...this.props} />;\n    }\n}\n```\n\n```javascript\n<MyNavLink to=\"/about\">About</MyNavLink>\n<MyNavLink to=\"/home\">Home</MyNavLink>\n```\n\n## 5. Switch的使用\n\n1. 通常情况下，`path`和`component`是一一对应的关系\n2. `Switch`可以提高路由匹配效率（单一匹配），匹配成功后，就不继续往下遍历\n3. 使用`<Switch></Switch>`标签将`<Route />`包裹起来\n\n```javascript\n<MyNavLink to=\"/about\">About</MyNavLink>\n<MyNavLink to=\"/home\">Home</MyNavLink>\n\n<Switch>\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/home\" component={Home} />\n</Switch>\n```\n\n## 6. 解决样式丢失问题\n\n1. `public/index.html`中引入样式时不写`./`，写`/`（常用）\n2. `public/index.html`中 引入样式时不写`./`，写`%PUBLIC_URL%`（常用）\n3. 使用`HashRouter`\n\n## 7. 严格匹配与模糊匹配\n\n1. 默认使用的是`模糊匹配`（`输入的路径`必须包含要`匹配的路径`，且**顺序要一致**）\n2. 开启严格匹配：`<Route exact={true} path=\"/about\" component={About}/>`\n3. 严格匹配不要随便开启，需要再开。有些时候开启会导致无法继续匹配二级路由\n\n## 8. Redirect的使用\n\n一般写在所有**路由注册**的最下方，当所有路由都无法匹配时，跳转到`Redirect`指定的路由。\n\n```javascript\n<Switch>\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/home\" component={Home} />\n    <Redirect to=\"/home\" />\n</Switch>\n```\n\n## 9. 嵌套路由\n\n1. 在需要开启路由的组件的文件夹中，再创建组件\n\n2. 在组件中开启子路由，注册子路由时要写上父路由的`path`值\n3. 路由的匹配是按照注册路由的顺序进行的\n\n![](https://img.lzxjack.top:99/20210418094231.png)\n\n```javascript\nexport default class Home extends Component {\n    render() {\n        return (\n            <div>\n                <h2>Home</h2>\n                <div>\n                    <MyNavLink to=\"/home/news\">News</MyNavLink>\n                    <MyNavLink to=\"/home/message\">Message</MyNavLink>\n                </div>\n                <div>\n                    <Switch>\n                        <Route path=\"/home/news\" component={News} />\n                        <Route path=\"/home/message\" component={Message} />\n                        <Redirect to=\"/home/news\" />\n                    </Switch>\n                </div>\n            </div>\n        );\n    }\n}\n```\n\n## 10. 传递参数\n\n详情请点击<a href=\"https://lzxjack.top/post?title=react-router-props\" target=\"_blank\">`React-Router 传递参数`</a>。\n\n## 11. push和replace的区别\n\n- `push`模式\n\n路由可以理解为`栈`的数据结构，`push`模式下，将每一次的地址推入`栈`中，会形成`history`，可返回到上一层。\n\n- `replace`模式\n\n`replace`模式下，将`栈顶`的地址替换为当前的地址，不会形成`history`，不可返回到上一层，因为上一层被替换了。\n\n`React-Router`中默认是`push`模式，可在`路由链接`处开启`replace`模式：\n\n```javascript\n<Link replace={true} to=\"/home/message/detail/id/title\">title</Link>\n```\n\n## 12. 编程式路由导航\n\n借助`this.prosp.history`对象上的`API`对操作路由跳转、前进、后退。\n\n```javascript\npushShow = (id, title) => {\n    // push+params\n    this.props.history.push(`/home/message/detail/${id}/${title}`);\n\n    // push+search\n    this.props.history.push(`/home/message/detail/?id=${id}&title=${title}`);\n\n    // push+state\n    this.props.history.push(`/home/message/detail/`, { id, title });\n};\nreplaceShow = (id, title) => {\n    // replace+params\n    this.props.history.replace(`/home/message/detail/${id}/${title}`);\n\n    // replace+search\n    this.props.history.replace(`/home/message/detail/?id=${id}&title=${title}`);\n\n    // replace+state\n    this.props.history.replace(`/home/message/detail/`, { id, title });\n};\n...\n\n<button onClick={() => {this.pushShow(msgObj.id, msgObj.title)}}>push模式</button>\n<button onClick={() => {this.replaceShow(msgObj.id, msgObj.title);}}>replace模式</button>\n```\n\n## 13. withRouter的使用\n\n- `withRouter`可以加工`一般组件`，让`一般组件`具备`路由组件`的`API`\n- `withRouter`返回值是一个新组件\n\n```javascript\nimport { withRouter } from 'react-router-dom';\n...\n\nclass Header extends Component {\n...\n}\n\nexport default withRouter(Header);\n```\n\n## 14. BrowserRouter与HashRouter的区别\n\n|                               |                `BrowserRouter`                 |               `HashRouter`                |\n| :---------------------------: | :--------------------------------------------: | :---------------------------------------: |\n|           底层原理            | 使用`H5`的`history API`，不兼容`IE9`及以下版本 |       使用`URL`的哈希值，兼容性更好       |\n|          `path`形式           |   路径中没有`#`，`localhost:3000/demo/test`    | 路径包含`#`，`localhost:3000/#/demo/test` |\n| 刷新后对路由`state`参数的影响 | 没有任何影响，因为`state`保存在`history`对象中 |    刷新后会导致路由`state`参数的丢失！    |\n\n备注：`HashRouter`可以用于解决一些`路径错误`相关的问题。",
      "date": 1618367856000,
      "post": true,
      "tags": ["React"],
      "title": "React 路由的基本使用",
      "titleEng": "react-router"
    },
    {
      "_id": "14139e126124c36406b292bf261aa91a",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "## 1. 浅拷贝\n\n**浅拷贝**只拷贝了最外**简单数据类型的一层**，**更深层次对象级别**的只拷贝了地址。**地址指向同一个内存空间**。若改变拷贝后对象深层对象的值，由于地址一直未改变，拷贝前对象深层对象的值也会随之改变。\n下面是一个浅拷贝的例子：\n\n```javascript\nvar oldObj = {\n    id: 1,\n    name: 'Jack',\n    msg: {\n        age: 18,\n    },\n};\nvar newObj = {};\n// 遍历旧对象，依次拷贝\nfor (var k in oldObj) {\n    newObj[k] = oldObj[k];\n}\n```\n\n将拷贝后的对象输出：\n\n```javascript\nconsole.log(newObj);\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020102721040463.png#pic_center)\n可以看到，已经拷贝完成。\n但是改变一下**新对象**中深层对象的值，再输出旧对象，发现**旧对象**深层对象的值也随之**改变了**：\n\n```javascript\nnewObj.msg.age = 20;\nconsole.log(oldObj);\n```\n\n![](https://img.lzxjack.top:99/20210412103754.png)\n\n---\n\n另外，ES6 语法中提供了**浅拷贝的方法** `Object.assign(target, sources)`，其中：\n`target`：拷贝后的对象\n`sources`：拷贝前的对象\n例如，在本例中：\n\n```javascript\nObject.assign(newObj, oldObj);\nconsole.log(newObj);\n```\n\n![](https://img.lzxjack.top:99/20210412103808.png)\n\n同样，也可以完成**浅拷贝**。\n\n## 2. 深拷贝\n\n**深拷贝**拷贝多层, 每一级别的数据都会拷贝，**更深层次对象级别**的会开辟**新的内存空间进行拷贝**。新旧对象深层次对象级别的数据**地址不同**，所以两者独立，改变新对象的值，**旧对象不受影响**。\n下面是个例子：\n\n```javascript\nvar oldObj = {\n    id: 1,\n    name: 'Jack',\n    msg: {\n        age: 18,\n    },\n    color: ['pink', 'red'],\n};\nvar newObj = {};\n// 封装函数\nfunction deepCopy(newobj, oldobj) {\n    for (var k in oldobj) {\n        // 判断我们的属性值属于那种数据类型\n        // 1. 获取属性值  oldobj[k]\n        var item = oldobj[k];\n        // 2. 判断这个值是否是数组\n        if (item instanceof Array) {\n            newobj[k] = [];\n            // newobj[k]是属性，item是值\n            deepCopy(newobj[k], item);\n        } else if (item instanceof Object) {\n            // 3. 判断这个值是否是对象\n            newobj[k] = {};\n            deepCopy(newobj[k], item);\n        } else {\n            // 4. 属于简单数据类型\n            newobj[k] = item;\n        }\n    }\n}\ndeepCopy(newObj, oldObj);\nconsole.log(newObj);\n```\n\n得到新的对象：\n\n![](https://img.lzxjack.top:99/20210412103836.png)\n\n若改变**新对象**中`age`的值，**旧对象**中`age`的值**不会改变**，不会受到影响：\n\n```javascript\nnewObj.msg.age = 20;\nconsole.log(newObj);\nconsole.log(oldObj);\n```\n\n![](https://img.lzxjack.top:99/20210412103856.png)\n\n## 3. 小结\n\n1. **浅拷贝**只是拷贝一层，更深层次对象级别的只拷贝地址。\n2. **深拷贝**拷贝多层，每一级别的数据都会拷贝。\n\n以上为个人学习所得理解，若有不妥之处，欢迎评论指正。\n\n\n",
      "date": 1618221432000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 深拷贝和浅拷贝",
      "titleEng": "copy"
    },
    {
      "_id": "cd045e75611f429f06c57bcc17c48574",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. 同步API\n\n同步 API 从上到下依次执行，前面代码**会阻塞**后面代码的执行\n\n```javascript\nfor (var i = 0; i < 1000; i++) {\n    console.log(i);\n}\n\nconsole.log('for循环后面的内容...');\n```\n\n**执行结果：**\n先将 for 循环执行完毕后，再执行 for 循环后面的代码\n\n![](https://img.lzxjack.top:99/20210820135257.png)\n\n## 2. 异步API\n\n异步 API **不会等待**API 执行完成后再向下执行代码\n\n```javascript\nconsole.log('开始执行');\n\nsetTimeout(() => {\n    console.log('2秒后执行的内容');\n}, 2000);\n\nsetTimeout(() => {\n    console.log('0秒后执行的内容');\n}, 0);\n\nconsole.log('结束执行');\n```\n\n**执行结果**：\n\n![](https://img.lzxjack.top:99/20210820135415.png)\n\n**执行分析：**\n\n![](https://img.lzxjack.top:99/20210412120510.gif)\n\n先将所有的同步代码依次执行，期间将异步代码放入**异步代码执行区**和**回调函数队列**。同步代码执行完毕后，在**回调函数队列**中根据定时器的时间来依次执行相应的代码，延时少的先执行，延时多的后执行。\n\n\n",
      "date": 1618218491000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 异步代码执行顺序分析",
      "titleEng": "async"
    },
    {
      "_id": "cd045e75611f69fc06cccfd349a889cf",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部`this`的指向问题，常用的有 `bind()`、`call()`、`apply()`三种方法。\n\n## 1. call\n\n### 1. call用法\n\n`call()`方法调用一个对象。简单理解为**调用函数**的方式，但是它可以改变函数的`this`指向\n\n```javascript\nfun.call(thisArg, arg1, arg2, ...);\n```\n\n-   `thisArg`：在`fun`函数运行时指定的`this`值\n-   `arg1`，`arg2`：传递的其他参数\n-   返回值就是函数的返回值，因为它就是调用函数\n-   因此当我们想改变`this`指向，同时想调用这个函数的时候，可以使用`call()`，比如继承\n\n```js\nvar o = {\n    name: 'andy',\n};\nfunction fn(a, b) {\n    console.log(this);\n    console.log(a + b);\n}\nfn(1, 2); // 此时的this指向的是window 运行结果为3\nfn.call(o, 1, 2); // 此时的this指向的是对象o,参数使用逗号隔开,运行结果为3\n\nfn.call(1, 2); // this->1, a=2, b=undefined\n```\n\n![](https://img.lzxjack.top:99/20210412105920.png)\n\n另外，在`严格模式`下和`非严格模式`下，`this`有所区别：\n\n```javascript\n// 非严格模式\nfn.call(); // this -> window\nfn.call(null); // this -> window\nfn.call(undefined); // this -> window\n\n// 严格模式\nfn.call(); // this -> undefined\nfn.call(null); // this -> null\nfn.call(undefined); // this -> undefined\n```\n\n### 2. call用例\n\n**（1）判断数据类型**\n\n使用`Object.prototype.toString`可以判断数据类型。\n\n```javascript\nconst a = [1, 2, 3];\nconst b = {\n    name: 'jack',\n    age: 18,\n};\nconst c = 10;\n\nconst typeA = Object.prototype.toString.call(a); // [object Array]\nconst typeB = Object.prototype.toString.call(b); // [object Object]\nconst typeC = Object.prototype.toString.call(c); // [object Number]\n```\n\n**（2）类数组转数组**\n\n使用`Array.prototype.slice`可以将**类数组**转化为**数组**。\n\n```javascript\nconst arrayLike = {\n    0: 'Jack',\n    1: 'Tim',\n    2: 'Jone',\n    3: 'Randy',\n    length: 4,\n};\n\n// [ 'Jack', 'Tim', 'Jone', 'Randy' ]\nconst arr = Array.prototype.slice.call(arrayLike);\n```\n\n## 2. apply\n\n### 1. apply用法\n\n`apply()`方法调用一个函数。简单理解为**调用函数**的方式，但是它可以改变函数的`this`指向。\n\n`apply()`和`call()`方法的作用是一模一样的，都是用来改变方法的`this`关键字并且把方法执行，而且在`严格模式`下和`非严格模式`下，对于第一个参数是`null`/`undefined`这种情况的规律也是一样的。\n\n```javascript\nfun.apply(thisArg, [argsArray]);\n```\n\n-   `thisArg`：在`fun`函数运行时指定的`this`值\n-   `arg1`，`arg2`：传递的其他参数，写成`数组`形式传递\n-   返回值就是函数的返回值，因为它就是调用函数\n-   `apply()`主要跟**数组**有关系，比如使用`Math.max()`求数组的最大值\n\n```js\nvar o = {\n    name: 'andy',\n};\nfunction fn(a, b) {\n    console.log(this);\n    console.log(a + b);\n}\nfn(); // 此时的this指向的是window 运行结果为3\nfn.apply(o, [1, 2]); //此时的this指向的是对象o,参数使用数组传递 运行结果为3\n```\n\n![](https://img.lzxjack.top:99/20210412105931.png)\n\n### 2. apply用例\n\n借用`Math.max`方法，将数组作为参数传递进去，求**最大值**或**最小值**。\n\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\nconst max = Math.max.apply(null, nums); // 5\nconst min = Math.min.apply(null, nums); // 1\n```\n\n## 3. bind\n\n### 1. bind用法\n\n`bind()`方法**不会调用函数**。但是能改变函数内部`this`指向。\n\n在`严格模式`下和`非严格模式`下，对于第一个参数是`null`/`undefined`这种情况的规律与`call()`相同。\n\n```javascript\nfun.bind(thisArg, arg1, arg2, ...);\n```\n\n-   `thisArg`：在`fun`函数运行时指定的`this`值\n-   `arg1`，`arg2`：传递的其他参数\n-   **返回**由指定的`this`值和初始化参数改造的**原函数拷贝**\n-   因此当我们只是想改变`this`指向，并且**不想调用**这个函数的时候，可以使用`bind()`\n\n```js\nvar o = {\n    name: 'andy',\n};\n\nfunction fn(a, b) {\n    console.log(this);\n    console.log(a + b);\n}\n\n// 这里不会输出任何值，因为bind并不调用函数\nfn.bind(o, 1, 2);\n\n// 此处的f是bind返回的新函数\nvar f = fn.bind(o, 1, 2);\n// 调用新函数  this指向的是对象o，参数使用逗号隔开\nf();\n```\n\n![](https://img.lzxjack.top:99/20210412105945.png)\n\n## 4. 三者的异同\n\n-   共同点：都可以**改变`this`指向**\n-   不同点：\n\n    -   `call()` 和 `apply()` **会调用函数**，并且改变函数内部`this`指向.\n    -   `call()` 和 `apply()`传递的参数不一样，`call()`传递参数使用**逗号隔开**，`apply()`使用**数组传递**\n    -   `bind()` **不会调用函数**，可以改变函数内部`this`指向\n\n-   应用场景\n    1. `call()`经常**做继承**\n    2. `apply()`经常**跟数组有关系**，比如借助于数学对象实现数组最大值最小值\n    3. `bind()`**不调用函数**，但是还想改变`this`指向，比如改变定时器内部的`this`指向\n\n|              |      `call()`      |     `apply()`      |      `bind()`      |\n| :----------: | :----------------: | :----------------: | :----------------: |\n|    相同点    | 改变函数`this`指向 | 改变函数`this`指向 | 改变函数`this`指向 |\n| 是否调用函数 |         是         |         是         |        `否`        |\n|   传递参数   |    逗号`,`隔开     |    数组形式`[]`    |    逗号`,`隔开     |\n|   应用场景   |        继承        |     与数组有关     |    不想调用函数    |\n\n",
      "date": 1618216605000,
      "post": true,
      "tags": ["JavaScript", "this"],
      "title": "JavaScript call()、apply()、bind()的区别",
      "titleEng": "call-apply-bind"
    },
    {
      "_id": "14139e12612e129e084eeb503930b4bf",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. 当模块拥有路径但没有后缀时\n\n```javascript\nrequire('./find');\n```\n\n1.  `require`方法根据模块路径查找**模块**，如果是完整路径，直接引入模块\n2.  如果模块后缀省略，先找同名`JS`**文件**再找同名**文件夹**，没有同名文件夹则报错\n3.  如果找到了同名文件夹，找文件夹中的`index.js`\n4.  如果文件夹中没有`index.js`，就会去当前文件夹中的`package.json`文件中查找`main`选项中的入口文件\n5.  如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到\n\n## 2. 当模块没有路径且没有后缀时\n\n```javascript\nrequire('find');\n```\n\n1.  `Node.js`会假设它是**系统模块**\n2.  `Node.js`会去`node_modules`文件夹中\n3.  首先看是否有该名字的`JS`**文件**\n4.  再看是否有该名字的**文件夹**\n5.  如果是文件夹看里面是否有`index.js`\n6.  如果没有`index.js`查看该文件夹中的`package.json`中的`main`选项确定模块入口文件\n7.  否则，找不到则报错\n\n\n",
      "date": 1618207732000,
      "post": true,
      "tags": ["JavaScript", "Node.js"],
      "title": "Node.js 模块查找机制",
      "titleEng": "search-module"
    },
    {
      "_id": "2d44d6c261264c5206f39a7341170d57",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. 对象的三种创建方式\n\n### 1. 字面量方式\n\n```javascript\nvar obj = {};\n```\n\n### 2. new关键字\n\n```javascript\nvar obj = new Object();\n```\n\n### 3. 构造函数方式\n\n```javascript\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nvar obj = new Person('Jack', 18);\n```\n\n**new 的过程**：\n\n1. 新生成了一个对象\n2. 链接到原型\n3. 绑定`this`\n4. 返回新对象\n\n在调用 `new` 的过程中会发生以上四件事情，可以自己实现一个 `new`：\n\n```javascript\nfunction create() {\n\t// 创建一个空的对象\n\tlet obj = new Object()\n\t// 获得构造函数\n\tlet Con = [].shift.call(arguments)\n\t// 链接到原型\n\tobj.__proto__ = Con.prototype\n\t// 绑定 this，执行构造函数\n\tlet result = Con.apply(obj, arguments)\n\t// 确保 new 出来的是个对象\n\treturn typeof result === 'object' ? result : obj\n}\n```\n\n## 2. 静态成员和实例成员\n\n### 1. 静态成员\n\n静态成员是在构造函数**本身上**添加的成员，如下列代码中`sex`就是静态成员，静态成员只能通过**构造函数**来访问\n\n```javascript\nfunction Obj(uname, age) {\n    this.uname = uname;\n    this.age = age;\n    this.like = function () {\n        console.log('我喜欢运动');\n    };\n}\nObj.sex = '男';\nvar usr = new Obj('Jack', 18);\nconsole.log(Obj.sex); // 静态成员只能通过构造函数来访问\n```\n\n### 2. 实例成员\n\n实例成员就是构造函数内部通过`this`添加的成员，如下列代码中`uname`、`age`、`sing`就是实例成员，实例成员只能通过**实例化的对象**来访问。\n\n```javascript\nfunction Star(uname, age) {\n    this.uname = uname;\n    this.age = age;\n    this.do = function () {\n        console.log('1234');\n    };\n}\nvar ldh = new Star('Jack', 18);\nconsole.log(ldh.uname); //实例成员只能通过实例化的对象来访问\n```\n\n## 3. 构造函数的问题\n\n构造函数方法很好用，但是存在**浪费内存**的问题。\n\n```javascript\nfunction Star(uname, age) {\n    this.uname = uname;\n    this.age = age;\n    this.do = function () {\n        console.log('我会打篮球');\n    };\n}\nvar usr1 = new Star('Jack', 18);\nvar usr2 = new Star('Tom', 19);\n```\n\n![](https://img.lzxjack.top:99/20210412122419.png)\n\n## 4. 构造函数原型-prototype\n\n构造函数通过**原型**分配的函数是**所有对象所共享的**。\n\nJavaScript 规定，每一个构造函数都有一个`prototype`属性，指向**另一个对象**。注意这个`prototype`就是一个**对象**，这个对象的所有**属性**和**方法**，都会被构造函数所拥有。\n\n```javascript\nlet fun = Function.prototype.bind()\n```\n如果以上述方法创建一个函数，那么可以发现这个函数是不具有`prototype`属性的。\n\n我们可以把那些不变的方法，直接定义在`prototype`对象上，这样**所有对象的实例就可以共享这些方法**。\n\n```javascript\nfunction Star(uname, age) {\n    this.uname = uname;\n    this.age = age;\n}\nStar.prototype.do = function () {\n    console.log('我会打篮球');\n};\nvar usr1 = new Star('Jack', 18);\nvar usr2 = new Star('Tom', 19);\nusr1.do(); // 我会打篮球\nusr2.do(); // 我会打篮球\n```\n\n![](https://img.lzxjack.top:99/20210412122430.png)\n\n## 5. 对象原型\n\n**对象**都会有一个**属性**`__proto__`指向构造函数的`prototype`原型对象，之所以对象可以使用构造函数`prototype`原型对象的属性和方法，就是因为对象有`__proto__`原型的存在。\n\n`__proto__`对象原型和原型对象`prototype`是等价的。\n\n`__proto__`对象原型的意义就在于**为对象的查找机制提供一个方向**，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是**内部指向**原型对象`prototype`。\n\n![](https://img.lzxjack.top:99/20210412122440.png)\n\n```javascript\nfunction Star(uname, age) {\n    this.uname = uname;\n    this.age = age;\n}\nStar.prototype.do = function () {\n    console.log('我会打篮球');\n};\nvar usr1 = new Star('Jack', 18);\nusr1.do(); // 我会打篮球\nconsole.log(usr1.__proto__ == Star.prototype); // true\n```\n\n## 6. 构造函数-constructor\n\n**对象原型**（`__proto__`）和构造函数**原型对象**（`prototype`）里面都有一个`constructor`属性 ，称为**构造函数**，因为**它指回构造函数本身**。\n\n`constructor`主要用于**记录该对象引用于哪个构造函数**，它可以**让原型对象重新指向原来的构造函数**。\n\n**注意：**\n一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取**对象形式赋值**，但是这样就会**覆盖**构造函数原型对象原来的内容，这样修改后的原型对象`constructor`就**不再指向当前构造函数**了。此时，我们可以在**修改后的原型对象**中，添加一个`constructor`指向原来的构造函数。\n\n如果我们修改了原来的**原型对象**，给原型对象赋值的是一个对象，则必须**手动**利用`constructor`指回**原来的构造函数**，如：\n\n```javascript\nfunction Star(uname, age) {\n    this.uname = uname;\n    this.age = age;\n}\n// 很多情况下，我们需要手动的利用constructor这个属性指回，原来的构造函数\nStar.prototype = {\n    // 如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动利用constructor指回原来的构造函数\n    constructor: Star, // 手动设置指回原来的构造函数\n    do: function () {\n        console.log('我会打篮球');\n    },\n    movie: function () {\n        console.log('我喜欢看电影');\n    },\n};\nvar usr1 = new Star('Jack', 18);\nconsole.log(usr1);\n```\n\n![](https://img.lzxjack.top:99/20210412122717.png)\n\n如果未设置`constructor`属性，如图：\n\n![](https://img.lzxjack.top:99/20210412122731.png)\n\n## 7. 构造函数、实例、原型对象的三角关系\n\n1. **构造函数**的`prototype`属性指向了构造函数**原型对象**\n2. 实例对象是由构造函数创建的，实例对象的`__proto__`属性指向了构造函数的**原型对象**\n3. 构造函数的原型对象的`constructor`属性指向了**构造函数**，**实例对象**的**原型**的`constructor`属性（`usr1. __proto__.constructor`）也指向了**构造函数**\n\n![](https://img.lzxjack.top:99/20210412122503.png)\n\n## 8. 原型链\n\n每一个**实例对象**有一个`__proto__`属性，指向的**构造函数**的**原型对象**，构造函数的原型对象**也是一个对象**，也有`__proto__`属性，这样一层一层往上找就形成了**原型链**。\n\n![](https://img.lzxjack.top:99/20210412122522.png)\n\n**原型链查找机制：**\n\n1. 当访问一个对象的**属性**（包括**方法**）时，首先查找这个**对象自身**有没有该属性。\n2. 如果没有就**查找它的原型**（也就是`__proto__`指向的`prototype`原型对象）。\n3. 如果还没有就**查找原型对象的原型**（`Object`的原型对象）。\n4. 依此类推一直找到`Object`为止（`null`）。\n5. `__proto__`对象原型的意义就在于**为对象成员查找机制提供一个方向**，或者说一条路线。\n\n**总结**：\n\n-   `Object` 是所有对象的爸爸，所有对象都可以通过 `__proto__` 找到它\n-   `Function` 是所有函数的爸爸，所有函数都可以通过 `__proto__` 找到它\n-   `Function.prototype` 和 `Object.prototype` 是两个特殊的对象，他们由引擎来创建\n-   除了以上两个特殊对象，其他对象都是通过构造器 `new` 出来的\n-   函数的 `prototype` 是一个对象，也就是原型\n-   对象的 `__proto__` 指向原型， `__proto__` 将对象和原型连接起来组成了原型链\n\n**存在意义**：\n\n使得**实例对象**可以共享**构造函数**的原型**属性**和**方法**, 节省内存。构造函数原型上的属性和方法越多，节省内存越大。\n\n## 9. 原型对象中this指向\n\n构造函数中的`this`和原型对象的`this`，都指向`new`出来的**实例对象**。\n\n```javascript\nfunction Stu(uname, age) {\n    this.uname = uname;\n    this.age = age;\n    this.sing = function () {\n        console.log('构造函数内部的this：', this);\n    };\n}\nStu.prototype.dance = function () {\n    console.log('原型对象内部的this：', this);\n};\nvar usr1 = new Stu('Jack', 18);\nusr1.dance();\nusr1.sing();\n```\n\n![](https://img.lzxjack.top:99/20210414200230.png)\n\n## 10. 通过原型为数组扩展内置方法\n\n```javascript\nArray.prototype.sum = function () {\n    var sum = 0;\n    for (var i = 0; i < this.length; i++) {\n        sum += this[i];\n    }\n    return sum;\n};\n//此时数组对象中已经存在sum()方法了，可以使用数组.sum()进行数据求和\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconsole.log(arr.sum()); // 55\n```\n\n\n",
      "date": 1618203370000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 原型与原型链详解",
      "titleEng": "prototype"
    },
    {
      "_id": "14139e126124e57c06b7edba24dcdaf3",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "ES6 语法中，可以对对象进行解构赋值。\n\n例如从对象`obj`上拿到`c`的值，一般地，我们习惯于这样写：\n\n```javascript\nconst obj = { a: { b: { c: 1 } } };\nconst { c } = obj.a.b;\n```\n\n还可以这样写，连续解构：\n\n```javascript\nconst obj = { a: { b: { c: 1 } } };\n\nconst {\n    a: {\n        b: { c },\n    },\n} = obj;\n```\n\n另外，如果想给解构出的`c`重命名，可以直接在后面写：\n\n```javascript\nconst obj = { a: { b: { c: 1 } } };\nconst {\n    a: {\n        b: { c: c1 },\n    },\n} = obj; // 解构出c并重命名为c1\n```\n\n\n",
      "date": 1618190755000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 对象的连续解构赋值",
      "titleEng": "divide-value"
    }
  ],
  "requestId": "01a612482db08"
}
