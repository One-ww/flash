{
  "data": [
    {
      "_id": "8937eaa9611f4d9d05830a9848f644be",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. axios基本使用\n\n-   `get`和`delete`请求传递参数：\n    -   传统形式：`url`以`?`的形式传递参数\n    -   `restful`形式：通过`params`形式传递参数\n-   `post`和`put`请求传递参数：\n    -   通过选项传递参数\n    -   通过`URLSearchParams`传递参数\n\n## 2. 发送get请求\n\n```javascript\naxios.get('http://localhost:3000/adata').then(function (ret) {\n    //拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面\n    // 注意data属性是固定的用法，用于获取后台的实际数据\n    // console.log(ret.data)\n    console.log(ret);\n});\n```\n\n## 3. get请求传递参数\n\n### 1. 传统形式传递参数\n\n```javascript\naxios.get('http://localhost:3000/axios?id=123').then(function (ret) {\n    console.log(ret.data);\n});\n```\n\n### 2. restful形式传递参数\n\n```javascript\naxios.get('http://localhost:3000/axios/123').then(function (ret) {\n    console.log(ret.data);\n});\n```\n\n### 3. 通过params形式传递参数\n\n```javascript\naxios\n    .get('http://localhost:3000/axios', {\n        params: {\n            id: 789,\n        },\n    })\n    .then(function (ret) {\n        console.log(ret.data);\n    });\n```\n\n## 4. delete请求传参\n\n传参的形式和`get`请求一样\n\n```javascript\naxios\n    .delete('http://localhost:3000/axios', {\n        params: {\n            id: 111,\n        },\n    })\n    .then(function (ret) {\n        console.log(ret.data);\n    });\n```\n\n## 5. post请求\n\n### 1. 通过选项传递参数\n\n```javascript\naxios\n    .post('http://localhost:3000/axios', {\n        uname: 'lisi',\n        pwd: 123,\n    })\n    .then(function (ret) {\n        console.log(ret.data);\n    });\n```\n\n### 2. 通过URLSearchParams传递参数\n\n```javascript\nvar params = new URLSearchParams();\nparams.append('uname', 'zhangsan');\nparams.append('pwd', '111');\naxios.post('http://localhost:3000/axios', params).then(function (ret) {\n    console.log(ret.data);\n});\n```\n\n## 6. put请求传参\n\n传参的形式和`get`请求一样\n\n```javascript\naxios\n    .put('http://localhost:3000/axios/123', {\n        uname: 'lisi',\n        pwd: 123,\n    })\n    .then(function (ret) {\n        console.log(ret.data);\n    });\n```\n\n## 7. axios全局配置\n\n```javascript\n// 配置公共的请求头\naxios.defaults.baseURL = 'https://api.example.com';\n// #配置 超时时间\naxios.defaults.timeout = 2500;\n// 配置公共的请求头\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n// 配置公共的 post 的 Content-Type\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n## 8. axios拦截器\n\n### 1. 请求拦截器\n\n请求拦截器的作用是在**请求发送前**进行一些操作。例如在每个请求体里加上`token`，统一做了处理如果以后要改也非常容易\n\n```javascript\naxios.interceptors.request.use(\n    function (config) {\n        console.log(config.url);\n        //  1.1 任何请求都会经过这一步   在发送请求之前做些什么\n        config.headers.mytoken = 'nihao';\n        //  1.2 这里一定要return   否则配置不成功\n        return config;\n    },\n    function (err) {\n        //  1.3 对请求错误做点什么\n        console.log(err);\n    }\n);\n```\n\n### 2. 响应拦截器\n\n响应拦截器的作用是在接**收到响应后**进行一些操作。例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页\n\n```javascript\naxios.interceptors.response.use(\n    function (res) {\n        //  2.1 在接收响应做些什么\n        var data = res.data;\n        return data;\n    },\n    function (err) {\n        //  2.2 对响应错误做点什么\n        console.log(err);\n    }\n);\n```\n\n\n",
      "date": 1617766489000,
      "post": true,
      "tags": ["Axios"],
      "title": "学习记录 —— Axios",
      "titleEng": "axios",
      "url": "https://lzxjack.top/post?title=axios"
    },
    {
      "_id": "14139e126128f6c10767db002a0c44b7",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 虚拟DOM中key的作用\n\n`key`是虚拟 DOM 对象的标识, 在更新显示时`key`起着极其重要的作用。当状态中的数据发生变化时，react 会根据`新数据`生成`新的虚拟DOM`, 随后 React 进行`新虚拟DOM`与`旧虚拟DOM`的`diff`比较，比较规则如下：\n\n-   `旧虚拟DOM`中找到了与`新虚拟DOM`相同的`key`\n    -   若虚拟 DOM 中内容没变, **直接使用**之前的真实 DOM\n    -   若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后**替换**掉页面中之前的真实 DOM\n-   `旧虚拟DOM`中未找到与`新虚拟DOM`相同的`key`\n    -   根据数据创建新的真实 DOM，随后渲染到到页面\n\n## 2. 用index作为key可能的后果\n\n1. 若对数据进行**逆序**添加、**逆序**删除等**破坏顺序**操作\n\n    会产生**没有必要**的真实 DOM 更新 ==> 界面效果没问题, 但**效率低**\n\n2. **破坏顺序**操作中，若结构中还包含**输入类**的 DOM\n\n    会产生错误 DOM 更新 ==> 界面有问题\n\n    原因：结构中**输入类**的 DOM 不会更新，还是原来的数据，但是其他结构被更新了\n\n3. 如果**不存在**对数据的**逆序**添加、**逆序**删除等**破坏顺序操作**，仅用于渲染列表用于展示\n\n    使用`index`作为`key`是没有问题的\n\n## 3. 如何选择key\n\n1. 最好使用每条数据的**唯一标识**作为`key`, 比如`id`、手机号、身份证号、学号等唯一值。\n2. 如果确定只是简单的展示数据，用`index`也是可以的。\n\n\n",
      "date": 1617164896000,
      "post": true,
      "tags": ["React"],
      "title": "React 中key属性到底有什么作用？",
      "titleEng": "react-key",
      "url": "https://lzxjack.top/post?title=react-key"
    },
    {
      "_id": "14139e126128f99e07684f331dad1608",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 使用JS创建虚拟DOM\n\n```javascript\n//1.创建虚拟DOM\nconst VDOM = React.createElement('h1', { id: 'title' }, React.createElement('span', {}, 'Hello,React'));\n//2.渲染虚拟DOM到页面\nReactDOM.render(VDOM, document.getElementById('test'));\n```\n\n创建后的效果：\n\n![](https://img.lzxjack.top:99/20210330132247.png)\n\n## 2. 使用JSX语法创建虚拟DOM\n\n```javascript\n//1.创建虚拟DOM\nconst VDOM = (\n    <h1 id=\"title\">\n        <span>Hello,React</span>\n    </h1>\n);\n//2.渲染虚拟DOM到页面\nReactDOM.render(VDOM, document.getElementById('test'));\n```\n\n创建后的效果：\n\n![](https://img.lzxjack.top:99/20210330132339.png)\n\n**`jsx`语法规则：**\n\n1. 定义虚拟 DOM 时，不要写引号。\n\n2. 标签中混入`JS表达式`时要用`{}`。\n\n3. 样式的类名指定用`className`。\n\n4. 内联样式，用`style={{key:value}}`的形式去写，驼峰命名。\n\n5. 只有一个**根标签**。\n\n6. 标签必须闭合（单标签加`/`自闭和）。\n\n7. 标签首字母\n    - 若**小写**字母开头，则将该标签转为 html 中**同名元素**，若 html 中无该标签对应的同名元素，则报错。\n    - 若**大写**字母开头，react 就去渲染对应的**组件**，若组件没有定义，则报错。\n8. 它最终产生的就是一个`JS对象`\n\n\n",
      "date": 1617115208000,
      "post": true,
      "tags": ["React"],
      "title": "React 创建虚拟DOM的两种方式",
      "titleEng": "react-VDOM",
      "url": "https://lzxjack.top/post?title=react-VDOM"
    },
    {
      "_id": "8937eaa96128f4fd06b864491707b517",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. state\n\n```javascript\n//1.创建组件\nclass Weather extends React.Component {\n    //构造器调用几次？ ———— 1次\n    constructor(props) {\n        console.log('constructor');\n        super(props);\n        //初始化状态\n        this.state = { isHot: false, wind: '微风' };\n        //解决changeWeather中this指向问题\n        this.changeWeather = this.changeWeather.bind(this);\n    }\n\n    //render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数\n    render() {\n        console.log('render');\n        //读取状态\n        const { isHot, wind } = this.state;\n        return (\n            <h1 onClick={this.changeWeather}>\n                今天天气很{isHot ? '炎热' : '凉爽'}，{wind}\n            </h1>\n        );\n    }\n\n    //changeWeather调用几次？ ———— 点几次调几次\n    changeWeather() {\n        //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用\n        //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用\n        //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined\n\n        //获取原来的isHot值\n        const isHot = this.state.isHot;\n        //状态(state)不可直接更改\n        //状态必须通过setState进行更新,且更新是一种合并，不是替换。\n        this.setState({ isHot: !isHot });\n    }\n}\n//2.渲染组件到页面\nReactDOM.render(<Weather />, document.getElementById('test'));\n```\n\n简写：\n\n```javascript\nclass Weather extends React.Component {\n    // 初始化状态\n    state = { isHot: false, wind: '微风' };\n    render() {\n        return (\n            <h1 onClick={this.changeWeather}>\n                天气{this.state.isHot ? '炎热' : '凉爽'},{this.state.wind}\n            </h1>\n        );\n    }\n    // 自定义方法:赋值语句+箭头函数\n    changeWeather = () => {\n        const isHot = this.state.isHot;\n        this.setState({ isHot: !isHot });\n        // console.log(this);\n    };\n}\n\nReactDOM.render(<Weather />, document.getElementById('test'));\n```\n\n-   `state`是组件对象最重要的属性，值是对象(可以包含多个`key-value`的组合)\n-   组件自定义的方法中`this`为`undefined`，解决：\n    -   强制绑定`this`：通过函数对象的`bind()`\n    -   箭头函数\n-   状态数据，不能直接修改或更新，要使用`setState()`方法\n\n## 2. props\n\n```javascript\n//创建组件\nclass Person extends React.Component {\n    constructor(props) {\n        //构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props\n        super(props);\n        console.log('constructor', this.props);\n    }\n\n    //对标签属性进行类型、必要性的限制\n    static propTypes = {\n        name: PropTypes.string.isRequired, //限制name必传，且为字符串\n        sex: PropTypes.string,\n        age: PropTypes.number,\n    };\n\n    //指定默认标签属性值\n    static defaultProps = {\n        sex: '男',\n        age: 18,\n    };\n\n    render() {\n        // console.log(this);\n        const { name, age, sex } = this.props;\n        //props是只读的\n        //this.props.name = 'jack' //此行代码会报错，因为props是只读的\n        return (\n            <ul>\n                <li>姓名：{name}</li>\n                <li>性别：{sex}</li>\n                <li>年龄：{age + 1}</li>\n            </ul>\n        );\n    }\n}\nconst p1 = { name: 'Tom', sex: '女', age: 20 };\n//渲染组件到页面\nReactDOM.render(<Person {...p1} />, document.getElementById('test'));\n```\n\n-   每个组件对象都会有`props`属性\n-   组件标签的所有属性都保存在`props`中\n-   通过标签属性从组件外向组件内传递变化的数据\n\n**函数式组件使用`props`：**\n\n```javascript\n//创建组件\nfunction Person(props) {\n    const { name, age, sex } = props;\n    return (\n        <ul>\n            <li>姓名：{name}</li>\n            <li>性别：{sex}</li>\n            <li>年龄：{age}</li>\n        </ul>\n    );\n}\nPerson.propTypes = {\n    name: PropTypes.string.isRequired, //限制name必传，且为字符串\n    sex: PropTypes.string, //限制sex为字符串\n    age: PropTypes.number, //限制age为数值\n};\n\n//指定默认标签属性值\nPerson.defaultProps = {\n    sex: '男', //sex默认值为男\n    age: 18, //age默认值为18\n};\nconst p1 = { name: 'Tom', sex: '女', age: 20 };\n//渲染组件到页面\nReactDOM.render(<Person {...p1} />, document.getElementById('test'));\n```\n\n## 3. refs\n\n不要过度使用`ref`：发生事件的事件源和要操作的元素是同一个时，可以不使用`ref`。\n\n通过`onXxx`属性指定事件处理函数：\n\n-   React 使用的是自定义事件，而不是使用的原生 DOM 事件——兼容性\n-   React 中的事件是通过**事件委托**方式处理的（委托给组件最外层的元素）——高效\n\n### 1. 字符串形式\n\n```javascript\n//创建组件\nclass Demo extends React.Component {\n    //打印左侧输入框的数据\n    showData = () => {\n        console.log(this);\n        const { input1 } = this.refs;\n        console.log(input1.value);\n    };\n    //打印右侧输入框的数据\n    showData2 = () => {\n        const { input2 } = this.refs;\n        console.log(input2.value);\n    };\n    render() {\n        return (\n            <div>\n                <input ref=\"input1\" type=\"text\" placeholder=\"点击按钮提示数据\" />\n                &nbsp;\n                <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;\n                <input ref=\"input2\" onBlur={this.showData2} type=\"text\" placeholder=\"失去焦点提示数据\" />\n            </div>\n        );\n    }\n}\n//渲染组件到页面\nReactDOM.render(<Demo />, document.getElementById('test'));\n```\n\n### 2. 回调函数形式\n\n```javascript\n//创建组件\nclass Demo extends React.Component {\n    //展示左侧输入框的数据\n    showData = () => {\n        const { input1 } = this;\n        alert(input1.value);\n    };\n    //展示右侧输入框的数据\n    showData2 = () => {\n        const { input2 } = this;\n        alert(input2.value);\n    };\n    render() {\n        return (\n            <div>\n                <input ref={currentNode => (this.input1 = currentNode)} type=\"text\" placeholder=\"点击按钮提示数据\" />\n                &nbsp;\n                <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;\n                <input\n                    onBlur={this.showData2}\n                    ref={currentNode => (this.input2 = currentNode)}\n                    type=\"text\"\n                    placeholder=\"失去焦点提示数据\"\n                />\n                &nbsp;\n            </div>\n        );\n    }\n}\n//渲染组件到页面\nReactDOM.render(<Demo a=\"1\" b=\"2\" />, document.getElementById('test'));\n```\n\n### 3. createRef创建ref容器\n\n```javascript\n//创建组件\nclass Demo extends React.Component {\n    myRef = React.createRef();\n    myRef2 = React.createRef();\n    //展示左侧输入框的数据\n    showData = () => {\n        console.log(this.myRef.current.value);\n    };\n    //展示右侧输入框的数据\n    showData2 = () => {\n        console.log(this.myRef2.current.value);\n    };\n    render() {\n        return (\n            <div>\n                <input ref={this.myRef} type=\"text\" placeholder=\"点击按钮提示数据\" />\n                &nbsp;\n                <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;\n                <input onBlur={this.showData2} ref={this.myRef2} type=\"text\" placeholder=\"失去焦点提示数据\" />\n                &nbsp;\n            </div>\n        );\n    }\n}\n//渲染组件到页面\nReactDOM.render(<Demo a=\"1\" b=\"2\" />, document.getElementById('test'));\n```\n\n-   `React.createRef()`调用后可以返回一个容器，该容器可以存储被`ref`所标识的节点，该容器只能存一个节点\n\n\n",
      "date": 1617113998000,
      "post": true,
      "tags": ["React"],
      "title": "React 组件三大属性",
      "titleEng": "react-props",
      "url": "https://lzxjack.top/post?title=react-props"
    },
    {
      "_id": "cd045e756128f72108467c8343f47a7e",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "与旧版生命周期相比，React 生命周期即将废弃`componentWillMount()`、`componentWillReceiveProps()`、`componentWillUpdate()`三个钩子，现在使用会出现警告，下一个大版本需要加上`UNSAFE_`前缀才能使用，以后可能会被彻底废弃，不建议使用。\n\n新版增加了两个钩子：`getDerivedStateFromProps()`和`getSnapshotBeforeUpdate()`。\n\n## 1. 初始化阶段\n\n由`ReactDOM.render()`触发\n\n1. `constructor()`\n\n2. `getDerivedStateFromProps()`\n\n    在调用`render()`方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新`state`，如果返回 `null` 则不更新任何内容\n\n    使用场景（罕见）：`state`的值在任何时候都取决于`props`\n\n3. `render()`\n\n4. `componentDidMount()`\n\n    一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息\n\n## 2. 更新阶段\n\n由组件内部`this.setSate()`或父组件重新`render()`触发\n\n1. `getDerivedStateFromProps()`\n\n2. `shouldComponentUpdate()`\n\n3. `render()`\n\n4. `getSnapshotBeforeUpdate()`\n\n    最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的**任何返回值**将**作为参数**传递给 `componentDidUpdate()`\n\n5. `componentDidUpdate()`\n\n## 3. 卸载组件\n\n由`ReactDOM.unmountComponentAtNode()`触发\n\n1. `componentWillUnmount()`\n\n    组件即将卸载时触发\n\n    一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息\n\n![](https://img.lzxjack.top:99/20210330151933.png)\n\n\n",
      "date": 1617100018000,
      "post": true,
      "tags": ["React"],
      "title": "React 生命周期（新）",
      "titleEng": "react-life-new",
      "url": "https://lzxjack.top/post?title=react-life-new"
    },
    {
      "_id": "14139e12611f4e3e06124dff0ad974d0",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "Hexo 博客相关",
      "content": "## 1. 前言\n\n之前我需要更新博客时，都需要在命令行切换到博客**根目录**输入`hexo clean`、`hexo g`等命令，才能实现清除缓存、生成静态文件等操作。\n\n后来知道了可以直接输入`hexo clean&&hexo g&&hexo d`，直接完成整套过程，但每次更新还是要手动输入。\n\n再后来学到了一个编写脚本的方法，可以一键运行，自动实现整个过程。只需要双击运行，就可以做其他事情了，部署完成后命令行自动关闭。\n\n## 2. 实现方法\n\n新建`txt文本文件`，将后缀改为`.bat`，编写如下代码，分别实现`一键本地预览`、`一键部署博客`、`博客源文件一键push`：\n\n**tab 本地预览**：\n\n```powershell\n@echo off\ncd E:\\Hexo-Blog\nhexo clean&&hexo g&&hexo s\n```\n**tab 一键部署**：\n\n```powershell\n@echo off\ncd E:\\Hexo-Blog\nhexo clean&&hexo g&&gulp&&hexo d\n```\n\n**一键push**：\n\n```powershell\n@echo off\ncd E:\\hexoBlogFile\ngit add .\ngit commit -m '123'\ngit push\n```\n\n<!-- endtab -->\n\n\n`@echo off`表示**不显示后续命令行及当前命令行**。\n\n因为我的脚本文件就在`E`盘中，所以不需要切换盘符。\n\n为了隐藏后缀名，在桌面创建了快捷方式：\n\n![](https://img.lzxjack.top:99/20210330170544.png)\n\n这样每次更新博客后，只需要双击运行相应的脚本就可以啦！\n\n\n",
      "date": 1617098110000,
      "post": true,
      "tags": ["实用技巧", "Hexo", "脚本"],
      "title": "编写BAT脚本实现Hexo一键部署",
      "titleEng": "bat",
      "url": "https://lzxjack.top/post?title=bat"
    },
    {
      "_id": "8937eaa96128f66506b88fd15bec1533",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 非受控组件\n\n```javascript\nclass Login extends React.Component {\n    handleSubmit = event => {\n        event.preventDefault(); //阻止表单提交\n        const { username, password } = this;\n        alert(`你输入的用户名是：${username.value},你输入的密码是：${password.value}`);\n    };\n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                用户名：\n                <input ref={c => (this.username = c)} type=\"text\" name=\"username\" />\n                密码：\n                <input ref={c => (this.password = c)} type=\"password\" name=\"password\" />\n                <button>登录</button>\n            </form>\n        );\n    }\n}\n```\n\n## 2. 受控组件\n\n```javascript\nclass Login extends React.Component {\n    //初始化状态\n    state = {\n        username: '', //用户名\n        password: '', //密码\n    };\n\n    //保存用户名到状态中\n    saveUsername = event => {\n        this.setState({ username: event.target.value });\n    };\n\n    //保存密码到状态中\n    savePassword = event => {\n        this.setState({ password: event.target.value });\n    };\n\n    //表单提交的回调\n    handleSubmit = event => {\n        event.preventDefault(); //阻止表单提交\n        const { username, password } = this.state;\n        console.log(`你输入的用户名是：${username},你输入的密码是：${password}`);\n    };\n\n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                用户名：\n                <input onChange={this.saveUsername} type=\"text\" name=\"username\" />\n                密码：\n                <input onChange={this.savePassword} type=\"password\" name=\"password\" />\n                <button>登录</button>\n            </form>\n        );\n    }\n}\n```\n\n### 1. 高阶函数\n\n如果一个函数符合下面 2 个规范中的**任何一个**，那该函数就是高阶函数：\n\n-   若`A`函数，接收的**参数**是一个函数，那么`A`就可以称之为高阶函数。\n-   若`A`函数，**调用的返回值**依然是一个函数，那么`A`就可以称之为高阶函数。\n\n常见的高阶函数有：`Promise`、`setTimeout`、`arr.map()`等等。\n\n### 2. 函数柯里化\n\n通过函数调用继续**返回函数**的方式，实现**多次接收参数**最后统一处理的函数编码形式。\n\n```javascript\nfunction sum(a) {\n    return b => {\n        return c => {\n            return a + b + c;\n        };\n    };\n}\n```\n\n### 3. 函数柯里化实现表单数据收集\n\n```javascript\nclass Login extends React.Component {\n    //初始化状态\n    state = {\n        username: '', //用户名\n        password: '', //密码\n    };\n\n    //保存表单数据到状态中\n    saveFormData = dataType => {\n        return event => {\n            this.setState({ [dataType]: event.target.value });\n        };\n    };\n\n    //表单提交的回调\n    handleSubmit = event => {\n        event.preventDefault(); //阻止表单提交\n        const { username, password } = this.state;\n        alert(`你输入的用户名是：${username},你输入的密码是：${password}`);\n    };\n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                用户名：\n                <input onChange={this.saveFormData('username')} type=\"text\" name=\"username\" />\n                密码：\n                <input onChange={this.saveFormData('password')} type=\"password\" name=\"password\" />\n                <button>登录</button>\n            </form>\n        );\n    }\n}\n```\n\n### 4. 改进\n\n```javascript\nclass Login extends React.Component {\n    //初始化状态\n    state = {\n        username: '', //用户名\n        password: '', //密码\n    };\n\n    //保存表单数据到状态中\n    saveFormData = (dataType, event) => {\n        this.setState({ [dataType]: event.target.value });\n    };\n\n    //表单提交的回调\n    handleSubmit = event => {\n        event.preventDefault(); //阻止表单提交\n        const { username, password } = this.state;\n        alert(`你输入的用户名是：${username},你输入的密码是：${password}`);\n    };\n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                用户名：\n                <input onChange={event => this.saveFormData('username', event)} type=\"text\" name=\"username\" />\n                密码：\n                <input onChange={event => this.saveFormData('password', event)} type=\"password\" name=\"password\" />\n                <button>登录</button>\n            </form>\n        );\n    }\n}\n```\n\n\n",
      "date": 1617089804000,
      "post": true,
      "tags": ["React"],
      "title": "React 收集表单数据",
      "titleEng": "react-get-form-data",
      "url": "https://lzxjack.top/post?title=react-get-form-data"
    },
    {
      "_id": "cd045e75611f421d06c555054ba55e00",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. async \n\n`async`属性，立即下载脚本并执行。相当于告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本。\n\n因此，标记为`async`的脚本并**不保证**能按照它们出现的次序执行。\n\n`async`属性仅适用于外部脚本（只有在使用`src`属性时），因此浏览器会忽略行内脚本的`async`属性。\n\n使用`async`也会告诉页面你不会使用`document.write`，不过好的 Web 开发实践根本就不推荐使用这个方法。\n\n## 2. defer\n\n`defer`属性相当于告诉浏览器，**立即下载，但推迟执行**。\n\n`defer`属性仅适用于外部脚本（只有在使用`src`属性时），因此浏览器会忽略行内脚本的`defer`属性。\n\n若有多个`script`含`defer`属性，推迟执行的脚本**不一定**总会按顺序执行或者在`DOMContentLoaded`事件之前执行，因此最好只包含一个这样的脚本。\n\n对`defer`属性的支持是从 IE4、Firefox 3.5、Safari 5 和 Chrome 7 开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在**页面底部**比较好。\n\n## 3. 区别\n\n![](https://img.lzxjack.top:99/20210330200553.jpg)\n\n对于 HTML 标签`<script src=\"script.js\"></script>`\n\n简单地说，如果：\n\n-   既没有`defer`也没有`async`属性，则浏览器遇到该`script`标签时，会立即**加载**并**执行**指定的脚本。执行完毕后，才继续解析后面的标签。\n-   有`async `属性，浏览器遇到该`script`标签时，**加载**脚本的过程与解析后面标签的过程同时进行。加载完毕后，单独**执行**该脚本。\n-   有`defer`属性，浏览器遇到该`script`标签时，**加载**脚本的过程与解析后面标签的过程同时进行。但是**执行**脚本的过程，在解析完所有元素之后才执行。可以这样理解：`defer`本身就有**推迟**的意思，在**加载**完脚本后，将**执行**过程**推迟到最后**。\n\n\n",
      "date": 1617068762000,
      "post": true,
      "tags": ["HTML"],
      "title": "HTML script标签中async和defer的区别",
      "titleEng": "async-defer",
      "url": "https://lzxjack.top/post?title=async-defer"
    }
  ],
  "requestId": "1446b3ca6c043"
}
