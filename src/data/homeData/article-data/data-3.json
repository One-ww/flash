{
  "data": [
    {
      "_id": "9e7190f1618a1ec20483cd0006db61dd",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "## 1. setState同步？异步？\n\n在 React 的类式组件中，我们可以使用`setState`方法更新`state`状态。但**有些时候**使用`setState`之后，得不到最新的数据。\n\n其实 React 中`setState`本身执行的过程和代码是同步的，只是因为 React 框架本身的性能优化机制而导致的。React 中**合成事件**和**生命周期函数**的调用顺序在更新之前，导致在**合成事件**和**生命周期函数**中无法立刻得到更新后的值，形成了**异步**的形式。\n\n假如在一个**合成事件**中，循环调用了`setState`方法`n`次，如果 React 没有优化，当前组件就要被渲染`n`次，这对性能来说是很大的浪费。所以，React 为了性能原因，对调用多次`setState`方法合并为一个来执行。当执行`setState`的时候，`state`中的数据并不会马上更新。\n\n前面已经说到，在 React 的**合成事件**和**生命周期函数**中直接调用`setState`，会表现出**异步**的形式。\n\n除此之外，如果越过 React 的性能优化机制，在原生事件、`setTimeout`中使用`setState`，就会表现出**同步**的形式。\n\n## 2. 表现为异步\n\n### 1. React 合成事件\n\n在 React 中直接使用的事件，如`onChange`、`onClick`等，都是由 React 封装后的事件，是合成事件，由 React 管理。那么由于性能优化的机制，在合成事件中直接调用`setState`，将表现出**异步**的形式。\n\n如下代码，在合成事件`onClick`中，直接将`state`中的`count`加`1`，并在此之后打印`count`的值，结果**第一次**点击按钮时，会打印出`0`，而不是最新的`1`。\n\n```javascript\nstate = { count: 0 };\nadd = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count); // 0\n};\nrender() {\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button onClick={this.add}>add</button>\n        </>\n    );\n}\n```\n\n### 2. 生命周期函数\n\n生命周期函数也是由 React 所管理，在生命周期函数中直接调用`setState`，也会表现出**异步**的形式。\n\n如下代码，在生命周期`componentDidMount`函数中，将`state`中的`count`加`1`，并在此之后打印`count`的值，结果打印出`0`，而不是最新的`1`。\n\n```javascript\nstate = { count: 0 };\ncomponentDidMount() {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count); // 0\n}\nrender() {\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button>add</button>\n        </>\n    );\n}\n```\n\n## 3. 表现为同步\n\n### 1. 原生事件\n\n`setState`本身执行的过程是同步的，使用原生事件，绕过 React 的管理，将表现出**同步**的形式。\n\n如下代码，通过`id`获取到 DOM 元素，用原生方法绑定点击事件。在点击事件中，将`state`中的`count`加`1`，并在此之后打印`count`的值，结果会打印最新的`count`值`1`。\n\n```javascript\nstate = { count: 0 };\ncomponentDidMount() {\n    const btn = document.getElementById('btn');\n    btn.onclick = () => {\n        this.setState({ count: this.state.count + 1 });\n        console.log(this.state.count); // 1\n    };\n}\nrender() {\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button id=\"btn\">add</button>\n        </>\n    );\n}\n```\n\n### 2. setTimeout\n\n如下代码，在生命周期`componentDidMount`函数中写了一个定时器`setTimeout`，在`setTimeout`内部将`state`中的`count`加`1`，并在此之后打印`count`的值，结果会打印最新的`count`值`1`。\n\n`setState`虽然也是写在生命周期`componentDidMount`函数中的，但并不是直接写在`componentDidMount`里，而是套了一层`setTimeout`。这样，`setState`就表现出**同步**的形式。\n\n```javascript\nstate = { count: 0 };\ncomponentDidMount() {\n    setTimeout(() => {\n        this.setState({ count: this.state.count + 1 });\n        console.log(this.state.count); // 1\n    }, 0);\n}\nrender() {\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button>add</button>\n        </>\n    );\n}\n```\n\n## 4. setState的第二个参数\n\n无论`setState`的**对象式**写法，还是**函数式**写法，都有**第二个参数**，为可选的**回调函数**，这个回调函数在**状态更新完毕**、**界面也更新后**（`render`调用后）才被调用。\n\n如下代码所示，`setState`虽然直接在`componentDidMount`中调用，但在`setState`的回调函数中打印`count`的值，得到了最新的值`1`，因为回调函数在状态更新完毕后才被调用，当然能得到最新的`count`了。\n\n```javascript\nstate = { count: 0 };\ncomponentDidMount() {\n    this.setState({ count: this.state.count + 1 }, () => {\n        console.log(this.state.count); // 1\n    });\n}\nrender() {\n    return (\n        <>\n            <div>当前计数：{this.state.count}</div>\n            <button>add</button>\n        </>\n    );\n}\n```\n\n",
      "date": 1636441712000,
      "post": true,
      "tags": ["React"],
      "title": "React 关于setState同步或异步问题的理解",
      "titleEng": "react-setstate"
    },
    {
      "_id": "9e7190f161891f70046412ec74c4954a",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "在 React 中，**父子组件**的通信是常见的问题，除了使用状态管理工具（如`redux`）以外，也可以实现父子组件的相互通信。\n\n其中，父组件可以通过`props`、**原型方法**向子组件通信，子组件可以通过**回调函数**、**事件冒泡**向父组件通信。\n\n## 1. 父组件向子组件通信\n\n### 1. props\n\n如下代码，`name`作为`props`由父组件传递给子组件，子组件拿到`name`后，渲染在页面上。\n\n参数`name`由父组件传递给了子组件。\n\n```javascript\nimport { useState } from 'react';\n\nconst Son = ({ name }) => {\n    return <div>{name}</div>;\n};\n\nconst Father = () => {\n    const [name, setName] = useState('Jack');\n    return (\n        <>\n            <Son name={name} />\n        </>\n    );\n};\n\nexport default Father;\n```\n\n### 2. 原型方法\n\n父组件通过`React.createRef()`创建`Ref`，保存在实例属性`myRef`上。父组件中，渲染子组件时，定义一个`Ref`属性，值为刚创建的`myRef`。\n\n父组件调用子组件的`myFunc`函数，传递一个参数，子组件接收到参数，打印出参数。\n\n参数从父组件传递给子组件，完成了父组件向子组件通信。\n\n```javascript\nimport React, { Component, Fragment } from 'react';\n\nclass Son extends Component {\n    myFunc(name) {\n        console.log(name);\n    }\n    render() {\n        return <></>;\n    }\n}\n\n// 父组件\nexport default class Father extends Component {\n    constructor(props) {\n        super(props);\n        // 创建Ref，并保存在实例属性myRef上\n        this.myRef = React.createRef();\n    }\n\n    componentDidMount() {\n        // 调用子组件的函数，传递一个参数\n        this.myRef.current.myFunc('Jack');\n    }\n    render() {\n        return (\n            <>\n                <Son ref={this.myRef} />\n            </>\n        );\n    }\n}\n```\n\n## 2. 子组件向父组件通信\n\n### 1. 回调函数\n\n如下代码所示，父组件显示当前计数值，但不通过父组件本身修改这个值。父组件给子组件传递一个**函数**，子组件点击按钮时，调用这个函数，实现计数值加一。\n\n在子组件内部，修改了父组件中的值，从而完成了子组件向父组件通信。\n\n```javascript\nimport { useState } from 'react';\n\nconst Son = ({ setCount }) => {\n    return <button onClick={() => setCount(count => count + 1)}>点击+1</button>;\n};\n\nconst Father = () => {\n    const [count, setCount] = useState(0);\n    return (\n        <>\n            <div>计数值：{count}</div>\n            <Son setCount={setCount} />\n        </>\n    );\n};\n\nexport default Father;\n```\n\n### 2. 事件冒泡\n\n如下代码，利用了**事件冒泡**机制，点击子组件的`button`按钮，事件会冒泡到父组件身上，触发父组件的`onClick`函数，打印出`Jack`。\n\n点击的是子组件，父组件执行函数，完成了子组件向父组件通信。\n\n```javascript\nconst Son = () => {\n    return <button>点击</button>;\n};\n\nconst Father = () => {\n    const sayName = name => {\n        console.log(name);\n    };\n    return (\n        <div onClick={() => sayName('Jack')}>\n            <Son />\n        </div>\n    );\n};\n\nexport default Father;\n```\n\n",
      "date": 1636376383000,
      "post": true,
      "tags": ["React"],
      "title": "React 父子组件通信的几种方法",
      "titleEng": "react-father-son"
    },
    {
      "_id": "859059a56183cf8603b9ecd259a983e7",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "React 学习笔记",
      "content": "最近使用 React + Hook + TS 写了一个练手的`demo`，练习了 React + Hook 的 TypeScript 写法。本文主要记录自己在写`demo`过程中，遇到关于 TypeScript 写法上的坑。\n\n\n\n## 1. 创建 TS 项目\n\n使用`create-react-app`创建`React`项目，应该没有什么坑，记得在创建`React`项目的时候，添加`typescript`配置即可：\n\n```powershell\nnpx create-react-app app-name --template typescript\n```\n\n## 2. 在 React Hook 中 TS 写法\n\n将所有`.js`文件全部更名为`.ts`后缀，所有`.jsx`文件更名为`.tsx`，若还使用 JavaScript 的写法的话，项目还是能运行的，但配置了 TypeScript 还写 JavaScript 就达不到练手的目的了！\n\n在写`demo`的过程中，遇到了如下几个坑，经过查找后得到了解决，特此记录。\n\n### 1. 函数组件\n\n既然要用 React Hook，就需要写函数组件，我们需要告诉 TypeScript，这个函数是个 React 组件，在 JavaScript 中，通常这样定义一个函数组件：\n\n```javascript\nconst App = () => {\n    return <>App</>;\n};\n```\n\n配置了 TypeScript，就需要加上函数类型。React 提供了`React.FunctionComponent`的类型，意思是**函数组件**，我们可以直接简写为`React.FC`，如下代码所示：\n\n```typescript\nconst App: React.FC = () => {\n    return <>App</>;\n};\n```\n\n### 2. 类型声明举例\n\n一些简单的类型声明，比如`number`、`string`、`boolean`类型的，只需在声明的变量后面加上`:[类型]`即可。\n\n比如，定义一个`number`类型的`age`和`boolean`类型的`isDone`：\n\n```typescript\nlet age: number = 37;\nlet isDone: boolean = false;\n```\n\n在写`demo`中，我使用到一个**对象数组**，如下结构：\n\n```typescript\n[\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n]\n```\n\n那么一般的`array`类型已经满足不了了，这时就需要再定义一个`interface`：\n\n```typescript\ninterface TaskObj {\n    id: string;\n    content: string;\n    isDone: boolean;\n}\n```\n\n**注意**：接口名通常是**大写字母**开头。\n\n这个`interface`表示，定义的对象需要同时满足以下条件：\n\n- 有`id`属性，且类型为`string`\n- 有`content`属性，且类型为`string`\n- 有`isDone`属性，且类型为`boolean`\n\nTypeScript并不会检查属性的顺序，只需相应的属性存在，并且类型也满足即可。\n\n这时候定义单个对象，就可以使用刚刚定义的`interface`了：\n\n```typescript\nconst obj: TaskObj = { id: 'xxxx', content: 'xxxxxxx', isDone: false };\n```\n\n但如果需要定义上述的**对象数组**，需要这样写：\n\n```typescript\nconst allTasks: TaskObj[] = [\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n];\n```\n\n`TaskObj[]`表示该类型是一个数组，数组里的元素需要满足`TaskObj`接口。\n\n### 3. useState\n\n对于存储`string`类型的`state`，在`useState`右边加上`<string>`即可：\n\n```typescript\nconst [input, setInput] = useState<string>('');\n```\n\n实际上，`useState<string>('')`已经给了初始值`''`，那么 TypeScript 会**自动类型判断**，即使不写`<string>`也可以。\n\n如果要存储的数据结构如下：\n\n```typescript\n[\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n    { id: 'xxxx', content: 'xxxxxxx', isDone: false },\n]\n```\n\n那么还是需要上文提到的`interface`：\n\n```typescript\ninterface TaskObj {\n    id: string;\n    content: string;\n    isDone: boolean;\n}\n\nconst [task, setTask] = useState<TaskObj[]>([]);\n```\n\n### 4. 父组件给子组件传参\n\n在 JavaScript 中，父组件给子组件传递参数，直接子组件上写，子组件通过`props`接收即可：\n\n```tsx\n<Doing doing={doing} setTask={setTask} />\n```\n\n但是 TypeScript 若直接这么写会报错，原因是子组件并没有满足传递参数的接口，需要自己定义接口。\n\n如上代码，在子组件`Doing`外，需要定一个满足传递参数的接口：\n\n```typescript\ninterface DoingProps {\n    doing: TaskObj[];\n    setTask: Function;\n}\n\nconst Doing: React.FC<DoingProps> = ({ doing, setTask }) => {\n\t...\n}\n```\n\n如上代码，定义了一个`DoingProps`接口，并且在子组件的`React.FC`后添加`<DoingProps>`，表明该组件接收的参数需要满足如下条件：\n\n- 有`doing`属性，且类型为数组，数组的元素满足`TaskObj`接口。\n- 有`setTask`属性，且类型是一个函数。\n\n这样，父组件给子组件传参的过程就用 TypeScript 实现了。\n\n### 5. 类型断言\n\n在写`demo`中，需要拿到一个输入框的`DOM`节点，写了如下代码：\n\n```typescript\nconst inputNode: HTMLInputElement = document.getElementById(`${id}`)\n```\n\nTypeScript 却提示有如下错误：\n\n![](https://img.huahuabiz.com/user_files/20241222/1734874731909719.png)\n\n这时候只需加上类型断言即可，明确告诉编译器变量的类型：\n\n```typescript\nconst inputNode: HTMLInputElement = document.getElementById(`${id}`) as HTMLInputElement;\n```\n\n### 6. 键盘事件\n\n需要判断按下的按键，这时候需要键盘事件对象，用 TypeScript 来写，需要先将键盘事件`KeyboardEvent`引入：\n\n```typescript\nimport { KeyboardEvent } from 'react';\n```\n\n传递事件对象参数时，需要指明为键盘事件：\n\n```tsx\n<input \n    type=\"text\" \n    defaultValue=\"{obj.content}\" \n    onKeyDown={(e: KeyboardEvent) => updateTask(e, obj.id, obj.content)}\n/>\n```\n\n`updateTask`函数定义如下：\n\n```typescript\nconst updateTask = (e: KeyboardEvent, id: string, oldContent: string) => {\n\t...\n}\n```\n\n",
      "date": 1636028167000,
      "post": true,
      "tags": ["TypeScript"],
      "title": "关于React Hook使用TypeScript遇到的问题记录",
      "titleEng": "react-ts"
    },
    {
      "_id": "fa24ce1a618343cc040b6fdc1e88560a",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "在 JavaScript 的数组扩展运算符中，可以很轻松地将数组**展开**，并创建新的数组：\n\n```javascript\nconst arr = [1,2,3,4,5];\n\nconst arr0 = [...arr];\nconst arr1 = [1,...arr];\nconst arr2 = [1,...arr,3,4];\nconst arr3 = [1,...arr,...arr];\n```\n\n将如上代码复制到<a href=\"https://babeljs.io/\" target=\"_blank\">babel</a>官网，`babel`会自动将代码转换成浏览器兼容的 JavaScript 代码，就能看到它如何实现的了：\n\n```javascript\n\"use strict\";\n\nvar arr = [1, 2, 3, 4, 5];\nvar arr0 = [].concat(arr);\nvar arr1 = [1].concat(arr);\nvar arr2 = [1].concat(arr, [3, 4]);\nvar arr3 = [1].concat(arr, arr);\n```\n\n也可以查看展开数组，并`push`到另一数组的实现：\n\n```javascript\nconst arr = [1,2,3,4,5];\n\nconst arr0 = [];\narr0.push(...arr);\n```\n\n`babel`转换后：\n\n```javascript\n\"use strict\";\n\nvar arr = [1, 2, 3, 4, 5];\nvar arr0 = [];\narr0.push.apply(arr0, arr);\n```\n\n",
      "date": 1635992470000,
      "post": true,
      "tags": ["JavaScript", "babel"],
      "title": "JavaScript 关于数组的扩展运算符实现",
      "titleEng": "arr-extend"
    },
    {
      "_id": "fa24ce1a6182418b03e900e65b77ef5f",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "## 1. 定义\n\n`Promise`对象用于表示一个**异步操作**的最终完成（或者失败）及其结果值，是异步变成的一种解决方案，比传统的解决方案（回调函数和事件）更合理、更强大。ES6 将其写进了语言标准，统一用法，提供了原生的`Promise`对象。\n\n一个`Promise`对象代表一个在这个`Promise`被创建出来时不一定已知的值，它可以把异步操作最终的成功返回值或失败原因和相应的处理程序关联起来。这样，异步方法并不会立即返回最终的值，而是会返回一个`Promise`。\n\n一个`Promise`必然处于以下几种状态之一：\n\n- `pending`：初始状态，未被兑现，也未被拒绝\n- `fulfilled`：已兑现，操作完成\n- `rejected`：已拒绝，操作失败\n\n## 2. 基本使用\n\n通过`new`操作符来完成`Promise`的实例化，需要传入一个函数作为参数。`Promise`的状态是私有的，只能在内部进行操作。在传入的函数中，控制`Promise`的状态转换是通过调用它的两个函数参数实现的，通常命名为`resolve()`和`reject()`。调用`resolve()`将状态转换为`fulfilled`，调用`reject()`将状态转换为`rejected`。另外，调用`reject()`将**抛出错误**。\n\n如下代码，使用`new`操作符实例化了一个`Promise`，传入了一个函数，函数有两个参数：`resolve()`和`reject()`。通过简单的判断，控制`Promise`的状态转换。显然，当前代码执行后，应该调用`resolve()`，即将状态转化为`fulfilled`。\n\n在`Promise`后，调用了`then`方法，`then`方法**最多**接收两个函数作为参数，第一个参数是状态变为`fulfilled`的回调函数，第二个参数是状态变为`rejected`的回调函数。本例中，由于`Promise`状态已变为`fulfilled`，故`then`方法执行第一个参数，打印出`resolve()`方法传来的值：`'fulfilled'`。\n\n```javascript\nnew Promise((resolve, reject) => {\n    const a = 1;\n    if (a === 1) {\n        resolve('fulfilled');\n    } else {\n        reject('rejected');\n    }\n}).then(\n    fulfilledValue => console.log(fulfilledValue),\n    rejectedValue => console.log(rejectedValue)\n);\n// fulfilled\n```\n\n如果稍微修改一下`a`的值，使`Promise`的状态转为`rejected`，那么`then`方法就会执行第二个参数，打印出`reject()`方法传来的值：`'rejected'`。\n\n```javascript\nnew Promise((resolve, reject) => {\n    const a = 2;\n    if (a === 1) {\n        resolve('fulfilled');\n    } else {\n        reject('rejected');\n    }\n}).then(\n    fulfilledValue => console.log(fulfilledValue),\n    rejectedValue => console.log(rejectedValue)\n);\n// rejected\n```\n\n另外，如果内部抛出错误，`then`方法也会执行第二个函数：\n\n```javascript\nnew Promise((resolve, reject) => {\n    throw 'error';\n}).then(null, error => console.log(error));\n// error\n```\n\n## 3. 原型方法\n\n### 1. Promise.prototype.then()\n\n`then()`方法返回一个新的`Promise`，如上文所述，它**最多**需要两个参数：`Promise`的**成功**和**失败**的回调函数。因为`Promise`只能转换一次状态，所以这两个函数一定是**互斥**的。\n\n`then`方法支持**链式调用**。\n\n返回的新`Promise`，具体情况如下，如果`then`中的回调函数：\n\n（1）返回了一个**值**，那么`then`返回的`Promise`是`fulfilled`状态，并将**返回的值**作为`fulfilled`状态的回调函数参数值。\n\n如下代码所示，最初的`Promise`状态是`fulfilled`，那么第一个`then`方法调用第一个回调函数，先打印出`1`，又返回了`'Jack'`，那么该`then`返回的`Promise`也是`fulfilled`状态，并且将`'Jack'`作为第二个`then`方法的回调函数参数。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n        return 'Jack';\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// fulfilledValue 1\n// fulfilledValue Jack\n```\n\n这里，如果把最初的`Promise`状态改成`rejected`，那么就如下代码，第一个`then`方法调用的是它的第二个回调函数，这个回调函数返回`'Jack'`，是个值，那么这个`then`返回的就是`fulfilled`状态，并将**返回的值**作为`fulfilled`状态的回调函数参数值，和上文的规则完全一致。\n\n```javascript\nnew Promise((resolve, reject) => {\n    // resolve(1);\n    reject(-1);\n})\n    .then(\n        value => {\n            console.log('fulfilledValue', value);\n        },\n        value => {\n            console.log('rejectedValue', value);\n            return 'Jack';\n        }\n    )\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// rejectedValue -1\n// fulfilledValue Jack\n```\n\n由此可见，`then`方法不管调用哪个回调函数，返回`Promise`的规则都是一致的。为了方便起见，下文中的最初`Promise`都设置为`fulfilled`状态。\n\n（2）没有返回任何值，那么`then`返回的`Promise`是`fulfilled`状态，并且`fulfilled`状态的回调函数参数值是`undefined`。\n\n如下代码所示，由于第一个`then`没有返回任何值，所以第二个`then`的第一个回调函数的参数是`undefined`。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// fulfilledValue 1\n// fulfilledValue undefined\n```\n\n（3）抛出一个错误，那么`then`返回的`Promise`是`rejected`状态，并将**抛出的错误**作为`fulfilled`状态的回调函数参数值。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n        throw 'Error!';\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// fulfilledValue 1\n// rejectedValue Error!\n```\n\n（4）返回一个是`fulfilled`状态的`Promise`，那么`then`返回的`Promise`是`fulfilled`状态，并且将前面`Promise`**接受状态的回调函数参数**，作为返回的`Promise`**接受状态的回调函数参数**。\n\n如下代码，第一个`then`返回了一个`fulfilled`状态的`Promise`，那么第二个`then`会调用第一个回调函数，并且参数是`'fulfilled'`。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n        return Promise.resolve('fulfilled');\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// fulfilledValue 1\n// fulfilledValue fulfilled\n```\n\n（5）返回一个是`rejected`状态的`Promise`，那么`then`返回的`Promise`是`rejected`状态，并且将前面`Promise`**拒绝状态的回调函数参数**，作为返回的`Promise`**拒绝状态的回调函数参数**。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n        return Promise.reject('rejected');\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n// fulfilledValue 1\n// rejectedValue rejected\n```\n\n（6）返回一个是`pending`状态的`Promise`，那么`then`返回的`Promise`也是`pending`状态，并且它最终状态与前面`Promise`最终状态相同。同时，它变成最终状态**执行的回调函数参数**，与前面`Promise`变成最终状态**执行的回调函数的参数**是**相同**的。\n\n```javascript\nnew Promise((resolve, reject) => {\n    resolve(1);\n    // reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve('1秒后出现');\n            }, 1000);\n        });\n    })\n    .then(\n        res => {\n            console.log('fulfilledValue', res);\n        },\n        res => {\n            console.log('rejectedValue', res);\n        }\n    );\n\n// fulfilledValue 1\n// fulfilledValue 1秒后出现\n```\n\n（7）如果最初的`Promise`是`rejected`状态，且第一个`then`没有第二个函数参数，那么第二个`then`就会执行其第二个回调函数，并且参数为最初`Promise`的`reject`中的参数。\n\n```javascript\nnew Promise((resolve, reject) => {\n    // resolve(1);\n    reject(-1);\n})\n    .then(value => {\n        console.log('fulfilledValue', value);\n    })\n    .then(null, res => {\n        console.log('rejectedValue', res);\n    });\n// rejectedValue -1\n```\n\n### 2. Promise.prototype.catch()\n\n`Promise.prototype.catch()`方法用于给`Promise`添加拒绝处理程序。这个方法只接收一个参数：`onRejected`处理程序。它的行为与调用`Promise.prototype.then(undefined, onRejected)`相同。\n\n如下代码，两种等价的写法。\n\n```javascript\nnew Promise((resolve, reject) => {\n    reject('error');\n}).catch(error => console.log(error));\n// error\n```\n\n```javascript\nnew Promise((resolve, reject) => {\n    reject('error');\n}).then(null, error => console.log(error));\n// error\n```\n\n### 3. Promise.prototype.finally()\n\n`Promise.prototype.finally()`方法用于给`Promise`添加`onFinally`处理程序，这个处理程序在`Promise`转换为`fulfilled`或`rejected`状态时都会执行。但`onFinally`处理程序不知道`Promise`的状态是`fulfilled`还是`rejected`，所以这个方法主要用于**添加清理代码**。\n\n```javascript\nnew Promise((resolve, reject) => {\n    console.log('loading start...');\n    const a = 2;\n    if (a === 1) {\n        resolve(1);\n    } else {\n        reject(-1);\n    }\n})\n    .then(value => {\n        console.log('fulfilled value', value);\n    })\n    .catch(error => console.log('error', error))\n    .finally(() => console.log('loading end...'));\n// loading start...\n// error -1\n// loading end...\n```\n\n## 4. 实例方法\n\n### 1. Promise.all()\n\n`Promise.all()`方法接收一个`Promise`的**可迭代类型**的输入，并且**只**返回一个`Promise`实例， 那个输入的所有`Promise`的`resolve`回调的结果是一个**数组**。简单来说，`Promise.all()`用于将多个`Promise`实例包装成一个新的`Promise`实例。\n\n```javascript\nconst promiseArray = [1, 2, 3, 4].map(item => new Promise(resolve => resolve(item)));\nconsole.log(promiseArray);\n// [ Promise { 1 }, Promise { 2 }, Promise { 3 }, Promise { 4 } ]\n\nPromise.all(promiseArray).then(res => console.log(res));\n// [ 1, 2, 3, 4 ]\n```\n\n### 2. Promise.race()\n\n`Promise.race(iterable)`方法返回一个`Promise`，一旦迭代器中的某个`Promise`**接受**或**拒绝**，返回的`Promise`就会**接受**或**拒绝**。\n\n```javascript\nconst promiseArray = [1, 2, 3, 4].map(item => new Promise(resolve => resolve(item)));\nconsole.log(promiseArray);\n// [ Promise { 1 }, Promise { 2 }, Promise { 3 }, Promise { 4 } ]\n\nPromise.race(promiseArray).then(res => console.log(res));\n// 1\n```\n\n### 3. Promise.resolve()\n\n`Promise.resolve()`方法返回一个**接受状态**的`Promise`对象。\n\n```javascript\nPromise.resolve(1).then(res => console.log(res));\n// 1\n```\n\n### 4. Promise.reject()\n\n`Promise.reject()`方法返回一个带有参数的**拒绝状态**的`Promise`对象。\n\n```javascript\nPromise.reject(-1).then(null, res => console.log(res));\n// -1\n```\n\n\n\n> 以上是本人学习所得，若有不妥，欢迎指出交流！\n\n***\n\n> 参考：\n>\n> - 《JavaScript高级程序设计（第4版）》\n> - <a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\">「MDN」</a>",
      "date": 1635926347000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 异步编程Promise详解",
      "titleEng": "promise"
    },
    {
      "_id": "9e7190f16180c9e40345153401794fd0",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "在 JavaScript 中，ES6 开始引入`class`的概念。实际上，JavaScript 中`class`的本质也是基于原型`prototype`的实现方式作了进一步的封装，其本质还是函数`function`。虽说如此，`class`和`function`还是有不同之处。\n\n## 1. 相同点：都可作为构造函数\n\n### 1. 函数作为构造函数\n\n`class`和`function`都可以作为构造函数，通过`new`操作符来实例化。\n\n如下代码，函数作为构造函数的写法。函数作为构造函数，通常首字母要大写。构造函数中的`this`指向构造函数创建出来的实例对象`usr`。\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n}\n\nconst usr = new Person('Jack');\nconsole.log(usr); // Person { name: 'Jack' }\n```\n\n### 2. 类实现构造函数\n\n类可以包含构造函数方法、实例方法、`setter`函数、`getter`函数和静态类方法，但这些**都不是**必须的。\n\n如下代码所示，定义一个`class`，需要用`class`关键字加上类名，类名建议首字母大写。类中的`constructor`方法是一个特殊的方法，称为**构造函数方法**，用来初始化一个对象，在一个`class`中，只能有一个`constructor`方法，若定义多个`constructor`将会报错。\n\n在用`new`操作符创建类的实例时，会自动调用这个`constructor`函数。若不定义`constructor`，相当于`constructor`为空函数。\n\n```javascript\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nconst usr = new Person('Jack');\nconsole.log(usr); // Person { name: 'Jack' }\n```\n\n类实例化时，传入的参数会用作构造函数的参数，如果没有参数传递，则类名后面的括号可以省略：\n\n```javascript\nclass Person {\n    constructor() {\n        this.name = 'Jack';\n    }\n}\n\nconst usr = new Person;\nconsole.log(usr); // Person { name: 'Jack' }\n```\n\n## 2. 不同点\n\n### 1. class构造函数必须使用new操作符\n\n`class`构造函数与`function`构造函数的主要区别为，调用`class`构造函数必须使用`new`操作符。而普通`function`构造函数如果不使用`new`调用，那么会以全局的`this`（在浏览器中是`window`）作为内部对象。\n\n如下代码，普通`function`构造函数把`window`作为`this`来创建实例：\n\n```javascript\nfunction Person() {}\nconst p = Person();\n```\n\n调用`class`构造函数时如果忘了使用`new`则会抛出错误：\n\n```javascript\nclass Animal {}\nconst a = Animal();\n// TypeError: Class constructor Animal cannot be invoked without 'new'\n```\n\n### 2. class声明不可以提升\n\n`function`构造函数声明存在提升，也就是定义构造函数的部分**可以**写在实例化对象的后面：\n\n```javascript\nconst usr = new Person('Jack');\nconsole.log(usr); // Person { name: 'Jack' }\n\nfunction Person(name) {\n    this.name = name;\n}\n```\n\n`class`声明不存在提升，声明类的部分**不能**写在实例化对象的后面，如下代码所示，报错信息显示`Cannot access 'Person' before initialization`。\n\n```javascript\nconst usr = new Person('Jack');\n// ReferenceError: Cannot access 'Person' before initialization\n\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n}\n```\n\n### 3. class不可以用call、apply、bind改变执行上下文\n\n普通的`function`函数，调用时可以使用`call`、`apply`、`bind`改变其`this`指向，如下代码，调用`sayName`的同时，通过`call`改变其`this`指向为`obj`，打印出了`obj`对象中的`name`属性。\n\n```javascript\nfunction sayName() {\n    console.log(this.name);\n}\n\nconst obj = {\n    name: 'Jack',\n};\n\nsayName.call(obj); // Jack\n```\n\n`call`、`apply`、`bind`具体使用方式见<a href=\"https://www.wwflash.top/post?title=cd045e75611f69fc06cccfd349a889cf&page=13\" target=\"_blank\">「JavaScript call()、apply()、bind()的区别」</a>。\n\n若`class`也尝试用`call`改变其`this`指向时会报错：\n\n```javascript\nclass Person {\n    constructor() {\n        this.name = 'Tom';\n    }\n}\n\nconst obj = {\n    name: 'Jack',\n};\n\nPerson.call(obj); // TypeError: Class constructor Person cannot be invoked without 'new'\n```\n\n\n\n***\n\n> 参考：\n>\n> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class\" target=\"_blank\">「MDN—class」</a>",
      "date": 1635830204000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript class和function的区别",
      "titleEng": "class-function"
    },
    {
      "_id": "fa24ce1a617f913e03848cce07e919cc",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "在 ES6 中，添加了`Object.is()`、`Object.assign()`、`Object.keys()`、`Object.values()`、`Object.entries()`等方法。\n\n## 1. Object.is()\n\n`Object.is()`方法用来判断两个值是否为**同一个值**。\n\n使用语法如下，其中，`value1`和`value2`是比较的两个值。\n\n```javascript\nObject.is(value1, value2);\n```\n\n`Object.is()`方法返回一个**布尔类型的值**，若满足以下条件则两个值相等：\n\n- 都是`undefined`\n- 都是`null`\n- 都是`true`或都是`false`\n- 都是字符串，且相同长度、相同字符、相同顺序\n- 是相同对象（每个对象有同一个引用）\n- 都是数字，且满足以下任意一个\n  - 都是`0`\n  - 都是`+0`\n  - 都是`-0`\n  - 都是`NaN`\n  - 都非零，且非`NaN`，且是同一个值\n\n例如，如下代码，先定义了两个空对象`obj1`和`obj2`，虽然他们都是空对象，但对象是引用数据类型，存储的是对象的地址，所以它们是**不相等**的。\n\n```javascript\nconst obj1 = {};\nconst obj2 = {};\nconsole.log(Object.is(obj1, obj2)); // false\n```\n\n但如果将**同一个对象**赋值给两个变量，那么两个变量中存储的都是**同一个地址**，所以他们是**相等**的。\n\n```javascript\nconst obj1 = {};\nconst value1 = obj1;\nconst value2 = obj1;\nconsole.log(Object.is(value1, value2)); // true\n```\n\n`Object.is()`方法与`===`不同的地方在于，`===`运算符将`+0`和`-0`视为相等，而将`NaN`与`NaN`视为不相等。\n\n```javascript\nconsole.log(+0 === -0); // true\nconsole.log(NaN === NaN); // false\n```\n\n同样的两个值，在`Object.is()`方法中的结果：\n\n```javascript\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(NaN, NaN)); // true\n```\n\n## 2. Object.assign()\n\n`Object.assign()`方法用于将所有可枚举属性的值从**一个**或**多个源对象**分配到**目标对象**，并**返回目标对象**。\n\n使用语法如下，`target`是目标对象，`sources`是源对象：\n\n```javascript\nObject.assign(target, ...sources)\n```\n\n如下代码，将源对象`obj2`合并到目标对象`obj1`上，打印结果显示完成了合并。\n\n同时，通过判断`res === obj1`为`true`，也说明了`Object.assign()`改变了第一个参数的对象，即**目标对象**，也说明返回值是合并后的**目标对象**。\n\n```javascript\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\n\nconst res = Object.assign(obj1, obj2);\nconsole.log(res); // { a: 1, b: 2 }\nconsole.log(res === obj1); // true\n```\n\n如下代码，如果目标对象和源对象中有相同的属性，那么**源对象**的属性将覆盖**目标对象**的属性：\n\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { a: 2 };\n\nconst res = Object.assign(obj1, obj2);\nconsole.log(res); // { a: 2, b: 2 }\n```\n\n## 3. Object.keys()\n\n`Object.keys()`方法会返回一个由一个给定对象的**自身可枚举属性**组成的**数组**，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。\n\n语法如下，`obj`是待枚举的对象：\n\n```javascript\nObject.keys(obj)\n```\n\n如下代码，遍历对象`obj`的属性，并返回一个数组：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3, d: 4 };\n\nconst res = Object.keys(obj);\nconsole.log(res); // [ 'a', 'b', 'c', 'd' ]\n```\n\n注意，`Object.keys()`只能遍历到**可枚举属性**，有如下代码，通过`Object.defineProperty`给对象`obj`添加了一个属性`e`，但没有添加配置项`enumerable`为`true`，那么这个新添加的属性`e`就是不可枚举的，使用`Object.keys()`方法是遍历不到`e`的：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3, d: 4 };\n\nObject.defineProperty(obj, 'e', {\n    value: 5,\n});\n\nconst res = Object.keys(obj);\nconsole.log(res); // [ 'a', 'b', 'c', 'd' ]\n```\n\n有关`Object.defineProperty`的更多说明，请看<a href=\"https://www.wwflash.top/post?title=fa24ce1a617936ec02ac2a346144aa9f&page=4\" target=\"_blank\">「JavaScript中的Object.defineProperty()方法」</a>。\n\n## 4. Object.values()\n\n`Object.values()`方法返回一个给定对象自身的所有**可枚举属性值**的数组，排列顺序和正常循环遍历该对象时返回的顺序一致 。\n\n语法如下，`obj`是待枚举的对象：\n\n```javascript\nObject.values(obj)\n```\n\n如下代码所示，`Object.values()`也只能遍历**可枚举属性的值**：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3, d: 4 };\n\nObject.defineProperty(obj, 'e', {\n    value: 5,\n});\n\nconst res = Object.values(obj);\nconsole.log(res); // [ 1, 2, 3, 4 ]\n```\n\n## 5. Object.entries()\n\n`Object.entries()`方法相当于`Object.keys()`和`Object.values()`的结合，它返回一个给定对象自身**可枚举属性**的**键值对**数组。\n\n语法如下，`obj`是待枚举的对象：\n\n```javascript\nObject.entries(obj)\n```\n\n如下代码所示，`Object.entries()`也只能遍历**可枚举属性的键值对**：\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3, d: 4 };\n\nObject.defineProperty(obj, 'e', {\n    value: 5,\n});\n\nconst res = Object.entries(obj);\nconsole.log(res); // [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ], [ 'd', 4 ] ]\n```\n\n\n\n***\n\n> 参考：\n>\n> <a href=\"https://developer.mozilla.org/zh-CN/\" target=\"_blank\">「MDN」</a>",
      "date": 1635750136000,
      "post": true,
      "tags": ["JavaScript", "ES6"],
      "title": "JavaScript ES6中Object的新增方法",
      "titleEng": "es6-object"
    },
    {
      "_id": "9e7190f1617d2ceb02d5b04c352952e3",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上的每日一题：<a href=\"https://leetcode-cn.com/problems/single-number-iii/\" target=\"_blank\">「260. 只出现一次的数字 III」</a>\n\n## 1. 题目描述\n\n给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。\n\n你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n\n**示例1 ：**\n\n```\n输入：nums = [1,2,1,3,2,5]\n输出：[3,5]\n解释：[5, 3] 也是有效的答案。\n```\n\n**示例2 ：**\n\n```\n输入：nums = [-1,0]\n输出：[-1,0]\n```\n\n**示例3 ：**\n\n```\n输入：nums = [0,1]\n输出：[1,0]\n```\n\n\n\n## 2. 解答\n\n这道题和[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)解法类似。\n\n异或运算：\n1. `0`和**任何数**异或=**任何数本身**\n2. **任何数**和**自身**异或=`0`\n3. 异或满足**交换律**、**结合律**\n\n知道了以上三条，就可以解题了。\n\n总体思路，将`nums`的数按照一定规则分成两组，相同的数必然会被分到一组，关键是**两个不同的数一定要分在不同组**。再每组进行异或，得到的结果就是原数组中两个不同的数，具体如下：\n\n- 首先从0开始，与数组中所有的数进行异或，得到结果`temp`\n- `temp`等价为数组中两个不同的数**异或的结果**\n- 寻找`temp`中，为`1`的最低的位`k`。例如`[1,2,1,3,2,5]`，得到`temp=6`，也就是`110`，`110`的为`1`的最低的位是第1位，则`k=10`\n- `temp`为`110`，是`011`和`101`异或的结果，为`1`的最低位代表两个不同的数，在这一位上不同。那么让两个不同的数，和`k`进行**与**操作，就能分开了\n- 分组，`011&10`，`101&10`，可以将两个不同的数分在两组，其余相同的数肯定会被分在同一组\n- 每组分别进行异或运算，得到两个答案\n\n```JavaScript\nconst singleNumber = nums => {\n    let temp = 0;\n    const len = nums.length;\n    for (let i = 0; i < len; i++) {\n        temp = temp ^ nums[i];\n    }\n    // 此时temp是两个不同的数异或的结果\n    // 寻找k，k是temp最低位为1、其余位是0的二进制数\n    let k = 1;\n    while ((temp & k) === 0) k = k << 1;\n\n    let [num1, num2] = [0, 0];\n    for (let i = 0; i < len; i++) {\n        // 分组，目的是将两个不同的数分开\n        if (nums[i] & k) {\n            num1 = num1 ^ nums[i];\n        } else {\n            num2 = num2 ^ nums[i];\n        }\n    }\n    return [num1, num2];\n};\n```\n\n\n",
      "date": 1635593375000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "「每日一题」只出现一次的数字 III",
      "titleEng": "lc-260-III"
    }
  ],
  "requestId": "0b8accdce9d0d"
}
