{
  "data": [
    {
      "_id": "859059a5617d222a02d9932e023f4d47",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "## 1. 箭头函数的使用\n\nES6 中新增了使用箭头`=>`来定义函数表达式的方法。**很多情况下**，箭头函数和函数表达式创建的函数并无区别，只有写法上的不同。\n\n本文第二块内容将介绍箭头函数和普通函数功能上的区别。\n\n### 1. 普通函数到箭头函数\n\n如下所示，定义一个函数，可以使用`function`关键字，函数接收两个参数`a`和`b`，返回`a`和`b`的和。\n\n```javascript\nfunction getSum(a, b) {\n    return a + b;\n}\n```\n\n若使用箭头函数来定义这个函数，可以写成如下形式，省略`function`关键字，用箭头`=>`定义一个函数。\n\n```javascript\nconst getSum = (a, b) => {\n    return a + b;\n};\n```\n\n### 2. 省略大括号和 return\n\n若定义的箭头函数，函数体内只有`return`语句，则可以省略大括号`{}`和`return`。\n\n如下所示，定义的箭头函数，完整写法。\n\n```javascript\nconst getSum = (a, b) => {\n    return a + b;\n};\n```\n\n此箭头函数的函数体内只有`return`语句，那么，省略了大括号`{}`和`return`后的精简写法如下：\n\n```javascript\nconst getSum = (a, b) => a + b;\n```\n\n### 3. 省略小括号\n\n若定义的箭头函数，参数只有一个，则可以省略小括号。\n\n如下所示，定义的箭头函数，只有一个参数，完整写法。\n\n```javascript\nconst func = (a) => {\n    return a + 2;\n};\n```\n\n省略了参数旁边的小括号，以下代码等价于上面的代码。\n\n```javascript\nconst func = a => a + 2;\n```\n\n**注意**：若函数没有参数，或者多个参数的情况下，必须要使用括号。\n\n## 2. 箭头函数与普通函数的区别\n\n大多数情况下，能使用普通函数的地方都可以用箭头函数代替，因为箭头函数更精简。\n\n但在部分情况下，箭头函数与普通函数有着很大的却别。\n\n### 1. 箭头函数的 this 是父级作用域的 this\n\n如下代码，定义了一个对象`obj`，对象中有个普通函数定义的方法`getThis`，打印出此处的`this`。调用`obj.getThis()`，会打印出`obj`对象。这说明方法内部的`this`指向对象`obj`。\n\n```javascript\nconst obj = {\n    name: 'Jack',\n    getThis() {\n        console.log(this);\n    },\n};\nobj.getThis(); // {name: 'Jack', getThis: ƒ}\n```\n\n同样定义一个对象`obj`，但里面的方法用箭头函数定义，浏览器中调用`obj.getThis()`却打印出`Window`，这说明即使调用`obj`对象身上的方法，方法内部的`this`也不会指向`obj`，而是指向定义`obj`的上下文的`this`。\n\n```javascript\nconst obj = {\n    name: 'Jack',\n    getThis: () => {\n        console.log(this);\n    },\n};\nobj.getThis(); // Window\n```\n\n### 2. call、apply、bind无法改变箭头函数的 this\n\n如下代码，普通函数`getName`打印`this.name`，通过`call`将函数中的`this`绑定到`obj`身上，调用`getName`打印出`obj`身上的属性`name`。\n\n```javascript\nconst obj = {\n    name: 'Jack',\n};\n\nfunction getName() {\n    console.log(this.name);\n}\ngetName.call(obj); // Jack\n```\n\n若将函数改成箭头函数，那么`call`将不起作用，无法将函数内部的`this`绑定到`obj`，打印出`undefined`。\n\n```javascript\nconst obj = {\n    name: 'Jack',\n};\n\nconst getName = () => {\n    console.log(this.name);\n};\ngetName.call(obj); // undefined\n```\n\n### 3. 不可以作为构造函数\n\n箭头函数不可以作为构造函数使用，若将箭头函数作为构造函数，将报错，如下代码所示。\n\n```javascript\nconst Person = () => {\n    this.name = 'Jack';\n};\nconst usr = new Person(); // Person is not a constructor\n```\n\n### 4. 不可以使用 arguments\n\n在普通函数内部，可以使用`arguments`来获取传入的参数，是一个类数组对象：\n\n```javascript\nfunction func() {\n    console.log(arguments);\n}\nfunc(1, 2, 3); // [Arguments] { '0': 1, '1': 2, '2': 3 }\n```\n\n而箭头函数就不可以使用`arguments`对象，获取不到输入的参数。\n\n在浏览器中，若在箭头函数使用`arguments`对象，将报错。\n\n```javascript\nconst func = () => {\n    // 浏览器环境\n    console.log(arguments); // arguments is not defined\n};\nfunc(1, 2, 3);\n```\n\n但是箭头函数可以在参数内，以`...args`的方式，获取到输入的参数，得到的`args`是一个数组。\n\n```javascript\nconst func = (...args) => {\n    console.log(args); // [ 1, 2, 3 ]\n};\nfunc(1, 2, 3);\n```\n\n### 5. 箭头函数不支持 new.target\n\n普通函数定义的构造函数内部，支持使用`new.target`，返回构造实例的构造函数。\n\n```javascript\nfunction Person() {\n    this.name = 'Jack';\n    console.log(new.target);\n}\n// 指向构造函数\nnew Person(); // [Function: Person]\n```\n\n而在箭头函数中，不支持使用`new.target`。在浏览器环境中，箭头函数使用`new.target`将报错：`new.target expression is not allowed here`。\n\n```javascript\nconst Person=() =>{\n    this.name = 'Jack';\n    console.log(new.target);\n}\n// 浏览器环境\nnew Person(); // new.target expression is not allowed here\n```\n\n\n\n***\n\n> 本文参考：\n>\n> 《JavaScript高级程序设计（第4版）》",
      "date": 1635590660000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 箭头函数的特点、与普通函数的区别",
      "titleEng": "arrow-func"
    },
    {
      "_id": "859059a5617bb04f02b11c6a4c3f5472",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "JavaScript 中的变量是松散类型的，可以保存任何类型数据，变量只不过是一个名称。JavaScript 中，可以声明变量的关键字有`var`、`let`和`const`。\n\n## 1. var\n\n使用`var`定义变量，可以保存任何类型的值。若不初始化变量，变量会保存`undefined`。\n\n### 1. 函数级作用域\n\n使用`var`定义的变量会成为包含它的**函数**的局部变量。\n\n```javascript\nfunction func() {\n    var a = 'hi'; // 局部变量\n}\nfunc();\nconsole.log(a); // ReferenceError: a is not defined\n```\n\n变量`a`在函数内部使用`var`定义，调用函数`func`，会创建这个变量并给它赋值。函数执行结束后，变量就会被销毁，所以上述代码最后一行会报错，显示变量`a`未定义。\n\n若在函数内部，不使用`var`操作符，直接给变量`a`赋值，那么`a`就成为了全局变量，可以在函数外部访问到。在浏览器环境下，`a`成为`window`对象的属性。\n\n```javascript\nfunction func() {\n    a = 'hi'; // 全局\n}\nfunc();\nconsole.log(a); // hi\nconsole.log(window.a); // hi\nconsole.log(window.a === a); // true\n```\n\n### 2. 变量提升\n\n使用`var`声明变量，会自动提升到函数作用域顶部，如下代码：\n\n```javascript\nfunction func() {\n    console.log(a);\n    var a = 1;\n}\nfunc(); // undefined\n```\n\n代码没有报错，输出了`undefined`，这是因为**变量的声明**被提升到了函数作用域顶部，等价于如下代码：\n\n```javascript\nfunction func() {\n    var a;\n    console.log(a);\n    a = 1;\n}\nfunc(); // undefined\n```\n\n### 3. 重复声明\n\n另外，使用`var`重复声明同一个变量也可以：\n\n```javascript\nfunction func() {\n    var a = 1;\n    var a = 2;\n    var a = 3;\n    console.log(a);\n}\nfunc(); // 3\n```\n\n### 4. 全局变量挂载到 window\n\n浏览器环境中，全局作用域下，使用`var`声明的变量，会挂载到`window`对象上。\n\n```javascript\nvar a = 1;\nconsole.log(window.a === a); // true\n```\n\n## 2. let\n\n`let`也可以声明变量，但和`var`操作符有很大的区别。\n\n### 1. 块级作用域\n\n以下代码会报错，因为`let`声明的作用域，具有**块级作用域**，即被`{}`包裹的部分。\n\n```javascript\nif (true) {\n    let a = 10;\n}\nconsole.log(a); // a is not defined\n```\n\n### 2. 不可重复声明\n\n以下代码，执行到`let a = 2`就会报错，因为变量`a`在当前块级作用域中已经被声明过了，不能重复声明。\n\n```javascript\nif (true) {\n    let a = 1;\n    let a = 2; // SyntaxError: Identifier 'a' has already been declared\n    let a = 3;\n}\n```\n\n另外，如果混用`var`和`let`声明变量，也是不允许的，下面的代码都会报错：\n\n```javascript\nlet a;\nvar a; // 报错\n```\n\n```javascript\nvar a;\nlet a; // 报错\n```\n\n### 2. 不存在变量提升（暂时性锁区）\n\n使用`let`声明的变量，不能在声明之前访问它。\n\n```javascript\nif (true) {\n    console.log(a); // ReferenceError: Cannot access 'a' before initialization\n    let a = 1;\n}\n```\n\n实际上，JavaScript 也会注意出现在块后面的`let`声明，只不过在此之前**不能以任何方式来引用未声明的变量**。在`let`声明之前的执行瞬间被称为**暂时性死区**。\n\n### 3. 全局变量不会挂载到 window\n\n和`var`不同，即使在全局作用域下，使用`let`声明的变量也不会挂载到`window`对象。\n\n```javascript\nvar a = 1;\nlet b = 2;\nconsole.log(window.a === a); // true\nconsole.log(window.b === b); // false\n```\n\n### 4. 不依赖条件声明\n\n```javascript\nif (typeof name === 'undefined') {\n    let name;\n}\n// name 被限制在 if {} 块的作用域内\nname = 'Matt'; // 全局赋值\n\ntry {\n    console.log(age); // 如果 age 没有声明过，则会报错\n} catch (error) {\n    let age;\n}\n// age 被限制在 catch {}块的作用域内\nage = 26; // 全局赋值\n```\n\n## 3. const\n\n`const`的特点与`let`基本一致，但`const`有一些自己的特点。\n\n### 1. 声明变量时必须同时初始化\n\n以下声明报错，因为声明的同时没有初始化变量。\n\n```javascript\nconst a; // Missing initializer in const declaration\n```\n\n### 2. 不能修改声明后的变量\n\n使用`const`定义了一个变量后，不能再更改它的值：\n\n```javascript\nconst a = 1;\na = 2; // TypeError: Assignment to constant variable\n```\n\n这里有一个误区，实际上，使用`const`声明的变量，不能修改的是**内存地址**！！\n\n具体规则如下：\n\n-   当`const`定义的常量为**基本数据类型**时，**不能被修改**。\n-   当`const`定义的常量为**引用数据类型**时，可以通过其属性进行**数据修改**。\n\n**基本数据类型**的值就保存在**内存地址**中，所以`const`定义的**基础数据类型**不可被改变。 而**引用数据类型**指向的**内存地址**只是一个**指针**，通过指针来指向实际数据，也就是说，**不可被改变的是指针**，**而不是数据**，所以`const`定义的**引用数据类型**的常量可以通过属性来修改其数据。\n\n例如，使用`const`定义了一个数组，虽然不能更改**数据类型**，但可以通过`push`等方法，修改这个数组中的数据。\n\n```javascript\nconst arr = [];\narr.push(1, 2, 3);\nconsole.log(arr); // [ 1, 2, 3 ]\n```\n\n## 4. 总结及最佳实践\n\n|         `var`          |             `let`              |            `const`             |\n| :--------------------: | :----------------------------: | :----------------------------: |\n|      函数级作用域      |         **块级**作用域         |         **块级**作用域         |\n|        重复声明        |        **不可**重复声明        |        **不可**重复声明        |\n|        变量提升        |       **不存在**变量提升       |       **不存在**变量提升       |\n|        值可更改        |            值可更改            |         值**不可**更改         |\n| 全局变量挂载到`window` | 全局变量**不会**挂载到`window` | 全局变量**不会**挂载到`window` |\n\n通常，写 JavaScript 代码时，遵循以下原则：\n\n1. 不使用`var`\n2. `const`优先，`let`次之\n\n## 5. 一道面试题\n\n以下代码运行后会打印什么？\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n    setTimeout(function () {\n        console.log(i);\n    }, 0);\n}\n```\n\n> **答案**：6 6 6 6 6\n\n虽然每个`for`循环中定时器设置的时间都是`0`，但由于 JavaScript 是单线程 `eventLoop`机制，`setTimeout`是异步任务，遇到`setTimeout`函数时，JavaScript 会将其放入**任务队列**中，待同步任务执行完毕后，才执行**任务队列**中的**异步任务**。\n\n又因为`setTimeout`函数也是一种**闭包**，往上找它的**父级作用域链**是`window`，而变量`i`是用`var`声明的，是`window`上的**全局变量**，所以此时变量`i`的值已经变成`i = 6`了，最后执行`setTimeout`时，当然会输出 5 个`6`了！\n\n**使用`let`解决**：\n\n利用 JavaScript 的**块级作用域**，就不用这么麻烦了。如果`for`循环使用**块级作用域**变量关键字，循环就会为每个循环创建**独立的变量**，从而每次打印都会有正确的索引值。\n\n```javascript\nfor (let i = 1; i <= 5; i++) {\n    setTimeout(function () {\n        console.log(i);\n    }, 0);\n}\n```\n\n> 只介绍了其中一个解决方法，详细分析及其他解决方法见<a href=\"https://lzxjack.top/post?title=loop-output\" target=\"_blank\">JavaScript经典题 —— 解决循环打印问题</a>。\n\n\n\n***\n\n> 参考资料：\n>\n> 《JavaScript高级程序设计（第4版）》",
      "date": 1635495914000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 变量声明var、let、const详解",
      "titleEng": "var-let-const"
    },
    {
      "_id": "fa24ce1a617936ec02ac2a346144aa9f",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "前端基础",
      "content": "## 1. 功能\n\n`Object.defineProperty()`方法会直接在一个**对象**上定义一个**新属性**，或者**修改**一个对象的现有属性，并**返回**此对象。\n\n## 2. 语法\n\n```javascript\nObject.defineProperty(obj, prop, descriptor)\n```\n\n### 1. 参数\n\n- `obj`：要定义属性的对象。\n- `prop`：要定义或修改的属性的**名称**或`Symbol`。\n- `descriptor`：配置项，需传一个对象，该对象有如下属性：\n  - `value`：该属性对应的值，可以是任何有效值（数值，对象，函数等），默认是`undefined`\n  - `writable`：控制属性是否可以被**修改**，默认值是`false`\n  - `configurable`：控制属性是否可以被**删除**，默认值是`false`\n  - `enumerable`：控制属性是否可以**枚举**，默认值是`false`\n  - `get`：当读取属性`prop`时，`getter`就会被调用，且返回值就是属性`prop`的值。若没有`getter`，默认是`undefined`\n  - `set`：当修改属性`prop`时，`setter`就会被调用，且函数参数是修改的**具体值**。若没有`setter`，默认是`undefined`\n\n### 2. 返回值\n\n该方法返回被传递给函数的**对象**。\n\n## 3. 应用举例\n\n在浏览器环境中，如何使下面的`if`语句成立？\n\n```javascript\nif (a === 1 && a === 2 && a === 3) {\n    console.log(true);\n}\n```\n\n第一次看到这题，感觉不可能实现，一个变量怎么可能即等于`1`，又等于`2`，也等于`3`呢？\n\n稍作分析可以看到，`if`中的判断语句，实际上读取了3次变量`a`的值，所以可以使用`Object.defineProperty()`方法来解决这个问题。\n\n在浏览器环境中，将变量`a`定义在`window`上，每次读取变量`a`，都会调用一次`getter`函数，通过`getter`函数来改变`a`的值。\n\n具体见如下代码：\n\n```javascript\nlet number = 0;\nObject.defineProperty(window, 'a', {\n    get() {\n        number++;\n        return number;\n    },\n});\n\nif (a === 1 && a === 2 && a === 3) {\n    console.log(true);\n}\n```\n\n将变量`a`定义在`window`上，定义一个变量`number`，`setter`函数中，将`number`自增，并返回`number`。这样每次读取变量`a`时，自动调用`setter`函数，`a`的值也会自动发生变化。浏览器控制台会输出`true`。\n\n***\n\n> 参考：\n>\n> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\">Object.defineProperty() —— MDN</a>",
      "date": 1635333809000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript中的Object.defineProperty()方法",
      "titleEng": "define-property"
    },
    {
      "_id": "18ed09686177acf701f2dae709c63964",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 常见问题",
      "content": "在处理数据时，经常会遇到需要将**多维数组**转化成**一维数组**的场景，也就是**数组扁平化**，这里我总结了三种方式来实现数组扁平化。\n\n## 1. reduce + 递归\n\n使用`reduce`处理数组，`reduce`的第一个参数是一个函数，第二个参数是可选的，是传递给函数的初始值。如果没有提供初始值，则将使用数组中的**第一个元素**。\n\n这里传入一个空数组`[]`作为初始值，接着判断`cur`是否是数组，若为数组，则递归调用；若不是数组，就将`cur`拼接到`pre`。\n\n```javascript\nconst arr = [1, 2, [3, [4, [5, 6], 7], 8], 9, [10]];\n\nconst flatten = arr => {\n    return arr.reduce((pre, cur) => {\n        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);\n    }, []);\n};\n\nconst res = flatten(arr);\nconsole.log(res); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n## 2. 直接用flat()\n\n`flat()`方法会按照一个**可指定的深度**递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n\n参数为指定要提取嵌套数组的结构深度，**可选**，默认为`1`。\n\n```javascript\nconst flatten = arr => arr.flat(Infinity);\n```\n\n## 3. while循环\n\n利用**展开运算符**，可以将二维数组转化为一维数组：\n\n```javascript\n[].concat(...[1, 2, [3, 4]]); // [1, 2, 3, 4]\n```\n\n再利用`while`循环，若`arr`出现数组，则使用一次**展开运算符**，直到没有为止。\n\n```javascript\nconst flatten = arr => {\n    while (arr.some(item => Array.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n    return arr;\n};\n```\n\n",
      "date": 1635232934000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 实现数组扁平化的常见方法",
      "titleEng": "arr-flat"
    },
    {
      "_id": "14139e12611f6f2206179ca371785688",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "> 以下为本人学习所记，若有不对，望指出。\n\n## 1. 变量的作用域\n\n根据作用域的不同，JavaScript 中的变量可分为两种：**全局变量**和**局部变量**。\n\n其中，**函数内部**可以直接读取**全局变量**：\n\n```javascript\nvar a = 1;\nfunction fn1() {\n    console.log(a);\n}\nfn1(); // 1\n```\n\n但是，**函数外部**不能读取函数内的**局部变量**：\n\n```javascript\nfunction fn2() {\n    var b = 2;\n}\nconsole.log(b); // ReferenceError: b is not defined\n```\n\n> 定义局部变量时要注意，要使用关键字`var`、`const`或`let`声明，若像下面这样声明，相当于`window.b = 2`，声明了一个全局变量！\n\n```javascript\nfunction fn2() {\n    b = 2; // 不要这样声明，这样相当于声明了全局变量\n}\nfn2();\nconsole.log(b); // 2\n```\n\n## 2. 什么是闭包\n\n> 以下摘自MDN：\n>\n> 一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n我们看下面这个例子，在函数内部，再定义一个函数，并将其作为返回值，返回一个函数：\n\n```javascript\nfunction fn1() {\n    let a = 1;\n    return function fn2() {\n        console.log(a);\n    };\n}\n// 因为fn1函数有返回值，用result接收\nconst result = fn1();\nresult(); // 1\n```\n\nJavaScript中的函数会形成闭包。 **闭包**是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时**作用域内**的**任何局部变量**。在本例中，`result`是执行`fn1`时创建的`fn2`函数实例的引用。`fn2`的实例维持了一个对它的词法环境（变量`a`存在于其中）的引用。因此，当`result`被调用时，变量`a`仍然可用，其值就被传递到`console.log`中。\n\n下面看一个`makeAdder`函数：\n\n```javascript\nfunction makeAdder(x) {\n    return function (y) {\n        return x + y;\n    };\n}\n\nconst add5 = makeAdder(5);\nconst add10 = makeAdder(10);\n\nconsole.log(add5(2)); // 7\nconsole.log(add10(2)); // 12\n```\n\n`add5`和`add10`都是闭包。它们共享相同的函数定义，但是**保存了不同的词法环境**。在`add5`的环境中，`x`为 5。而在`add10`中，`x`则为 10。\n\n## 3. 闭包的作用\n\n### 1. 在函数外部访问到函数内部变量\n\n从上述例可看出，**闭包可以在函数外部访问到函数内部的变量**，这是其第一个作用。\n\n### 2. 使变量留存在内存中\n\n闭包另一个作用，**使已经运行结束的函数上下文中的变量对象继续留在内存中**。看下面一段 demo：\n\n```javascript\nfunction fn1() {\n    var a = 1;\n    return function fn2() {\n        console.log(a++);\n    };\n}\nvar result = fn1();\nresult(); // 1\nresult(); // 2\nresult(); // 3\n```\n\n`a`是函数`fn1`中的局部变量，`a`的值在函数`fn2`中改变，`fn2`每执行一次，`a`就`+1`。\n\n而上述代码执行 3 次`result()`后，分别输出了`a`的值，`a`不断地`+1`。这说明函数`fn1`中的变量`a`一直保存在**内存**中，并没有在函数`fn1`调用后被清除。\n\n因为函数`fn2`被赋给了一个**全局变量**，因此`fn2`会一直在**内存**中，而`fn2`的存在依赖于`fn1`，所以`fn1`也一直保存在**内存**中，并不会调用后被<a href=\"https://lzxjack.top/post?title=garbage-collection\" target=\"_blank\">**垃圾回收机制**</a>清除。\n\n### 3. 模拟私有方法\n\nJavaScript不支持将方法声明为私有，但可以用闭包来模拟私有方法。下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问**私有函数**和**变量**。\n\n```javascript\nconst counter = function () {\n    let privateCounter = 0;\n\n    return {\n        add() {\n            privateCounter++;\n        },\n        min() {\n            privateCounter--;\n        },\n        value() {\n            return privateCounter;\n        },\n    };\n};\n\nconst counter1 = counter();\nconst counter2 = counter();\n\ncounter1.add();\ncounter1.add();\ncounter1.add();\n\ncounter2.min();\n\nconsole.log(counter1.value()); // 3\nconsole.log(counter2.value()); // -1\n```\n\n两个计数器`counter1`和`counter1`都保持各自的**独立性**。每个闭包都是引用自己作用域内的变量`privateCounter`，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。另外，在一个闭包内对变量的修改，**不会**影响到另外一个闭包中的变量。\n\n## 4. 闭包的副作用\n\n### 1. 常驻内存\n\n闭包会使得函数中的变量都被保存在**内存**中，内存消耗很大，不能滥用闭包，否则会造成严重的性能问题，在**IE浏览器**中可能由于**循环引用**而导致**内存泄露**。\n\n解决方法：在退出函数之前，将不使用的**局部变量**全部清除。\n\n### 2. 误改函数内部的值\n\n不要随便改变父函数**内部变量**的值。\n\n\n\n---\n\n> **参考文章**：\n>\n> - <a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\">学习 Javascript 闭包（Closure）</a>\n> - <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\" target=\"_blank\">闭包——MDN</a>\n",
      "date": 1634782351000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "理解 JavaScript 闭包，从这里开始",
      "titleEng": "closure"
    },
    {
      "_id": "9e7190f161693376002a46615b8daace",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "## 1. px\n\n`px`是像素单位。它是代表显示器上每一个显示的像素点，根据用户屏幕显示器的分辨率决定。\n\n## 2. em\n\n`em`为相对单位，相对于当前元素内文本的字体尺寸。如果当前元素没有指定字体尺寸，那么以浏览器默认的字体尺寸为准。\n\n例如，当前元素设置了字体尺寸为`24px`，那么`2em`就代表`48px`。\n\n## 3. rem\n\n`rem`为相对单位，相对于`<HTML>`元素文本的字体尺寸。如果`<HTML>`元素没有指定字体尺寸，那么以浏览器默认的字体尺寸为准。\n\n例如，`<HTML>`元素设置了字体尺寸为`24px`，那么`2rem`就代表`48px`。\n\n## 4. vw和vh\n\n`vw`和`vh`是相对单位，相对于**当前视口**。\n\n例如，`10vw`代表当前视口**宽度**的`10%`，`20vh`代表当前视口**高度**的`20%`。\n\n## 5. 百分号\n\n`%`是相对单位，相对于**父元素**的相关尺寸。\n\n例如，父元素设置了`height: 100px`，那么它的子元素`height: 50%`就代表`50px`。",
      "date": 1634284391000,
      "post": true,
      "tags": ["CSS"],
      "title": "CSS尺寸单位px、em、rem、vw、vh以及%的区别",
      "titleEng": "css-size"
    },
    {
      "_id": "cd045e75615fb32f13c85eb1249220fe",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上10-8 的每日一题：<a href=\"https://leetcode-cn.com/problems/repeated-dna-sequences/\" target=\"_blank\">「187. 重复的DNA序列」</a>\n\n## 1. 题目描述\n\n所有 DNA 都由一系列缩写为 `'A'`，`'C'`，`'G'` 和 `'T'` 的核苷酸组成，例如：`\"ACGAATTCCG\"`。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。\n\n编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 `s` 中出现次数超过一次。\n\n\n\n**示例1 ：**\n\n```\n输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n```\n\n**示例2 ：**\n\n```\n输入：s = \"AAAAAAAAAAAAA\"\n输出：[\"AAAAAAAAAA\"]\n```\n\n\n\n## 2. 解答\n\n\n### 1. Set+滑动窗口\n\n维护长度为10的滑动窗口，并将窗口中的子串加入`Set`。加入`Set`之前判断`Set`中是否已存在，若存在，放入`res`。最后返回`res`去重后的结果。\n\n```JavaScript\nconst findRepeatedDnaSequences = s => {\n    const len = s.length;\n    const res = [];\n    // 长度小于等于10，直接返回空数组\n    if (len <= 10) return res;\n    const set = new Set();\n    let i = 0;\n    while (i + 9 < len) {\n        // 维护长度为10的滑动窗口\n        const str = s.slice(i, i + 10);\n        // 当前窗口如果set中已经存在，放入res\n        if (set.has(str)) res.push(str);\n        // 当前窗口加入set\n        set.add(str);\n        i++;\n    }\n    // 数组去重\n    return [...new Set(res)];\n};\n```\n\n### 2. Map+滑动窗口\n\n维护长度为10的滑动窗口，并将窗口中的子串加入`Map`并计数。滑动完成后，遍历`Map`，将次数大于1的加入到`res`。\n\n```JavaScript\nconst findRepeatedDnaSequences = s => {\n    const len = s.length;\n    const res = [];\n    // 长度小于等于10，直接返回空数组\n    if (len <= 10) return res;\n    const map = new Map();\n    let i = 0;\n    while (i + 9 < len) {\n        // 维护长度为10的滑动窗口\n        const str = s.slice(i, i + 10);\n        // 放入map计数\n        map.set(str, (map.get(str) || 0) + 1);\n        i++;\n    }\n    for (const item of map) {\n        // 挑选出次数大于1的\n        if (item[1] > 1) res.push(item[0]);\n    }\n    return res;\n};\n```\n\n\n\n***\n\n",
      "date": 1633661709000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」重复的DNA序列",
      "titleEng": "lc-187"
    },
    {
      "_id": "14139e126151bf680fbc2aab6bdfa59b",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "JavaScript 手撕代码",
      "content": "## 1. 回顾构造函数、实例、原型对象的关系\n\n1. **构造函数**的`prototype`属性指向了构造函数的**原型对象**\n2. **实例**对象是由构造函数创建的，实例对象的`__proto__`属性指向了构造函数的**原型对象**\n3. 构造函数的原型对象的`constructor`属性指向了**构造函数**，**实例对象**的**原型**的`constructor`属性（`usr1. __proto__.constructor`）也指向了**构造函数**\n\n现有构造函数`Star`，`Star`的实例对象`usr1`，其三者关系如图所示：\n\n![](https://img.huahuabiz.com/user_files/20241222/1734875093235783.png)\n\n## 2. new操作符做了什么\n\n简单来说，当我们使用`new`操作符为**构造函数**创建**实例**时，发生了下面**4**件事：\n\n1. 创建一个**新对象**\n2. 为**新对象**添加属性`__proto__`，将该属性链接至**构造函数**的**原型对象**\n3. 执行构造函数，`this`被绑定在**新对象**上\n4. 确保返回一个对象\n\n如下所示，通过`new`操作符，为构造函数实例化了一个对象：\n\n```javascript\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nconst usr1 = new Person('Jack', 18);\nconsole.log(usr1);\n// Person { name: 'Jack', age: 18 }\n```\n\n若在构造函数中，返回一个对象，那么通过`new`操作符得到的对象，就是构造函数中返回的对象：\n\n```javascript\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    // 构造函数中返回一个对象\n    return {\n        a: 1,\n    };\n}\n\nconst usr1 = new Person('Jack', 18);\nconsole.log(usr1);\n// { a: 1 }\n```\n\n## 3. 手动实现new\n\n知道了`new`操作符背后做的事情，我们可以自己写一个`myNew`，实现相同的功能。\n\n```javascript\n// 定义构造函数\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\n// 手动实现new:\n// constructor: 构造函数\n// ...args: 构造函数参数\nfunction myNew(constructor, ...args) {\n    // 1. 创建一个新对象\n    const obj = {};\n    // 2. 为新对象添加属性__proto__，将该属性链接至构造函数的原型对象\n    obj.__proto__ = constructor.prototype;\n    // 3. 执行构造函数，this被绑定在新对象上\n    const res = constructor.call(obj, ...args);\n    // 4. 确保返回一个对象\n    return res instanceof Object ? res : obj;\n}\n\nconst usr1 = myNew(Person, 'Jack', 18);\nconst usr2 = new Person('Jack', 18);\n\nconsole.log(usr1);\nconsole.log(usr2);\n```\n\n在浏览器运行环境下，查看输出结果：\n\n![](https://img.huahuabiz.com/user_files/20241222/173487509323674.png)\n\n若构造函数本身返回一个对象，自己实现的`myNew`也可以返回这个对象：\n\n```javascript\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    // 构造函数中返回一个对象\n    return {\n        a: 1,\n    };\n}\n\nfunction myNew(constructor, ...args) {\n    // 1. 创建一个新对象\n    const obj = {};\n    // 2. 为新对象添加属性__proto__，将该属性链接至构造函数的原型对象\n    obj.__proto__ = constructor.prototype;\n    // 3. 执行构造函数，this被绑定在新对象上\n    const res = constructor.call(obj, ...args);\n    // 4. 确保返回一个对象\n    return res instanceof Object ? res : obj;\n}\n\nconst usr2 = myNew(Person, 'Jack', 18);\nconsole.log(usr2);\n// { a: 1 }\n```\n\n\n\n***\n\n",
      "date": 1632747331000,
      "post": true,
      "tags": ["JavaScript", "this"],
      "title": "JavaScript 手动实现new操作符",
      "titleEng": "myNew"
    }
  ],
  "requestId": "8c425fc505701"
}
