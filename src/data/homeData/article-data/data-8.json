{
  "data": [
    {
      "_id": "2d44d6c2612c3f1307cb7d694c4def74",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上的每日一题：<a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\" target=\"_blank\">「528. 按权重随机选择」</a>\n\n## 1. 题目描述\n\n给定一个正整数数组`w`，其中`w[i]`代表下标`i`的权重（下标从`0`开始），请写一个函数`pickIndex`，它可以随机地获取下标`i`，选取下标`i`的概率与`w[i]`成正比。\n\n例如，对于`w = [1, 3]`，挑选下标`0`的概率为`1 / (1 + 3) = 0.25` （即，25%），而选取下标`1`的概率为`3 / (1 + 3) = 0.75`即，75%）。\n\n也就是说，选取下标`i`的概率为`w[i] / sum(w) `。\n\n**示例 1：**\n\n```\n输入：\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n输出：\n[null,0]\n解释：\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。\n```\n\n**示例 2：**\n\n```\n输入：\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n```\n\n## 2. 解答\n\n例如输入数组为`[1,2,3,4]`，则划分：`[1,1], [2,3], [4,5,6], [7,8,9,10]`，求出前缀和数组`[1,3,6,10]`。\n\n生成`[1,10]`之间的一个随机整数，用二分查找在前缀和数组中寻找满足区间条件的最小下标`i`，并返回。\n\n```javascript\nclass Solution {\n    constructor(w) {\n        this.len = w.length;\n        // 定义前缀和数组\n        this.pre = new Array(this.len).fill(0);\n        this.pre[0] = w[0];\n        // 从i=1开始，求每个位置的前缀和\n        for (let i = 1; i < this.len; i++) {\n            this.pre[i] = this.pre[i - 1] + w[i];\n        }\n        console.log(this.pre);\n        // 总和\n        this.total = this.pre[this.len - 1];\n    }\n    pickIndex() {\n        // Math.random()返回 0 ~ 1 之间的一个随机数\n        // x 是 1 ~ total 之间的一个随机整数\n        const x = Math.floor(Math.random() * this.total) + 1;\n        // 二分查找\n        let [low, high] = [0, this.len - 1];\n        while (low <= high) {\n            const mid = (low + high) >> 1;\n            if (this.pre[mid] < x) low = mid + 1;\n            else high = mid - 1;\n        }\n        return low;\n    }\n}\n```\n\n\n\n***\n\n",
      "date": 1630289631000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」按权重随机选择",
      "titleEng": "lc-528"
    },
    {
      "_id": "2d44d6c2612af66507a545db6a5f0f96",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上的每日一题：<a href=\"https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/\" target=\"_blank\">「1588. 所有奇数长度子数组的和」</a>\n\n## 1. 题目描述\n\n给你一个正整数数组`arr`，请你计算所有可能的奇数长度子数组的和。\n\n**子数组**定义为原数组中的一个连续子序列。\n\n请你返回`arr`中**所有奇数长度子数组的和** 。\n\n**示例 1：**\n\n```\n输入：arr = [1,4,2,5,3]\n输出：58\n解释：所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n```\n\n**示例 2：**\n\n```\n输入：arr = [1,2]\n输出：3\n解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。\n```\n\n## 2. 解答\n\n首先根据<a href=\"https://leetcode-cn.com/problems/running-sum-of-1d-array/\" target=\"_blank\">「1480. 一维数组的动态和」</a>**原地修改**计算出数组每个位置的前缀和，再确定左右边界计算所有奇数长度子数组的和。\n\n使用双重`for`循环确定左右边界`i`和`j`，外层`i`每次`+1`，因为子数组长度要奇数，所以内层`j`每次`+2`。\n\n例如，对于用例`arr = [1,4,2,5,3]`，**注意**，此时`arr`已经是输入数组的前缀和：\n\n- `i != 0`时，比如`[i,j]=[1,3]`区间的子数组`[4,2,5]`，和为`arr[3] - arr[1-1]`，即`arr[j] - arr[i-1]`\n- `i == 0`时，比如`[i,j]=[0,2]`区间的子数组`[1,4,2]`，和为`arr[2]`，即`arr[j]`\n- 总结起来就是，对于`[i,j]`的区间子数组，和为`arr[j] - (arr[i - 1] || 0)`\n- 循环中累加所求的区间子数组和即可\n\n![](https://img.lzxjack.top:99/20210829103814.png)\n\n![](https://img.lzxjack.top:99/20210829103831.png)\n\n![](https://img.lzxjack.top:99/20210829103849.png)\n\n```javascript\nconst sumOddLengthSubarrays = arr => {\n    const len = arr.length;\n    // 原地修改，计算前缀和\n    for (let i = 1; i < len; i++) {\n        arr[i] += arr[i - 1];\n    }\n    // 定义返回值，初始为0\n    let res = 0;\n    // 定义左边界\n    for (let i = 0; i < len; i++) {\n        // 定义右边界，因为长度奇数，j每次+2\n        for (let j = i; j < len; j += 2) {\n            // 此时arr已经是前缀和\n            // i!==0, [i,j]区间内的长度和 = arr[j] - arr[i - 1]\n            // i===0, [i,j]区间内的长度和 = arr[j]\n            res += arr[j] - (arr[i - 1] || 0);\n        }\n    }\n    return res;\n};\n```\n\n\n\n***\n\n",
      "date": 1630205423000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」所有奇数长度子数组的和",
      "titleEng": "lc-1588"
    },

    {
      "_id": "cd045e756124e5e60782d9ec3ceaa4c9",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "## 1. 前言\n\n最近在写一个博客系统，在「评论」模块中，有这样一个需求：有**用户 1**已经评论留言，**用户 2**在**用户 1**的评论下，给**用户 1**回复评论。\n\n这时候需要发一封邮件通知**用户 1**的评论收到了回复，所以就想写一个自动发邮件的功能。\n\n在网上找到了<a href=\"https://github.com/nodemailer/nodemailer\" target=\"_blank\">「Nodemailer」</a>这个项目，「Nodemailer」是一个简单易用的`Node.js`邮件发送组件，可以使用**SMTP**协议，用指定的账户发送电子邮件。\n\n但是「Nodemailer」只能运行在`Node.js`环境中，在浏览器中直接使用会报错，使用不了。所以我的想法是，在自己的「阿里云服务器」`Node.js`环境中，使用`express`框架搭建一个简单的路由，「Nodemailer」运行在服务器上。在前端页面利用`Axios`发送 http 请求，服务器收到相应请求后，获取参数，使用「Nodemailer」发送电子邮件。\n\n![](https://img.lzxjack.top:99/20210811095916.png)\n\n同时还要注意**同源政策**的问题。\n\n话不多说，开始实现这样一个功能吧！\n\n## 2. 客户端代码\n\n客户端只需要通过`Axios`发送 http 请求给服务器即可：\n\n```javascript\naxios({\n    url: 'http://XX.XXX.XXX.XXX:4000/email',\n    method: 'get',\n    params: {\n        name,\n        owner,\n        email: replyEmail,\n        search: 'msg',\n    },\n    withCredentials: true,\n})\n    .then(() => message.success('回复成功!'))\n    .catch(err => console.error(err));\n```\n\n这里设置了`withCredentials`为`true`，指定在涉及到**跨域请求**时，携带`cookie`信息。\n\n## 3. 服务端代码\n\n使用模块化路由，所有的**路由请求**都在`app.js`中处理，各个模块处理相应的逻辑。\n\n在`app.js`中，使用`use()`中间件拦截所有请求，为`res`统一设置`header`，解决同源限制问题。\n\n`app.js`：\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst email = require('./email');\n\n// 拦截所有请求\napp.use((req, res, next) => {\n    // 1.允许哪些客户端访问我\n    // * 代表允许所有的客户端访问我\n    // 注意：如果跨域请求中涉及到cookie信息传递，值不可以为*号 比如是具体的域名信息\n    res.header('Access-Control-Allow-Origin', 'http://localhost:3001');\n    // 2.允许客户端使用哪些请求方法访问我\n    res.header('Access-Control-Allow-Methods', 'get,post');\n    // 允许客户端发送跨域请求时携带cookie信息\n    res.header('Access-Control-Allow-Credentials', true);\n    next();\n});\n\n// 博客评论收到回复后的邮件提醒服务\napp.use('/email', email);\n\napp.listen(4000);\nconsole.log('服务器启动成功，监听4000端口...');\n```\n\n发送电子邮件的步骤写在`email.js`中，主要分为三步：\n\n1. 引入`nodemailer`\n2. 创建发件人的信息\n3. 发送电子邮件\n\n这里我使用的是 163 邮箱，需要在 163 邮箱中，开启`smtp`服务，并获取到**授权码**。\n\n`email.js`：\n\n```javascript\nconst express = require('express');\nconst email = express.Router();\n// 1. 引入nodemailer\nconst nodemailer = require('nodemailer');\n\n// 2. 创建发件人的信息\nconst transporter = nodemailer.createTransport({\n    host: 'smtp.163.com',\n    port: 465,\n    secureConnection: true, // use SSL\n    auth: {\n        user: 'lzxjack1998@163.com', // 自己的邮箱地址\n        pass: 'xxxxxxxxxxxxxx', // 不是密码，是授权码\n    },\n});\n\nemail.get('/', (req, res) => {\n    const { name, owner, email: to, search } = req.query;\n    const blogUrl = 'xxxxxxxxxxxxxxxxx';\n    const html = 'xxxxxxxxxxxxxx';\n    const subject = '评论回复提醒';\n    const from = '\"飞鸟\"<lzxjack1998@163.com>';\n    const mailOptions = {\n        from, // 发件人\n        to, // 收件人\n        subject, // 邮件标题\n        html, // 邮件内容，html格式\n    };\n    // 3. 发送电子邮件\n    transporter.sendMail(mailOptions, (error, info) => {\n        if (error) return console.log(error);\n        console.log(info);\n    });\n    res.send('已成功发送邮件！');\n});\n\nmodule.exports = email;\n```\n\n## 4. 发送邮件\n\n将服务端代码放到云服务器上，运行`app.js`：\n\n![](https://img.lzxjack.top:99/20210811101703.png)\n\n尝试回复一个评论，发送`axios`请求，发送电子邮件，服务端打印相关信息：\n\n![](https://img.lzxjack.top:99/20210811101959.png)\n\n成功收到邮件！\n\n![](https://img.lzxjack.top:99/20210811101842.png)\n\n\n",
      "date": 1628675104000,
      "post": true,
      "tags": ["JavaScript", "Node.js", "Linux"],
      "title": "JavaScript 利用Nodemailer发送电子邮件",
      "titleEng": "email"
    },
    {
      "_id": "2d44d6c26124f89106c306fd3b972b7b",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. 原型链继承\n\n```javascript\n// 定义父类\nfunction Parent() {\n    this.name = 'Jack';\n}\n// 父类原型添加方法\nParent.prototype.getName = function () {\n    return this.name;\n};\n\n// 子类\nfunction Child() {}\n// 子类的原型设置为父类Parent的实例\nChild.prototype = new Parent();\n\n// 实例化子类\nconst child = new Child();\n\nconsole.log(child.getName()); // Jack\n```\n\n父类`Parent`有属性和方法，子类`Child`没有属性和方法。实现继承的关键是，子类`Child`没有使用默认原型，而是将其替换成了一个新的对象，这个对象恰好是`Parent`的实例，这样`Child`的实例就能从`Parent`的实例中继承属性和方法，而且还与`Parent`的原型挂上了钩。\n\n`Child`和`Parent`的关系如下如所示：\n\n![](https://img.lzxjack.top:99/20210802133147.png)\n\n**缺陷**：\n\n（1）原型中包含**引用值**的时候，会在所有实例间共享\n\n```javascript\nfunction SuperType() {\n    this.colors = ['red', 'blue', 'green'];\n}\nfunction SubType() {}\n// 继承 SuperType\nSubType.prototype = new SuperType();\n\nconst instance1 = new SubType();\ninstance1.colors.push('black'); // 加入新元素\nconsole.log(instance1.colors); // [ 'red', 'blue', 'green', 'black' ]\n\nconst instance2 = new SubType();\nconsole.log(instance2.colors); // [ 'red', 'blue', 'green', 'black' ]\n```\n\n`SubType`的所有实例都会共享这个`colors`属性。这一点通过`instance1.colors`上的修改也能反映到`instance2.colors`上就可以看出来。\n\n（2）子类型在实例化时**不能**给父类型的构造函数传参\n\n由于以上两个原因，**原型链继承**基本不会单独使用。\n\n## 2. 盗用构造函数\n\n这种技术有时也称作**对象伪装**或**经典继承**。在**子类构造函数**中调用**父类构造函数**。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 `apply()`和`call()`方法以**新创建的对象**为上下文执行构造函数。\n\n```javascript\nfunction SuperType() {\n    this.colors = ['red', 'blue', 'green'];\n}\nfunction SubType() {\n    // 继承 SuperType\n    SuperType.call(this);\n}\nconst instance1 = new SubType();\ninstance1.colors.push('black');\nconsole.log(instance1.colors); // [ 'red', 'blue', 'green', 'black' ]\n\nconst instance2 = new SubType();\nconsole.log(instance2.colors); // [ 'red', 'blue', 'green' ]\n```\n\n通过使用`call()`或`apply()`方法，`SuperType`构造函数在为`SubType`的实例创建的新对象的上下文中执行了。这相当于新的`SubType`对象上运行了 `SuperType()`函数中的**所有初始化代码**。结果就是每个实例都会有自己的`colors`属性。\n\n**优势**：\n\n相比于使用**原型链**，**盗用构造函数**的一个优点就是**可以在子类构造函数中向父类构造函数传参**。\n\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n}\nfunction SubType() {\n    // 继承 SuperType 并传参\n    SuperType.call(this, 'Nicholas');\n    // 实例属性\n    this.age = 29;\n}\nconst usr = new SubType();\nconsole.log(usr.name, usr.age); // Nicholas 29\n```\n\n**缺陷**：\n\n（1）必须在构造函数中定义方法，因此**函数不能重用**，每次创建实例都会创建一次方法。\n\n（2）子类也**不能**访问**父类原型**上定义的方法，因此所有类型只能使用**构造函数模式**。\n\n盗用构造函数基本上也**不能单独使用**。\n\n## 3. 组合继承\n\n**组合继承**，有时候也叫**伪经典继承**，综合了**原型链**和**盗用构造函数**，将两者的优点集中了起来。使用**原型链继承原型上的属性和方法**，而通过**盗用构造函数继承实例属性**。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction SubType(name, age) {\n    // 继承属性\n    SuperType.call(this, name);\n    this.age = age;\n}\n// 继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nconst usr1 = new SubType('Nicholas', 29);\nusr1.colors.push('black');\nconsole.log(usr1.colors); // [ 'red', 'blue', 'green', 'black' ]\nusr1.sayName(); // Nicholas\nusr1.sayAge(); // 29\n\nconst usr2 = new SubType('Greg', 27);\nconsole.log(usr2.colors); // [ 'red', 'blue', 'green' ]\nusr2.sayName(); // Greg\nusr2.sayAge(); // 27\n```\n\n**组合继承**弥补了**原型链**和**盗用构造函数**的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了`instanceof`操作符和`isPrototypeOf()`方法**识别合成对象**的能力。\n\n## 4. 原型式继承\n\n`Object.create()`方法接收两个参数：\n\n1. 作为新对象原型的**对象**\n2. 给新对象定义额外属性的**对象**（可选）\n\n原型式继承适用于这种情况，有一个对象，想在它的基础上**再创建一个新对象**。需要把这个对象先传给`Object.create()`，然后再对返回的对象进行适当修改。本质上，`Object.create()`是对传入的对象执行了一次**浅复制**。\n\n```javascript\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('Rob');\n\nconst anotherPerson2 = Object.create(person);\nanotherPerson2.name = 'Linda';\nanotherPerson2.friends.push('Barbie');\n\nconsole.log(person.friends); // [ 'Shelby', 'Court', 'Van', 'Rob', 'Barbie' ]\n```\n\n`person.friends`不仅是`person`的属性，也会跟`anotherPerson`和`anotherPerson2`共享。这里实际上克隆了两个`person`。\n\n`Object.create()`的第二个参数，每个新增属性都通过各自的**描述符**来描述。以这种方式添加的属性会**遮蔽原型对象上的同名属性**。\n\n```javascript\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = Object.create(person, {\n    name: {\n        value: 'Greg',\n    },\n});\nanotherPerson.name = 'Jack';\n\nconsole.log(anotherPerson.name); // Greg\n```\n\n**原型式继承**非常适合不需要单独创建构造函数，但仍然需要在**对象间共享信息**的场合。但属性中包含的**引用值**始终会在**相关对象间共享**，跟使用**原型模式**是一样的。\n\n## 5. 寄生式继承\n\n与原型式继承比较接近的一种继承方式是**寄生式继承**。\n\n```javascript\nfunction createAnother(original) {\n    const clone = Object.create(original); // 通过调用函数创建一个新对象\n    clone.sayHi = function () {\n        // 以某种方式增强这个对象\n        console.log('hi');\n    };\n    return clone; // 返回这个对象\n}\n\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = createAnother(person);\n\nanotherPerson.sayHi(); // hi\nconsole.log(anotherPerson.name); // Nicholas\nconsole.log(anotherPerson.friends); // [ 'Shelby', 'Court', 'Van' ]\n```\n\n这个例子基于`person`对象返回了一个**新对象**。新返回的`anotherPerson`对象具有`person`的所有**属性**和**方法**，还有一个新方法`sayHi()`。\n\n**寄生式继承**同样适合主要关注对象，而不在乎**类型**和**构造函数**的场景。`Object.create()`函数**不是**寄生式继承所必需的，任何**返回新对象的函数**都可以在这里使用。\n\n## 6. 寄生式组合继承\n\n**组合继承**存在效率问题：**父类构造函数**始终会**被调用两次**，一次在是**创建子类原型**时调用，另一次是在**子类构造函数**中调用。\n\n**寄生式组合继承**的基本模式如下所示：\n\n```javascript\nfunction inheritPrototype(subType, superType) {\n    let prototype = object(superType.prototype); // 创建对象\n    prototype.constructor = subType; // 增强对象\n    subType.prototype = prototype; // 赋值对象\n}\n```\n\n`inheritPrototype()`函数实现了**寄生式组合继承**的核心逻辑。函数接收两个参数：**子类构造函数**和**父类构造函数**。在这个函数内部，第一步是**创建父类原型的副本**。然后，**给返回的`prototype`对象设置`constructor`属性**，解决由于重写原型导致默认`constructor`丢失的问题。最后**将新创建的对象赋值给子类型的原型**。\n\n```javascript\nfunction inheritPrototype(subType, superType) {\n    let prototype = Object.create(superType.prototype); // 创建对象\n    prototype.constructor = subType; // 增强对象\n    subType.prototype = prototype; // 赋值对象\n}\n\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nconst usr = new SubType('Jack', 18);\nusr.sayName(); // Jack\nusr.sayAge(); // 18\nconsole.log(usr.colors); // [ 'red', 'blue', 'green' ]\n```\n\n这里只调用了一次`SuperType`构造函数，避免了`SubType.prototype`上不必要也用不到的属性， 因此可以说这个例子的效率更高。而且，**原型链仍然保持不变**，因此`instanceof`操作符和`isPrototypeOf()`方法正常有效。\n\n**寄生式组合继承**可以算是**引用类型继承**的**最佳模式**。\n\n\n",
      "date": 1627998446000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 6种继承方式详解",
      "titleEng": "inherit"
    },
    {
      "_id": "f427f5e2642313f30019ba0a02aac3bd",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "**（1）属性设置使用简写**\n\n例如：\n\n```css\n.box {\n    margin-top: 10px;\n    margin-right: 20px;\n    margin-bottom: 30px;\n    margin-left: 40px;\n}\n```\n\n简写为：\n\n```css\n.box {\n    margin: 10px 20px 30px 40px;\n}\n```\n\n可以减小生成包的体积。\n\n**（2）用CSS替换图片**\n\n一些箭头、圆，若能用CSS代替，尽量用CSS画。\n\n可以减少HTTP请求，减轻服务器压力。\n\n**（3）删除不必要的单位、零**\n\n例如：\n\n```css\n.box {\n    width: 0.2em;\n    height: 20em;\n    padding: 0px;\n}\n```\n\n可优化为：\n\n```css\n.box {\n    width: 0.2em;\n    height: 20em;\n    padding: 0;\n}\n```\n\n可以减小生成包的体积。\n\n**（4）使用CSS精灵图**\n\n也可以减少HTTP请求，减轻服务器压力。",
      "date": 1603093237000,
      "post": true,
      "tags": ["CSS"],
      "title": "如何优化CSS以提高性能？",
      "titleEng": "css-optimize"
    },
    {
      "_id": "2cc84e26642313f6067fbbab5c3cf1ee",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "# 1. 实现效果\n\n一共三栏，左中右，左右分别在页面的左右侧，中间部分充满剩余的宽度。\n\n![](https://img.lzxjack.top:99/20211019145816.png)\n\n# 2. 实现方案\n\n## 1. 浮动布局\n\n注意，中间的盒子，需要写在最下面。左右盒子分别设置左浮动、右浮动。\n\n```html\n<div class=\"box\">\n    <div class=\"left\">left</div>\n    <div class=\"right\">right</div>\n    <div class=\"center\">center</div>\n</div>\n```\n\n```css\n.left {\n    float: left;\n    width: 100px;\n    background: red;\n}\n\n.center {\n    background: green;\n}\n\n.right {\n    float: right;\n    width: 100px;\n    background: blue;\n}\n```\n\n## 2. table布局\n\n```html\n<div class=\"box\">\n    <div class=\"left\">left</div>\n    <div class=\"center\">center</div>\n    <div class=\"right\">right</div>\n</div>\n```\n\n```css\n.box {\n    width: 100%;\n    display: table;\n    height: 100px;\n}\n\n.left {\n    display: table-cell;\n    width: 100px;\n    background: red;\n}\n\n.center {\n    display: table-cell;\n    background: green;\n}\n\n.right {\n    display: table-cell;\n    width: 100px;\n    background: blue;\n}\n```\n\n## 3. 定位布局\n\n父盒子相对定位，子盒子绝对定位。\n\n```html\n<div class=\"box\">\n    <div class=\"left\">left</div>\n    <div class=\"center\">center</div>\n    <div class=\"right\">right</div>\n</div>\n```\n\n```css\n.box {\n    position: relative;\n}\n\n.left {\n    position: absolute;\n    left: 0px;\n    width: 100px;\n    background: red;\n}\n\n.center {\n    position: absolute;\n    left: 100px;\n    right: 100px;\n    background: green;\n}\n\n.right {\n    position: absolute;\n    right: 0px;\n    width: 100px;\n    background: blue;\n}\n```\n\n## 4. flex布局\n\n父盒子设置为`flex`容器，左右盒子定宽，中间盒子占满剩余空间。\n\n```html\n<div class=\"box\">\n    <div class=\"left\">left</div>\n    <div class=\"center\">center</div>\n    <div class=\"right\">right</div>\n</div>\n```\n\n```css\n.box {\n    display: flex;\n}\n\n.left {\n    width: 100px;\n    background: red;\n}\n\n.center {\n    flex: 1;\n    background: green;\n}\n\n.right {\n    width: 100px;\n    background: blue;\n}\n```\n\n## 5. grid布局\n\n只需两行核心代码即可。\n\n```html\n<div class=\"box\">\n    <div class=\"left\">left</div>\n    <div class=\"center\">center</div>\n    <div class=\"right\">right</div>\n</div>\n```\n\n```css\n.box {\n    display: grid;\n    grid-template-columns: 100px 1fr 100px;\n}\n\n.left {\n    background: red;\n}\n\n.center {\n    background: green;\n}\n\n.right {\n    background: blue;\n}\n```\n\n",
      "date": 1603092649000,
      "post": true,
      "tags": ["CSS"],
      "title": "CSS实现三栏布局的5种方案",
      "titleEng": "3-layout"
    },
    {
      "_id": "1ac91032642313f9001aca5a356d7564",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "# 1. 实现效果\n\n在一个父盒子中，有两个子盒子。左边盒子定宽，右边盒子自动充满剩下的宽度。当左边盒子宽度改变时，右边盒子也会自动调整，以充满整个剩下的宽度。\n\n![](https://img.lzxjack.top:99/20211018151153.gif)\n\n# 2. 实现方案\n\n相同的`HTML`：\n\n```html\n<div class=\"box-wrapper\">\n    <div class=\"left-box\">left-box</div>\n    <div class=\"right-box\">right-box</div>\n</div>\n```\n\n## 1. flex布局\n\n```css\n.box-wrapper {\n    width: 600px;\n    height: 400px;\n    border: 1px solid #000;\n    /* flex布局 */\n    display: flex;\n}\n\n.left-box {\n    width: 200px;\n    height: 100%;\n    background: red;\n}\n\n.right-box {\n    background: blue;\n    flex: 1;\n}\n```\n\n## 2. table布局\n\n```css\n.box-wrapper {\n    width: 600px;\n    height: 400px;\n    border: 1px solid #000;\n    /* table 布局 */\n    display: table;\n}\n\n.left-box {\n    width: 200px;\n    height: 100%;\n    background: red;\n    display: table-cell;\n}\n\n.right-box {\n    height: 100%;\n    background: blue;\n    display: table-cell;\n}\n```\n\n## 3. grid布局\n\n```css\n.box-wrapper {\n    width: 600px;\n    height: 400px;\n    border: 1px solid #000;\n    display: grid;\n    /* 声明列的宽度 */\n    grid-template-columns: 200px auto;\n}\n\n.left-box {\n    background: red;\n}\n\n.right-box {\n    background: blue;\n}\n```\n\n",
      "date": 1603005361000,
      "post": true,
      "tags": ["CSS"],
      "title": "CSS实现左边定宽、右边自适应布局",
      "titleEng": "css-auto-width"
    },
    {
      "_id": "93e4b6a0642313db06838469444aec7c",
      "_openid": "dbee9976b3c14448a06f2006a4795cf2",
      "classes": "CSS",
      "content": "CSS中有继承性的属性如下：\n\n|      类型      |                             属性                             |\n| :------------: | :----------------------------------------------------------: |\n|    **字体**    | `font`、`font-family`、`font-weight`、`font-size`、`font-style`... |\n|    **文本**    | `text-indent`、`text-align`、`line-height`、`word-spacing`、`letter-spacing`、`text-transform`、`direction`、`color` |\n| **元素可见性** |                         `visibility`                         |\n|    表格布局    | `caption-side`、`border-collapse`、`border-spacing`、`empty-cells`、`table-layout` |\n|      列表      | `list-style-type`、`list-style-image`、`list-style-position`、`list-style` |\n|    生成内容    |                           `quotes`                           |\n|    **光标**    |                           `cursor`                           |\n|    页面样式    |      `page`、`page-break-inside`、`windows`、`orphans`       |\n|    声音样式    | `speak`、`speak-punctuation`、`speak-numeral`、`speak-header`、`speech-rate`、`volume`、`voice-family`、`pitch`、`pitch-range`、`stress`、`richness`、`azimuth`、`elevation` |\n\n\n\n",
      "date": 1602746251000,
      "post": true,
      "tags": ["CSS"],
      "title": "CSS可以继承的属性",
      "titleEng": "css-inherit"
    }
  ],
  "requestId": "60f031c689223"
}
