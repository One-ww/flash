{
  "data": [
    {
      "_id": "2d44d6c2612c3f1307cb7d694c4def74",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上 2021-8-30 的每日一题：<a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\" target=\"_blank\">「528. 按权重随机选择」</a>\n\n## 1. 题目描述\n\n给定一个正整数数组`w`，其中`w[i]`代表下标`i`的权重（下标从`0`开始），请写一个函数`pickIndex`，它可以随机地获取下标`i`，选取下标`i`的概率与`w[i]`成正比。\n\n例如，对于`w = [1, 3]`，挑选下标`0`的概率为`1 / (1 + 3) = 0.25` （即，25%），而选取下标`1`的概率为`3 / (1 + 3) = 0.75`即，75%）。\n\n也就是说，选取下标`i`的概率为`w[i] / sum(w) `。\n\n**示例 1：**\n\n```\n输入：\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n输出：\n[null,0]\n解释：\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。\n```\n\n**示例 2：**\n\n```\n输入：\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n```\n\n## 2. 解答\n\n例如输入数组为`[1,2,3,4]`，则划分：`[1,1], [2,3], [4,5,6], [7,8,9,10]`，求出前缀和数组`[1,3,6,10]`。\n\n生成`[1,10]`之间的一个随机整数，用二分查找在前缀和数组中寻找满足区间条件的最小下标`i`，并返回。\n\n```javascript\nclass Solution {\n    constructor(w) {\n        this.len = w.length;\n        // 定义前缀和数组\n        this.pre = new Array(this.len).fill(0);\n        this.pre[0] = w[0];\n        // 从i=1开始，求每个位置的前缀和\n        for (let i = 1; i < this.len; i++) {\n            this.pre[i] = this.pre[i - 1] + w[i];\n        }\n        console.log(this.pre);\n        // 总和\n        this.total = this.pre[this.len - 1];\n    }\n    pickIndex() {\n        // Math.random()返回 0 ~ 1 之间的一个随机数\n        // x 是 1 ~ total 之间的一个随机整数\n        const x = Math.floor(Math.random() * this.total) + 1;\n        // 二分查找\n        let [low, high] = [0, this.len - 1];\n        while (low <= high) {\n            const mid = (low + high) >> 1;\n            if (this.pre[mid] < x) low = mid + 1;\n            else high = mid - 1;\n        }\n        return low;\n    }\n}\n```\n\n\n\n***\n\n😄最近新创建了个开源仓库，总结LeetCode的每日一题，目前已有C++、JavaScript语言版本，欢迎大家提供其他语言版本！\n\n🖥️仓库地址：<a href=\"https://github.com/HDU-Coder-X/Daily-question-of-Leetcode\" target=\"_blank\">「每日一题系列」</a>",
      "date": 1630289631000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」按权重随机选择",
      "titleEng": "lc-528",
      "url": "https://lzxjack.top/post?title=lc-528"
    },
    {
      "_id": "2d44d6c2612af66507a545db6a5f0f96",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "LeetCode 题解",
      "content": "> 这是 LeetCode 上 2021-8-29 的每日一题：<a href=\"https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/\" target=\"_blank\">「1588. 所有奇数长度子数组的和」</a>\n\n## 1. 题目描述\n\n给你一个正整数数组`arr`，请你计算所有可能的奇数长度子数组的和。\n\n**子数组**定义为原数组中的一个连续子序列。\n\n请你返回`arr`中**所有奇数长度子数组的和** 。\n\n**示例 1：**\n\n```\n输入：arr = [1,4,2,5,3]\n输出：58\n解释：所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n```\n\n**示例 2：**\n\n```\n输入：arr = [1,2]\n输出：3\n解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。\n```\n\n## 2. 解答\n\n首先根据<a href=\"https://leetcode-cn.com/problems/running-sum-of-1d-array/\" target=\"_blank\">「1480. 一维数组的动态和」</a>**原地修改**计算出数组每个位置的前缀和，再确定左右边界计算所有奇数长度子数组的和。\n\n使用双重`for`循环确定左右边界`i`和`j`，外层`i`每次`+1`，因为子数组长度要奇数，所以内层`j`每次`+2`。\n\n例如，对于用例`arr = [1,4,2,5,3]`，**注意**，此时`arr`已经是输入数组的前缀和：\n\n- `i != 0`时，比如`[i,j]=[1,3]`区间的子数组`[4,2,5]`，和为`arr[3] - arr[1-1]`，即`arr[j] - arr[i-1]`\n- `i == 0`时，比如`[i,j]=[0,2]`区间的子数组`[1,4,2]`，和为`arr[2]`，即`arr[j]`\n- 总结起来就是，对于`[i,j]`的区间子数组，和为`arr[j] - (arr[i - 1] || 0)`\n- 循环中累加所求的区间子数组和即可\n\n![](https://img.lzxjack.top:99/20210829103814.png)\n\n![](https://img.lzxjack.top:99/20210829103831.png)\n\n![](https://img.lzxjack.top:99/20210829103849.png)\n\n```javascript\nconst sumOddLengthSubarrays = arr => {\n    const len = arr.length;\n    // 原地修改，计算前缀和\n    for (let i = 1; i < len; i++) {\n        arr[i] += arr[i - 1];\n    }\n    // 定义返回值，初始为0\n    let res = 0;\n    // 定义左边界\n    for (let i = 0; i < len; i++) {\n        // 定义右边界，因为长度奇数，j每次+2\n        for (let j = i; j < len; j += 2) {\n            // 此时arr已经是前缀和\n            // i!==0, [i,j]区间内的长度和 = arr[j] - arr[i - 1]\n            // i===0, [i,j]区间内的长度和 = arr[j]\n            res += arr[j] - (arr[i - 1] || 0);\n        }\n    }\n    return res;\n};\n```\n\n\n\n***\n\n😄最近新创建了个开源仓库，总结LeetCode的每日一题，目前已有C++、JavaScript语言版本，欢迎大家提供其他语言版本！\n\n🖥️仓库地址：<a href=\"https://github.com/HDU-Coder-X/Daily-question-of-Leetcode\" target=\"_blank\">「每日一题系列」</a>",
      "date": 1630205423000,
      "post": true,
      "tags": ["JavaScript", "LeetCode"],
      "title": "「每日一题」所有奇数长度子数组的和",
      "titleEng": "lc-1588",
      "url": "https://lzxjack.top/post?title=lc-1588"
    },
    {
      "_id": "8937eaa961288547069d0a651ee59c1e",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "> 本文记录了一次部署 API 接口的踩坑经历，写得不好，多多指教。😆😆\n\n在写我的个人博客系统的时候，要开发一个评论小模块，其中有一项功能：有**用户 1**已经评论留言，**用户 2**在**用户 1**的评论下，给**用户 1**回复评论。\n\n这时候需要发一封邮件通知**用户 1**的评论收到了回复，于是就利用[「Nodemailer」](https://github.com/nodemailer/nodemailer)写了这样一个功能，具体实现见<a href=\"https://lzxjack.top/post?title=email\" target=\"_blank\">JavaScript 利用Nodemailer发送电子邮件</a>，使用**Node.js**编写，接口放在了云服务器上。\n\n在本地服务器`localhost:3000`测试后，可以正常发送请求，并发送邮件。\n\n但是当我将博客项目打包成静态页面，托管在腾讯云开发上后，再次测试，浏览器控制台（Edge）发出以下**错误**：\n\n![](https://img.lzxjack.top:99/20210827133516.jpg)\n\n查了一下资料，发现原因是页面通过**HTTPS**加载，而发出的请求是**HTTP**协议的，这个请求被浏览器拦截，因此服务器没有收到请求。\n\n于是我想把服务器的接口地址配置上**SSL**证书，也通过**HTTPS**协议访问，这样发送的请求也是**HTTPS**协议，应该就没问题了。\n\n但经过一番尝试后，发现我只有一个博客域名，申请的**SSL**证书是绑定这个域名的，无法再绑定到**IP**地址，于是又**失败**了...🙃🙃🙃\n\n既然只有一个域名，我又想到了一个方案：将博客部署到云服务器，域名解析到服务器，API 接口放在服务器的另一个端口，这样博客页面和 API 接口使用同一个域名（端口号不同），不就都可以配置**SLL**证书，都实现**HTTPS**协议了吗！😁\n\n于是我把博客页面由腾讯云开发托管，改为部署到云服务器，并配置**SSL**证书，具体见<a href=\"https://lzxjack.top/post?title=nginx-ssl\" target=\"_blank\">nginx下安装SSL证书，为页面开启HTTPS访问！</a>\n\n然后修改了 API 接口，原 API 接口见<a href=\"https://lzxjack.top/post?title=email\" target=\"_blank\">JavaScript 利用Nodemailer发送电子邮件</a>，修改了`app.js`，添加`https`模块来配置**SSL**证书：\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst email = require('./email');\nconst https = require('https');\nconst fs = require('fs');\n\n// 拦截所有请求\napp.use((req, res, next) => {\n    // 1.允许哪些客户端访问我\n    // * 代表允许所有的客户端访问我\n    // 注意：如果跨域请求中涉及到cookie信息传递，值不可以为*号 比如是具体的域名信息\n    res.header('Access-Control-Allow-Origin', 'https://lzxjack.top');\n    // 2.允许客户端使用哪些请求方法访问我\n    res.header('Access-Control-Allow-Methods', 'get');\n    // 允许客户端发送跨域请求时携带cookie信息\n    res.header('Access-Control-Allow-Credentials', true);\n    next();\n});\n\n// 博客评论收到回复后的邮件提醒服务\napp.use('/email', email);\n\nconst httpsOption = {\n    key: fs.readFileSync('./SSL/lzxjack.top.key'), //配置自己的证书\n    cert: fs.readFileSync('./SSL/lzxjack.top.pem'), //同上\n};\n\nhttps.createServer(httpsOption, app).listen(444);\nconsole.log('服务器启动成功，监听444端口...');\n```\n\n客户端调用接口时，以**https**协议，并加上端口号`444`：\n\n```javascript\naxios({\n    url: 'https://lzxjack.top:444/email',\n    method: 'get',\n    params: {\n        name,\n        owner,\n        email: replyEmail,\n        search: props.postTitle,\n    },\n    withCredentials: true,\n})\n```\n\n这样就完成了！用户回复评论时，服务器可以正常收到请求，并发送提醒邮件！🚩🚩🚩",
      "date": 1630045272000,
      "post": true,
      "tags": ["Node.js", "Linux"],
      "title": "简单记录一次使用Node.js部署API的踩坑经历",
      "titleEng": "log-node-api",
      "url": "https://lzxjack.top/post?title=log-node-api"
    },
    {
      "_id": "8937eaa96125a19a0628ed9e132453cb",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "## 1. 前言\n\n之前我使用`hexo`搭建过个人博客。`hexo`很强大，渲染页面速度快，支持`markdown`语法，可以一键部署，还可以扩展各种插件。\n\n但`hexo`搭建的是静态页面，每次更新文章，都要**重新生成**静态页面，再部署页面。`hexo`也没有后台管理，想要修改发布的文章，只能修改源代码，再重新生成页面。所以很早之前就想写一个自己的博客系统，由**博客展示页面**和**后台管理页面**构成，通过后台管理页面，可以实时更新、发布文章，非常方便。但在当时还没有能力写出这样一个系统，就一直没有去做。\n\n后来学习了`React`之后，想尝试下写自己的博客，就每天课余时间写一点，最后写出来了 😅😅😅。\n\n由于之前有搭建过`hexo`博客，所以就按照之前自己`hexo`博客的功能来写，基本的功能有文章管理、文章搜索、分类/标签、图库、说说、留言板/评论、友链、小作品页面、建站日志时间轴、关于页面等。但是很多功能还不完善，不具有通用性，只适用于本博客，以后会慢慢改进 🧐🧐🧐！\n\n## 2. 仓库地址\n\n### 1. 博客展示页面\n\n演示地址：<a href=\"https://lzxjack.top/\" target=\"_blank\">「飞鸟小站」</a>\n\n仓库地址：<a href=\"https://github.com/lzxjack/react-blog\" target=\"_blank\">「GitHub」</a>\n\n![](https://img.lzxjack.top:99/20210907102912.png)\n\n### 2. 后台管理页面\n\n演示地址：<a href=\"https://react-blog-admin-8fo571wf24c87f9-1304393382.ap-shanghai.app.tcloudbase.com/\" target=\"_blank\">「飞鸟小站后台」</a>\n\n>点击`游客`按钮即可使用**游客**身份浏览！\n\n仓库地址：<a href=\"https://github.com/lzxjack/react-blog-admin\" target=\"_blank\">「GitHub」</a>\n\n![](https://img.lzxjack.top:99/20210907102952.png)\n\n## 3. 用到的技术/工具\n\n🔖 博客主要使用到的技术如下：\n\n**前端**（博客页面+后台管理）：\n\n-   `React`脚手架`Create-React-App`\n-   状态集中管理工具`Redux`\n-   前端路由`React-Router`\n-   `AntD`组件库\n-   <a href=\"https://www.jinrishici.com/\" target=\"_blank\">今日诗词</a>提供首页的诗句\n-   时间格式化工具<a href=\"http://momentjs.cn/\" target=\"_blank\">moment</a>\n-   `markdown`格式渲染工具<a href=\"https://github.com/markedjs/marked\" target=\"_blank\">marked</a>\n-   代码高亮渲染工具<a href=\"https://highlightjs.org/\" target=\"_blank\">highlight.js</a>\n-   其他第三方包\n\n**后端**：\n\n后端使用腾讯云`CloudBase`云端一体化后端云服务，包括：\n\n-   用户管理：管理员登录、访客匿名用户登录\n-   数据库：存放管理员的博客数据\n-   网站托管：托管后台管理页面\n\n**其他**：\n\n-   评论回复的邮箱提醒`API`，使用`Node.js`编写，运行在自己的**阿里云服务器**上\n-   已配置**SSL 证书**，开启**HTTPS**访问\n-   博客展示页面托管于**腾讯云开发静态文件托管**\n-   图床使用**阿里云OSS**\n-   `Webify`：应用托管，自动部署**后台管理页面**\n\n## 4. 主要功能\n\n### 1. 博客展示页面\n\n-   首页预览所有文章\n-   查看文章评论、发布评论、评论回复\n-   搜索文章：根据关键字搜索、分类搜索、标签搜索\n-   查看相册\n-   查看说说\n-   查看留言板留言、发布留言、留言回复\n-   查看友链、访问友链\n-   查看小作品\n-   查看建站日志时间轴\n-   查看关于本站/关于我\n-   进入后台管理页面\n\n### 2. 后台管理页面\n\n**管理**是指：对数据的**增**、**删**、**改**、**查**。\n\n-   首页预览博客基本数据（文章数、草稿数、友链数等），管理分类、标签\n-   文章管理、草稿管理\n-   相册管理\n-   说说管理\n-   查看留言、评论，删除留言、评论\n-   友链管理\n-   小作品管理\n-   关于页面文字管理\n-   建站日志管理\n\n## 5. 不断改进\n\n由于时间有限、本人能力有限，博客系统还有很多不足之处，会在学习新知识的同时不断改进博客。\n\n也请各路大佬多多指点 😆😆😆！\n\n\n",
      "date": 1629856078000,
      "post": true,
      "tags": ["React", "AntD", "JavaScript"],
      "title": "用React写的一款个人博客系统，前台+后台管理！",
      "titleEng": "my-blog",
      "url": "https://lzxjack.top/post?title=my-blog"
    },
    {
      "_id": "8937eaa961250817061db4e349d28409",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "## 1. 前言\n\n博客页面完成之后，需要将页面部署上线。本来整个开发流程都是基于**腾讯云开发**的，可以直接上传到腾讯云开发的**静态页面托管**，然后自定义域名，上传**SSL证书**即可，非常简单。\n\n但由于一些原因，我不得不将博客页面放到云服务器上运行，配置`nginx`环境，配置**SSL证书**以实现**HTTPS访问**。\n\n这里记录一下我的配置过程，以便分享和日后参考。\n\n## 2. 域名解析\n\n我是在**阿里云**购买的域名，到阿里云域名解析处，解析域名。\n\n![](https://img.lzxjack.top:99/20210824224612.png)\n\n- 主机记录中，`@`代表`lzxjack.top`。\n- 记录类型`A`是指，将域名指向一个`IPV4`地址。\n- 记录值就是服务器的**公网IP**。\n\n## 3. 博客页面放到服务器\n\n将打包好的**静态文件**上传到云服务器的某个位置，比如我放到了云服务器的`/home/www/blog`目录下。\n\n![](https://img.lzxjack.top:99/20210824223248.png)\n\n>注意，不要放到`admin`文件夹中，**可能**会访问不了！！我之前放到`admin`文件夹中，访问不了，后来改了路径，就可以访问。\n\n## 4. 开启服务器端口\n\n这里我使用了服务器的**80端口**和**443端口**，所以需要在云服务器中，将端口开放。\n\n![](https://img.lzxjack.top:99/20210824224334.png)\n\n## 5. nginx下安装SSL证书\n\n### 1. SSL证书放到服务器\n\n在**阿里云SSL证书**管理中，下载已经申请的免费证书，注意下载**nginx**类型的。\n\n![](https://img.lzxjack.top:99/20210824222801.png)\n\n下载后有两个文件，一个以`key`结尾，一个以`pem`结尾。将这两个文件放到云服务器的`/etc/nginx/cert`路径下：\n\n![](https://img.lzxjack.top:99/20210824223009.png)\n\n### 2. 配置nginx\n\n在云服务器的`/etc/nginx/`目录下，新建`vhost`文件夹，自己写的配置都放到这个文件夹中。然后在配置文件`nginx.conf`中将**整个文件夹**引入进来即可。这样若有新的需求时，只需在文件夹中添加新需求的配置文件即可，不会再次修改配置文件`nginx.conf`，提高效率。\n\n新建`vhost`文件夹后，在`/etc/nginx/vhost`新建配置文件：`blog.conf`，注意一定要以`conf`为后缀。\n\n文件内容如下：\n\n```c\nserver{\n        listen 443 ssl;\n        #- 打包后静态文件的路径\n        root /home/www/blog;\n        #- 将lzxjack.top替换成自己的域名\n        server_name lzxjack.top;\n        #- 404后重定向到index.html\n        error_page 404 /index.html;\n        #- 需要将lzxjack.top.pem替换成已上传的证书文件的名称。\n        ssl_certificate /etc/nginx/cert/lzxjack.top.pem;\n        #- 需要将lzxjack.top.key替换已上传的证书密钥文件的名称。\n        ssl_certificate_key /etc/nginx/cert/lzxjack.top.key;\n        ssl_session_timeout 5m;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n\n        location /{}\n}\n\n#- 设置HTTP请求自动跳转HTTPS\nserver {\n        listen 80;\n        #- 将lzxjack.top替换成自己的域名\n        server_name lzxjack.top;\n        rewrite ^(.*)$ https://$host$1;\n        location /{}\n}\n```\n\n根据注释内容，自行更改即可。\n\n### 3. 引入自己写的配置文件\n\n在云服务器中，打开`/etc/nginx/`目录下的`nginx.conf`文件，添加下面一行代码，将刚才新建的配置文件引入进来。`*.conf`的意思是将`vhost`文件夹下的所有`.conf`后缀的文件都引入了进来。\n\n![](https://img.lzxjack.top:99/20210824224907.png)\n\n> 注意：要写在`http{}`的里面。\n\n## 6. 完成\n\n云服务器输入`nginx -s reload`，重启`nginx`。\n\n到此为止，博客页面就配置好了。可以通过域名访问到博客，并开启了**HTTPS访问**。\n\n",
      "date": 1629816695000,
      "post": true,
      "tags": ["实用技巧", "HTTPS", "nginx", "Linux"],
      "title": "nginx下安装SSL证书，为页面开启HTTPS访问！",
      "titleEng": "nginx-ssl",
      "url": "https://lzxjack.top/post?title=nginx-ssl"
    },
    {
      "_id": "cd045e756124e5e60782d9ec3ceaa4c9",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "站点搭建",
      "content": "## 1. 前言\n\n最近在写一个博客系统，在「评论」模块中，有这样一个需求：有**用户 1**已经评论留言，**用户 2**在**用户 1**的评论下，给**用户 1**回复评论。\n\n这时候需要发一封邮件通知**用户 1**的评论收到了回复，所以就想写一个自动发邮件的功能。\n\n在网上找到了<a href=\"https://github.com/nodemailer/nodemailer\" target=\"_blank\">「Nodemailer」</a>这个项目，「Nodemailer」是一个简单易用的`Node.js`邮件发送组件，可以使用**SMTP**协议，用指定的账户发送电子邮件。\n\n但是「Nodemailer」只能运行在`Node.js`环境中，在浏览器中直接使用会报错，使用不了。所以我的想法是，在自己的「阿里云服务器」`Node.js`环境中，使用`express`框架搭建一个简单的路由，「Nodemailer」运行在服务器上。在前端页面利用`Axios`发送 http 请求，服务器收到相应请求后，获取参数，使用「Nodemailer」发送电子邮件。\n\n![](https://img.lzxjack.top:99/20210811095916.png)\n\n同时还要注意**同源政策**的问题。\n\n话不多说，开始实现这样一个功能吧！\n\n## 2. 客户端代码\n\n客户端只需要通过`Axios`发送 http 请求给服务器即可：\n\n```javascript\naxios({\n    url: 'http://XX.XXX.XXX.XXX:4000/email',\n    method: 'get',\n    params: {\n        name,\n        owner,\n        email: replyEmail,\n        search: 'msg',\n    },\n    withCredentials: true,\n})\n    .then(() => message.success('回复成功!'))\n    .catch(err => console.error(err));\n```\n\n这里设置了`withCredentials`为`true`，指定在涉及到**跨域请求**时，携带`cookie`信息。\n\n## 3. 服务端代码\n\n使用模块化路由，所有的**路由请求**都在`app.js`中处理，各个模块处理相应的逻辑。\n\n在`app.js`中，使用`use()`中间件拦截所有请求，为`res`统一设置`header`，解决同源限制问题。\n\n`app.js`：\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst email = require('./email');\n\n// 拦截所有请求\napp.use((req, res, next) => {\n    // 1.允许哪些客户端访问我\n    // * 代表允许所有的客户端访问我\n    // 注意：如果跨域请求中涉及到cookie信息传递，值不可以为*号 比如是具体的域名信息\n    res.header('Access-Control-Allow-Origin', 'http://localhost:3001');\n    // 2.允许客户端使用哪些请求方法访问我\n    res.header('Access-Control-Allow-Methods', 'get,post');\n    // 允许客户端发送跨域请求时携带cookie信息\n    res.header('Access-Control-Allow-Credentials', true);\n    next();\n});\n\n// 博客评论收到回复后的邮件提醒服务\napp.use('/email', email);\n\napp.listen(4000);\nconsole.log('服务器启动成功，监听4000端口...');\n```\n\n发送电子邮件的步骤写在`email.js`中，主要分为三步：\n\n1. 引入`nodemailer`\n2. 创建发件人的信息\n3. 发送电子邮件\n\n这里我使用的是 163 邮箱，需要在 163 邮箱中，开启`smtp`服务，并获取到**授权码**。\n\n`email.js`：\n\n```javascript\nconst express = require('express');\nconst email = express.Router();\n// 1. 引入nodemailer\nconst nodemailer = require('nodemailer');\n\n// 2. 创建发件人的信息\nconst transporter = nodemailer.createTransport({\n    host: 'smtp.163.com',\n    port: 465,\n    secureConnection: true, // use SSL\n    auth: {\n        user: 'lzxjack1998@163.com', // 自己的邮箱地址\n        pass: 'xxxxxxxxxxxxxx', // 不是密码，是授权码\n    },\n});\n\nemail.get('/', (req, res) => {\n    const { name, owner, email: to, search } = req.query;\n    const blogUrl = 'xxxxxxxxxxxxxxxxx';\n    const html = 'xxxxxxxxxxxxxx';\n    const subject = '评论回复提醒';\n    const from = '\"飞鸟\"<lzxjack1998@163.com>';\n    const mailOptions = {\n        from, // 发件人\n        to, // 收件人\n        subject, // 邮件标题\n        html, // 邮件内容，html格式\n    };\n    // 3. 发送电子邮件\n    transporter.sendMail(mailOptions, (error, info) => {\n        if (error) return console.log(error);\n        console.log(info);\n    });\n    res.send('已成功发送邮件！');\n});\n\nmodule.exports = email;\n```\n\n## 4. 发送邮件\n\n将服务端代码放到云服务器上，运行`app.js`：\n\n![](https://img.lzxjack.top:99/20210811101703.png)\n\n尝试回复一个评论，发送`axios`请求，发送电子邮件，服务端打印相关信息：\n\n![](https://img.lzxjack.top:99/20210811101959.png)\n\n成功收到邮件！\n\n![](https://img.lzxjack.top:99/20210811101842.png)\n\n\n",
      "date": 1628675104000,
      "post": true,
      "tags": ["JavaScript", "Node.js", "Linux"],
      "title": "JavaScript 利用Nodemailer发送电子邮件",
      "titleEng": "email",
      "url": "https://lzxjack.top/post?title=email"
    },
    {
      "_id": "2d44d6c26124f89106c306fd3b972b7b",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. 原型链继承\n\n```javascript\n// 定义父类\nfunction Parent() {\n    this.name = 'Jack';\n}\n// 父类原型添加方法\nParent.prototype.getName = function () {\n    return this.name;\n};\n\n// 子类\nfunction Child() {}\n// 子类的原型设置为父类Parent的实例\nChild.prototype = new Parent();\n\n// 实例化子类\nconst child = new Child();\n\nconsole.log(child.getName()); // Jack\n```\n\n父类`Parent`有属性和方法，子类`Child`没有属性和方法。实现继承的关键是，子类`Child`没有使用默认原型，而是将其替换成了一个新的对象，这个对象恰好是`Parent`的实例，这样`Child`的实例就能从`Parent`的实例中继承属性和方法，而且还与`Parent`的原型挂上了钩。\n\n`Child`和`Parent`的关系如下如所示：\n\n![](https://img.lzxjack.top:99/20210802133147.png)\n\n**缺陷**：\n\n（1）原型中包含**引用值**的时候，会在所有实例间共享\n\n```javascript\nfunction SuperType() {\n    this.colors = ['red', 'blue', 'green'];\n}\nfunction SubType() {}\n// 继承 SuperType\nSubType.prototype = new SuperType();\n\nconst instance1 = new SubType();\ninstance1.colors.push('black'); // 加入新元素\nconsole.log(instance1.colors); // [ 'red', 'blue', 'green', 'black' ]\n\nconst instance2 = new SubType();\nconsole.log(instance2.colors); // [ 'red', 'blue', 'green', 'black' ]\n```\n\n`SubType`的所有实例都会共享这个`colors`属性。这一点通过`instance1.colors`上的修改也能反映到`instance2.colors`上就可以看出来。\n\n（2）子类型在实例化时**不能**给父类型的构造函数传参\n\n由于以上两个原因，**原型链继承**基本不会单独使用。\n\n## 2. 盗用构造函数\n\n这种技术有时也称作**对象伪装**或**经典继承**。在**子类构造函数**中调用**父类构造函数**。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 `apply()`和`call()`方法以**新创建的对象**为上下文执行构造函数。\n\n```javascript\nfunction SuperType() {\n    this.colors = ['red', 'blue', 'green'];\n}\nfunction SubType() {\n    // 继承 SuperType\n    SuperType.call(this);\n}\nconst instance1 = new SubType();\ninstance1.colors.push('black');\nconsole.log(instance1.colors); // [ 'red', 'blue', 'green', 'black' ]\n\nconst instance2 = new SubType();\nconsole.log(instance2.colors); // [ 'red', 'blue', 'green' ]\n```\n\n通过使用`call()`或`apply()`方法，`SuperType`构造函数在为`SubType`的实例创建的新对象的上下文中执行了。这相当于新的`SubType`对象上运行了 `SuperType()`函数中的**所有初始化代码**。结果就是每个实例都会有自己的`colors`属性。\n\n**优势**：\n\n相比于使用**原型链**，**盗用构造函数**的一个优点就是**可以在子类构造函数中向父类构造函数传参**。\n\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n}\nfunction SubType() {\n    // 继承 SuperType 并传参\n    SuperType.call(this, 'Nicholas');\n    // 实例属性\n    this.age = 29;\n}\nconst usr = new SubType();\nconsole.log(usr.name, usr.age); // Nicholas 29\n```\n\n**缺陷**：\n\n（1）必须在构造函数中定义方法，因此**函数不能重用**，每次创建实例都会创建一次方法。\n\n（2）子类也**不能**访问**父类原型**上定义的方法，因此所有类型只能使用**构造函数模式**。\n\n盗用构造函数基本上也**不能单独使用**。\n\n## 3. 组合继承\n\n**组合继承**，有时候也叫**伪经典继承**，综合了**原型链**和**盗用构造函数**，将两者的优点集中了起来。使用**原型链继承原型上的属性和方法**，而通过**盗用构造函数继承实例属性**。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction SubType(name, age) {\n    // 继承属性\n    SuperType.call(this, name);\n    this.age = age;\n}\n// 继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nconst usr1 = new SubType('Nicholas', 29);\nusr1.colors.push('black');\nconsole.log(usr1.colors); // [ 'red', 'blue', 'green', 'black' ]\nusr1.sayName(); // Nicholas\nusr1.sayAge(); // 29\n\nconst usr2 = new SubType('Greg', 27);\nconsole.log(usr2.colors); // [ 'red', 'blue', 'green' ]\nusr2.sayName(); // Greg\nusr2.sayAge(); // 27\n```\n\n**组合继承**弥补了**原型链**和**盗用构造函数**的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了`instanceof`操作符和`isPrototypeOf()`方法**识别合成对象**的能力。\n\n## 4. 原型式继承\n\n`Object.create()`方法接收两个参数：\n\n1. 作为新对象原型的**对象**\n2. 给新对象定义额外属性的**对象**（可选）\n\n原型式继承适用于这种情况，有一个对象，想在它的基础上**再创建一个新对象**。需要把这个对象先传给`Object.create()`，然后再对返回的对象进行适当修改。本质上，`Object.create()`是对传入的对象执行了一次**浅复制**。\n\n```javascript\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('Rob');\n\nconst anotherPerson2 = Object.create(person);\nanotherPerson2.name = 'Linda';\nanotherPerson2.friends.push('Barbie');\n\nconsole.log(person.friends); // [ 'Shelby', 'Court', 'Van', 'Rob', 'Barbie' ]\n```\n\n`person.friends`不仅是`person`的属性，也会跟`anotherPerson`和`anotherPerson2`共享。这里实际上克隆了两个`person`。\n\n`Object.create()`的第二个参数，每个新增属性都通过各自的**描述符**来描述。以这种方式添加的属性会**遮蔽原型对象上的同名属性**。\n\n```javascript\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = Object.create(person, {\n    name: {\n        value: 'Greg',\n    },\n});\nanotherPerson.name = 'Jack';\n\nconsole.log(anotherPerson.name); // Greg\n```\n\n**原型式继承**非常适合不需要单独创建构造函数，但仍然需要在**对象间共享信息**的场合。但属性中包含的**引用值**始终会在**相关对象间共享**，跟使用**原型模式**是一样的。\n\n## 5. 寄生式继承\n\n与原型式继承比较接近的一种继承方式是**寄生式继承**。\n\n```javascript\nfunction createAnother(original) {\n    const clone = Object.create(original); // 通过调用函数创建一个新对象\n    clone.sayHi = function () {\n        // 以某种方式增强这个对象\n        console.log('hi');\n    };\n    return clone; // 返回这个对象\n}\n\nconst person = {\n    name: 'Nicholas',\n    friends: ['Shelby', 'Court', 'Van'],\n};\nconst anotherPerson = createAnother(person);\n\nanotherPerson.sayHi(); // hi\nconsole.log(anotherPerson.name); // Nicholas\nconsole.log(anotherPerson.friends); // [ 'Shelby', 'Court', 'Van' ]\n```\n\n这个例子基于`person`对象返回了一个**新对象**。新返回的`anotherPerson`对象具有`person`的所有**属性**和**方法**，还有一个新方法`sayHi()`。\n\n**寄生式继承**同样适合主要关注对象，而不在乎**类型**和**构造函数**的场景。`Object.create()`函数**不是**寄生式继承所必需的，任何**返回新对象的函数**都可以在这里使用。\n\n## 6. 寄生式组合继承\n\n**组合继承**存在效率问题：**父类构造函数**始终会**被调用两次**，一次在是**创建子类原型**时调用，另一次是在**子类构造函数**中调用。\n\n**寄生式组合继承**的基本模式如下所示：\n\n```javascript\nfunction inheritPrototype(subType, superType) {\n    let prototype = object(superType.prototype); // 创建对象\n    prototype.constructor = subType; // 增强对象\n    subType.prototype = prototype; // 赋值对象\n}\n```\n\n`inheritPrototype()`函数实现了**寄生式组合继承**的核心逻辑。函数接收两个参数：**子类构造函数**和**父类构造函数**。在这个函数内部，第一步是**创建父类原型的副本**。然后，**给返回的`prototype`对象设置`constructor`属性**，解决由于重写原型导致默认`constructor`丢失的问题。最后**将新创建的对象赋值给子类型的原型**。\n\n```javascript\nfunction inheritPrototype(subType, superType) {\n    let prototype = Object.create(superType.prototype); // 创建对象\n    prototype.constructor = subType; // 增强对象\n    subType.prototype = prototype; // 赋值对象\n}\n\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n};\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\ninheritPrototype(SubType, SuperType);\nSubType.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nconst usr = new SubType('Jack', 18);\nusr.sayName(); // Jack\nusr.sayAge(); // 18\nconsole.log(usr.colors); // [ 'red', 'blue', 'green' ]\n```\n\n这里只调用了一次`SuperType`构造函数，避免了`SubType.prototype`上不必要也用不到的属性， 因此可以说这个例子的效率更高。而且，**原型链仍然保持不变**，因此`instanceof`操作符和`isPrototypeOf()`方法正常有效。\n\n**寄生式组合继承**可以算是**引用类型继承**的**最佳模式**。\n\n\n",
      "date": 1627998446000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript 6种继承方式详解",
      "titleEng": "inherit",
      "url": "https://lzxjack.top/post?title=inherit"
    },
    {
      "_id": "8937eaa9611f6b5505876ef228056a29",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "杂七杂八",
      "content": "## 1. 准备工作\n\n首先在 Github 上创建一个公开仓库，放入相关文件，例如：\n\n![](https://img.lzxjack.top:99/20210729104427.png)\n\n点击仓库右侧的`Create a new release`按钮：\n\n![](https://img.lzxjack.top:99/20210729105733.png)\n\n写一个版本号，点击`Publish release`提交。\n\n![](https://img.lzxjack.top:99/20210729105802.png)\n\n## 2. 访问方式\n\n### 1. 根据版本号访问\n\n格式：\n\n```\nhttps://cdn.jsdelivr.net/gh/github用户名/仓库名@版本号/文件目录/文件名\n```\n\n例如：\n\n```\nhttps://cdn.jsdelivr.net/gh/lzxjack/cdn@1.0.0/json/emoji.json\n```\n\n### 2. 省略版本号（不推荐）\n\n省略版本号，直接访问最新的资源，不推荐在**生产环境**中使用。\n\n格式：\n\n```\nhttps://cdn.jsdelivr.net/gh/github用户名/仓库名/文件目录/文件名\n```\n\n例如：\n\n```\nhttps://cdn.jsdelivr.net/gh/lzxjack/cdn/json/emoji.json\n```\n\n### 3. 添加min后缀\n\n将`.min`添加到任何 JS / CSS 文件中以获得压缩的版本。\n\n例如：\n\n```\nhttps://cdn.jsdelivr.net/gh/lzxjack/cdn@1.0.0/js/wow.min.js\n```\n\n### 4. 查看目录列表\n\n在目录的最后添加`/`，可以查看当前目录的文件列表。\n\n格式：\n\n```\nhttps://cdn.jsdelivr.net/gh/github用户名/仓库名@版本号/[文件目录/]\n```\n\n`文件目录/`可以省略，直接访问整个仓库的目录列表。\n\n例如：\n\n```\nhttps://cdn.jsdelivr.net/gh/lzxjack/cdn@1.0.0/\n```\n\n![](https://img.lzxjack.top:99/20210729110508.png)\n\n\n",
      "date": 1627530827000,
      "post": true,
      "tags": ["GitHub", "实用技巧", "CDN", "jsdelivr"],
      "title": "使用jsDelivr加速GitHub的静态资源",
      "titleEng": "cdn",
      "url": "https://lzxjack.top/post?title=cdn"
    }
  ],
  "requestId": "60f031c689223"
}
