{
  "data": [
    {
      "_id": "14139e12612e1de0085150b25f63cd30",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "## 1. Web-Storage简介\n\nWeb Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用`cookie`的问题。\n\nWeb Storage 的第 2 版定义了两个对象：`localStorage`和`sessionStorage`。`localStorage`是永久存储机制，`sessionStorage`是跨会话的存储机制。\n\n这两者的主要区别是：\n\n-   `sessionStorage`对象只存储会话数据，这意味着数据只会存储到浏览器关闭。存储在`sessionStorage`中的数据不受页面刷新影响，可以在浏览器崩溃 并重启后恢复。\n-   存储在`localStorage`中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。`localStorage`数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。\n\n|                      |  sessionStorage  |      localStorage      |\n| :------------------: | :--------------: | :--------------------: |\n|       存储时效       | 浏览器关闭后清除 | 永久存储，直到手动清除 |\n| 刷新页面数据是否丢失 |        否        |           否           |\n\n## 2. sessionStorage\n\n存储在`sessionStorage`对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限，下面是`sessionStorage`的常见用法。\n\n\n（1）存储数据\n\n```javascript\n// 使用方法\nsessionStorage.setItem('name', 'Jack');\n// 使用属性\nsessionStorage.age = '18';\n```\n\n（2）获取数据\n\n```javascript\n// 使用方法\nconst name = sessionStorage.getItem('name');\n// 使用属性\nconst age = sessionStorage.age;\nconsole.log(name, age); // Jack 18\n```\n\n（3）取得给定数值位置的**名称**\n\n```javascript\nconst key = sessionStorage.key(0);\nconsole.log(key); // name\n```\n\n得到的是`键值对`中的`键`。\n\n（4）删除\n\n```javascript\nsessionStorage.removeItem('name'); // 删除名称为name的数据\ndelete sessionStorage.name; // 用delete删除\nsessionStorage.clear(); // 清空所有数据\n```\n\n（4）遍历\n\n```javascript\nsessionStorage.setItem('name', 'Jack');\nsessionStorage.age = '18';\nsessionStorage.weight = '60';\n\nconst res = [];\nfor (let i = 0; i < sessionStorage.length; i++) {\n    // 先通过key()取得名称\n    const key = sessionStorage.key(i);\n    // 再通过名称遍历sessionStorage\n    const val = sessionStorage.getItem(key);\n    res.push(val);\n}\nconsole.log(res); // [\"Jack\", \"18\", \"60\"]\n```\n\n## 3. localStorage\n\n要访问同一个`localStorage`对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。\n\n相关方法与`sessionStorage`相同：\n\n-   存数据\n\n    `localStorage.setItem(key, value)`\n\n-   取数据\n\n    `localStorage.getItem(key)`\n\n-   取得名称\n\n    `localStorage.key(index)`\n\n-   删除\n\n    `localStorage.removeItem(key)`\n\n    `localStorage.clear()`\n\n## 4. 存储事件\n\n对于`sessionStorage`和`localStorage`上的任何更改都会触发`storage`事件，但`storage`事件**不会区分**这两者。\n\n这个事件的事件对象有如下 4 个属性：\n\n-   `domain`：存储变化对应的域\n-   `key`：被设置或删除的键\n-   `newValue`：键被设置的新值，若键被删除则为`null`\n-   `oldValue`：键变化之前的值\n\n## 5. 限制\n\n不同浏览器给`localStorage`和`sessionStorage`设置了不同的空间限制，但大多数会限制为每个源`5MB`。\n\n`sessionStorage`和`localStorage`类型只能存储**字符串**。非字符串数据在存储之前会**自动转换为字符串**。同样，获得数据时，只能得到**字符串**。\n\n想要获取对象时，可以使用`JSON.parse()`方法将字符串转化为对象格式：\n\n```javascript\nJSON.parse(localStorage.getItem('xxxxx')).content.email;\n```\n\n\n",
      "date": 1621235734000,
      "post": true,
      "tags": ["浏览器"],
      "title": "客户端存储sessionStorage、localStorage详解",
      "titleEng": "storage"
    },
    {
      "_id": "2d44d6c26126497806f338f31f489c41",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "JavaScript 常见问题",
      "content": "## 1. JSON对象→JSON字符串\n\n`JSON.stringify()`\n\n```javascript\nconst obj = {\n    id: '0',\n    name: 'Jack',\n    age: '18',\n};\n\nconst str = JSON.stringify(obj);\nconsole.log(str); // {\"id\":\"0\",\"name\":\"Jack\",\"age\":\"18\"}\n```\n\n![](https://img.lzxjack.top:99/20210506212103.png)\n\n## 2. JSON字符串→JSON对象\n\n`JSON.parse()`\n\n```javascript\nconst str = '{\"id\":\"0\",\"name\":\"Jack\",\"age\":\"18\"}';\n\nconst obj = JSON.parse(str);\nconsole.log(obj);\n```\n\n![](https://img.lzxjack.top:99/20210506212155.png)\n\n\n",
      "date": 1620308681000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript JSON对象和字符串互相转化",
      "titleEng": "obj-json"
    },
    {
      "_id": "8937eaa9612e116b078819df29846ab0",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 实现效果\n\n![](https://img.lzxjack.top:99/20210430144621.gif)\n\n上面是`Count`组件，下面是`Flag`组件。\n\n`Count`组件中，点击`点击+1`按钮，数值加一，点击`清零`按钮，数值清零，同时数值传递给`Flag`组件同步显示。\n\n`Flag`组件中，点击`login`可以切换为`true`，点击`logout`切换为`false`，同时将状态传递给`Count`组件同步显示。\n\n## 2. 安装依赖包\n\n```powershell\nnpm install react-redux redux redux-thunk redux-devtools-extension\n```\n\n## 3. 文件结构\n\n![](https://img.lzxjack.top:99/20210430150047.png)\n\n使用了`redux`，需要在`UI组件`外套一层`容器组件`。由于是父子关系，`容器组件`通过`props`向里层的`UI组件`传递参数，将`容器组件`放在`containers`文件夹下。\n\n使用`redux`，需要单独创建`redux`文件夹，包括`actions`文件夹和`reducers`文件夹，还有向外暴露常量的`constant.js`和`store.js`。\n\n## 4. 详细代码\n\n### 1. Count组件\n\n（1）组件定义\n\n通过`class`定义的是`UI组件`，向外暴露的是`容器组件`，`容器组件`通过`props`向`UI组件`传递**状态**和**方法**。\n\n```javascript\n// src/containers/Count/index.jsx\nimport React, { Component, Fragment } from 'react';\nimport { connect } from 'react-redux';\nimport { add, clear } from '../../redux/actions/count';\n\n// UI组件\nclass Count extends Component {\n    add = () => {\n        // 通知redux\n        this.props.add(1);\n    };\n    clear = () => {\n        this.props.clear();\n    };\n    render() {\n        return (\n            <Fragment>\n                <h2>当前求和为：{this.props.count}</h2>\n                <h3>当前Flag：{this.props.flag ? 'true' : 'false'}</h3>\n                <button onClick={this.add}>点击+1</button>\n                <button onClick={this.clear}>清零</button>\n            </Fragment>\n        );\n    }\n}\n\n// 暴露容器组件\nexport default connect(\n    // 1.状态\n    state => ({ count: state.sum, flag: state.flagState }),\n    // 2.方法\n    { add, clear }\n)(Count);\n```\n\n（2）创建`action`\n\n该文件用于创建`action`对象。\n\n```javascript\n// src/redux/actions/count.js\n// 为Count组件创建action对象\n\n// 引入常量\nimport { ADD, CLEAR } from '../constant';\n\n// 创建加一action对象的函数\nexport const add = data => ({\n    type: ADD,\n    data,\n});\n\n// 创建清零action对象的函数\nexport const clear = data => ({\n    type: CLEAR,\n    data,\n});\n```\n\n（3）`reducer`\n\n该文件用于判断`type`的类型，加工数据。\n\n```javascript\n// src/redux/reducers/count.js\n// 为Count组件创建一个reducer\n// reducer接收两个参数：之前状态的preState，动作对象action\n\nimport { ADD, CLEAR } from '../constant.js';\n\n// 设定初始状态\nconst initState = 0;\n\nexport default function addReducer(preState = initState, action) {\n    // 从action中获取type和data\n    const { type, data } = action;\n    // 根据type决定如何加工数据\n    switch (type) {\n        case ADD:\n            return preState + data;\n        case CLEAR:\n            return 0;\n        // 初始化动作\n        default:\n            return preState;\n    }\n}\n```\n\n### 2. Flag组件\n\n（1）组件定义\n\n```javascript\n// src/containers/Flag/index.jsx\nimport React, { Component, Fragment } from 'react';\nimport { connect } from 'react-redux';\nimport { login, logout } from '../../redux/actions/flag';\n\nclass Flag extends Component {\n    login = () => {\n        this.props.login();\n    };\n    logout = () => {\n        this.props.logout();\n    };\n\n    render() {\n        return (\n            <Fragment>\n                <h2>当前Flag：{this.props.flag ? 'true' : 'false'}</h2>\n                <h3>当前求和为：{this.props.count}</h3>\n                <button onClick={this.login}>login</button>\n                <button onClick={this.logout}>logout</button>\n            </Fragment>\n        );\n    }\n}\n\nexport default connect(state => ({ flag: state.flagState, count: state.sum }), { login, logout })(\n    Flag\n);\n```\n\n（2）创建`action`\n\n```javascript\n// src/redux/actions/flag.js\n// 为Flag组件创建action对象\n\n// 引入常量\nimport { LOGIN, LOGOUT } from '../constant';\n\n// 创建加一action对象的函数\nexport const login = data => ({\n    type: LOGIN,\n    data,\n});\n\n// 创建加一action对象的函数\nexport const logout = data => ({\n    type: LOGOUT,\n    data,\n});\n```\n\n（3）`reducer`\n\n```javascript\n// src/redux/reducers/flag.js\n//  reducer接收两个参数：之前状态的preState，动作对象action\n\nimport { LOGIN, LOGOUT } from '../constant.js';\n\n// 设定初始状态\nconst initState = false;\n\nexport default function addReducer(preState = initState, action) {\n    const { type } = action;\n    switch (type) {\n        case LOGIN:\n            return true;\n        case LOGOUT:\n            return false;\n        default:\n            return preState;\n    }\n}\n```\n\n### 3. 汇总所有reducer\n\n所有的组件的`reducer`要汇总到一个文件中，并向外暴露`redux`中存放的状态**对象**。\n\n```javascript\n// src/redux/reducers/index.js\n// 汇总所有的reducer\n\nimport { combineReducers } from 'redux';\n\nimport sum from './count';\nimport flagState from './flag';\n\nexport default combineReducers({\n    sum,\n    flagState,\n});\n```\n\n### 4. 常量文件\n\n```javascript\n// src/redux/constant.js\nexport const LOGIN = 'login';\nexport const LOGOUT = 'logout';\n\nexport const ADD = 'add';\nexport const CLEAR = 'clear';\n```\n\n### 5. store\n\n引入汇总后的`rudecer`，暴露`store`。\n\n```javascript\n// src/redux/store.js\n// 整个文档只有一个store对象\n\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport allRudecers from './reducers';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\n// 暴露store\nexport default createStore(allRudecers, composeWithDevTools(applyMiddleware(thunk)));\n```\n\n### 6. 项目入口文件index.js\n\n引入`store`，并将`<App />`用`<Provider store={store}></Provider>`包裹，这样`<App />`下所有的组件都能接收到`store`了。\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.jsx';\nimport store from './redux/store';\nimport { Provider } from 'react-redux';\n\nReactDOM.render(\n    // Provider包裹App，目的：让App所有的后代容器组件都能接收到store\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n```\n\n\n",
      "date": 1619770988000,
      "post": true,
      "tags": ["React"],
      "title": "使用 react-redux 实现组件的状态管理和数据通信",
      "titleEng": "react-redux"
    },
    {
      "_id": "2d44d6c26128f84b077031fb1532bfb8",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. 为何使用react-router-config\n\n在 React 中使用路由，一般使用`react-router-dom`中的`NavLink`和`Route`，使用`NavLink`编写路由链接，使用`Route`注册路由：\n\n```javascript\nimport { NavLink, Route } from 'react-router-dom';\n...\n\n{/* 路由链接 */}\n<NavLink to=\"/home\">Home</NavLink>\n<NavLink to=\"/about\">About</NavLink>\n\n{/* 注册路由 */}\n<Route path=\"/home\" component={Home} />\n<Route path=\"/about\" component={About} />\n```\n\n`注册路由`部分写在相应的组件中，但一旦路由组件过多，路由嵌套关系复杂，就会很容易搞清楚路由组件之间的关系。\n\n`react_router_config`可以很好地解决这个问题，`react_router_config`将所有的路由注册写在同一个`.js`文件中，各个路由中间的嵌套关系也能清晰地得到，这对于复杂的路由管理来说，十分方便。\n\n## 2. react-router-config的基本使用\n\n首先安装`react_router_config`库。\n\n```powershell\nyarn add react_router_config\n```\n\n在项目`根目录`下创建`router.js`文件，将所需的路由数组形式，并向外暴露：\n\n```javascript\nimport Home from './components/Home';\nimport User from './components/User';\n\nconst routes = [\n    {\n        path: '/home',\n        component: Home,\n    },\n    {\n        path: '/user',\n        component: User,\n    },\n];\n\nexport default routes;\n```\n\n需要开启路由的组件：\n\n```javascript\nimport React, { Component } from 'react';\nimport { renderRoutes } from 'react-router-config';\nimport { NavLink } from 'react-router-dom';\nimport routes from './router.js';\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                {/* 路由链接 */}\n                <NavLink to=\"/home\">Home</NavLink>\n                <NavLink to=\"/user\">User</NavLink>\n\n                {/* 使用react-router-config中的renderRoutes方法 */}\n                {renderRoutes(routes)}\n            </div>\n        );\n    }\n}\n```\n\n这样，就能够实现路由的基本功能了。\n\n## 3. 嵌套路由\n\n`User`组件中嵌套路由组件`A`和`B`，`B`组件中嵌套路由`C`和`D`，修改`router.js`文件，子路由通过`children`继续定义下去即可：\n\n```javascript\nimport Home from './components/Home';\nimport User from './components/User';\nimport A from './components/User/A';\nimport B from './components/User/B';\nimport C from './components/User/B/C';\nimport D from './components/User/B/D';\n\nconst routes = [\n    {\n        path: '/home',\n        component: Home,\n    },\n    {\n        path: '/user',\n        component: User,\n        children: [\n            {\n                path: '/user/a',\n                component: A,\n            },\n            {\n                path: '/user/b',\n                component: B,\n                children: [\n                    {\n                        path: '/user/b/c',\n                        component: C,\n                    },\n                    {\n                        path: '/user/b/d',\n                        component: D,\n                    },\n                ],\n            },\n        ],\n    },\n];\n\nexport default routes;\n```\n\n`User`组件：\n\n```javascript\nimport React, { Component } from 'react';\nimport { renderRoutes } from 'react-router-config';\nimport { NavLink } from 'react-router-dom';\n\nexport default class User extends Component {\n    componentDidMount() {\n        console.log(this.props);\n    }\n    render() {\n        return (\n            <div>\n                User <hr />\n                <NavLink to=\"/user/a\">A</NavLink>\n                <NavLink to=\"/user/b\">B</NavLink>\n\n                {/* 需要用props传递嵌套的组件 */}\n                {renderRoutes(this.props.route.children)}\n            </div>\n        );\n    }\n}\n```\n\n这里写了一个`componentDidMount()`勾子，看一下组件挂载后打印的内容：\n\n![](https://img.lzxjack.top:99/20210429145310.png)\n\n可以看到，可以通过`this.props.route.children`得到子路由的注册信息，所以在使用`renderRoutes`方法时，需要传递`this.props.route.children`。\n\n`B`组件：\n\n```javascript\nimport React, { Component } from 'react';\nimport { renderRoutes } from 'react-router-config';\nimport { NavLink } from 'react-router-dom';\n\nexport default class B extends Component {\n    render() {\n        return (\n            <div>\n                BBB\n                <hr />\n                <NavLink to=\"/user/b/c\">C</NavLink>\n                <NavLink to=\"/user/b/d\">D</NavLink>\n                {renderRoutes(this.props.route.children)}\n            </div>\n        );\n    }\n}\n```\n\n## 4. 路由鉴权\n\n有时候一个组件并不希望所有用户都能直接访问到，仅让登录过的用户可以进行访问，这时候就需要路由鉴权。通过判断的条件，来返回指定的路由组件。\n\n修改`react_router_config`中`renderRoutes()`函数的源码，或者也可以直接自己定义一个`renderRoutes()`：\n\n```javascript\nimport React from 'react';\nimport { Route, Redirect, Switch } from 'react-router-dom';\n\nconst renderRoutes = (routes, authed, authPath = '/login', extraProps = {}, switchProps = {}) =>\n    routes ? (\n        <Switch {...switchProps}>\n            {routes.map((route, i) => (\n                <Route\n                    key={route.key || i}\n                    path={route.path}\n                    exact={route.exact}\n                    strict={route.strict}\n                    render={props => {\n                        if (!route.requiresAuth || authed || route.path === authPath) {\n                            return <route.component {...props} {...extraProps} route={route} />;\n                        }\n                        return (\n                            <Redirect\n                                to={{ pathname: authPath, state: { from: props.location } }}\n                            />\n                        );\n                    }}\n                />\n            ))}\n        </Switch>\n    ) : null;\n\nexport default renderRoutes;\n```\n\n若`User`组件不希望被未登录的用户访问到，修改`User`组件：\n\n```javascript\nimport React, { Component } from 'react';\n// import { renderRoutes } from 'react-router-config';\n// 引入自己的renderRoutes\nimport renderRoutes from './utils/renderRoutes';\nimport { NavLink } from 'react-router-dom';\nimport routes from './router.js';\n\nconst authed = false; // false表示未登录\nconst authPath = '/home'; // 需要跳转到的路径\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                {/* 路由链接 */}\n                <NavLink to=\"/home\">Home</NavLink>\n                <NavLink to=\"/user\">User</NavLink>\n\n                {/* {renderRoutes(routes)} */}\n                {renderRoutes(routes, authed, authPath)}\n            </div>\n        );\n    }\n}\n```\n\n同时，还需要修改`router.js`文件的内容，在**需要权限**才能访问的地方加上`requiresAuth: true`，其他加上`requiresAuth: false`即可。\n\n```javascript\nimport Home from './components/Home';\nimport User from './components/User';\nimport A from './components/User/A';\nimport B from './components/User/B';\nimport C from './components/User/B/C';\nimport D from './components/User/B/D';\n\nconst routes = [\n    {\n        path: '/home',\n        component: Home,\n        requiresAuth: false,\n    },\n    {\n        path: '/user',\n        component: User,\n        requiresAuth: true,\n        // requiresAuth: false,\n        children: [\n            {\n                path: '/user/a',\n                component: A,\n                requiresAuth: false,\n            },\n            {\n                path: '/user/b',\n                component: B,\n                // requiresAuth: false,\n                requiresAuth: true,\n                children: [\n                    {\n                        path: '/user/b/c',\n                        component: C,\n                        requiresAuth: false,\n                    },\n                    {\n                        path: '/user/b/d',\n                        component: D,\n                        requiresAuth: false,\n                    },\n                ],\n            },\n        ],\n    },\n];\n\nexport default routes;\n```\n\n这样，当用户未登录时，若访问`/user`，会自动跳转回`/home`。",
      "date": 1619685268000,
      "post": true,
      "tags": ["React"],
      "title": "React 集中式路由管理 + 路由鉴权",
      "titleEng": "react-router-config"
    },
    {
      "_id": "14139e12611f3e75060f4a726cdac115",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "在 JavaScript 中操作数组，可以使用`for`、`while`循环，也可以使用数组数组迭代方法，更方便地完成。\n\n## 1. forEach\n\n`forEach()`方法**没有返回值**，运行时为每个数组元素调用一次`回调函数`。\n\n```javascript\narr.forEach(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。如果给`forEach`传递了第二个参数，`回调函数`里的`this`将指向这个参数。如果没有传入第二个参数，则`this`指向全局对象（在浏览器是为`window`）。\n\n```javascript\nconst arr = [1, 2, 3, 4, 5];\n\narr.forEach((value, index, array) => {\n    console.log(value);\n    console.log(index);\n});\n```\n\n## 2. filter\n\n对数组使用`filter()`方法后，返回**过滤后**的新数组。\n\n```javascript\narr.filter(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。\n\n```javascript\nconst arr = [0, 1, 2, 3, 4];\n\nconst arr1 = arr.filter((value, index, array) => {\n    // 将大于2的元素取出，放入新数组并返回\n    return value > 2;\n});\nconsole.log(arr1); // [ 3, 4 ]\n\nconst arr2 = arr.filter((value, index, array) => {\n    // 将不大于2的元素取出，放入新数组并返回\n    return !(value > 2);\n});\nconsole.log(arr2); // [ 0, 1, 2 ]\n```\n\n## 3. some\n\n`some()`方法是只要数组中的某个值，符合给定的判断条件就返回`true`；否则，返回`false`。\n\n```javascript\narr.some(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。\n\n```javascript\nconst flag = arr.some((value, index, array) => {\n    // 判断arr中是否有>2的元素\n    return value > 2;\n});\nconsole.log(flag); // true\n```\n\n## 4. every\n\n`every()`方法与`some()`方法类似。\n\n`every()`方法是数组中的所有值都符合给定的判断条件的时候才会返回`true`，否则就返回`false`。\n\n```javascript\narr.every(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。\n\n```javascript\nconst arr = [0, 1, 2, 3, 4];\n\nconst flag = arr.every((value, index, array) => {\n    // 判断arr中所有元素是否都大于2\n    return value > 2;\n});\nconsole.log(flag); // false\n```\n\n## 5. find / findIndex\n\n### 1. find\n\n`find()`方法用于找出第一个符合条件的数组元素。所有数组元素依次执行回调函数，直到找出第一个返回值为`true`的元素，然后返回该元素。如果没有符合条件的元素，则返回`undefined`。\n\n```javascript\narr.find(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。\n\n```javascript\nconst arr = [2, 4, 6, 8, 10];\n\nconst num = arr.find((value, index, array) => {\n    // 返回arr中第一个大于5的元素\n    return value > 5;\n});\nconsole.log(num); // 6\n```\n\n### 2. findIndex\n\n`findIndex()`与`find()`方法类似，但`findIndex()`返回的是第一个返回值为`true`的元素索引。如果所有元素都不符合条件，则返回`-1`。\n\n```javascript\narr.findIndex(callback, [thisArg]);\n```\n\n该方法需要传入一个回调函数`callback`，函数参数：\n\n-   项目值`value`\n-   项目索引`index`\n-   数组本身`array`\n\n`thisArg`为可选参数，表示执行`callback`时的 `this` 的值。\n\n```javascript\nconst arr = [2, 4, 6, 8, 10];\n\nconst num = arr.findIndex((value, index, array) => {\n    // 返回arr中第一个大于5的元素索引\n    return value > 5;\n});\nconsole.log(num); // 2\n```\n\n## 6. reduce / reduceRight\n\n### 1. reduce\n\n```javascript\narray.reduce(callback, [initialValue]);\n```\n\n回调函数依次接收 4 个参数：\n\n-   `accumulator`上一次调用回调返回的值，或者是提供的初始值（`initialValue`）\n-   `currentValue`数组中正在处理的元素\n-   `currentIndex`数组中正在处理的元素索引，如果提供了`initialValue` ，从 0 开始；否则从 1 开始。\n-   `array`数组对象本身\n\n第二个参数`initialValue`是可选的，是传递给函数的初始值。如果没有提供初始值，则将使用数组中的**第一个元素**。 在没有初始值的空数组上调用`reduce`将报错。\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\nconst sum1 = arr.reduce((a, b) => {\n    return a + b;\n});\n// 过程：((1+2)+3)+4=10\nconsole.log(sum1); // 10\n\nconst sum2 = arr.reduce((a, b) => {\n    return a - b;\n}, 4);\n// 过程：(((4-1)-2)-3)-4=-6\nconsole.log(sum2); // -6\n```\n\n### 2. reduceRight\n\n`reduceRight()`方法的功能和`reduce()`功能是一样的，不同的是`reduceRight()`从数组的末尾向前将数组中的数组项做累加。\n\n```javascript\nconst arr = [1, 2, 3];\n\nconst sum1 = arr.reduceRight((a, b) => {\n    return a - b;\n}, 1);\n// 过程：((1-3)-2)-1=-5\nconsole.log(sum1); // -5\n```\n\n",
      "date": 1619439079000,
      "post": true,
      "tags": ["JavaScript", "数组"],
      "title": "JavaScript 数组迭代方法笔记",
      "titleEng": "arr-func"
    },
    {
      "_id": "2d44d6c26128f5d2076fc88175165ff7",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. setState\n\n使用`setState`更新状态有 2 种写法。\n\n`对象式`是`函数式`的简写方式（语法糖）。\n\n**使用原则（非必须）：**\n\n-   新状态**不依赖于**原状态 ===> 使用`对象式`\n-   新状态**依赖于**原状态 ===> 使用`函数式`\n-   如果需要在`setState()`执行后获取最新的状态数据，要在`callback`函数中读取\n\n### 1. 对象式\n\n```javascript\nsetState(stateChange, [callback]);\n```\n\n-   `stateChange`为状态改变对象（该对象可以体现出状态的更改）\n-   `callback`是可选的回调函数, 它在状态更新完毕、界面也更新后（`render`调用后）才被调用\n-   状态的更新是`异步`的，如果想要查看`更新后的状态`，需要写在`callback`中\n\n```javascript\nconst { count } = this.state;\nthis.setState({ count: count + 1 }, () => {\n    console.log(this.state.count);\n});\n```\n\n### 2. 函数式\n\n```javascript\nsetState(updater, [callback]);\n```\n\n-   `updater`为返回`stateChange`对象的函数，可以接收到`state`和`props`\n\n-   `callback`是可选的回调函数, 它在状态更新完毕、界面也更新后（`render`调用后）才被调用\n\n```\nthis.setState((state, props) => ({ count: state.count + 1 }));\n```\n\n## 2. 路由组件的lazyLoad\n\n通过 React 的`lazy`函数配合`import()`函数动态加载路由组件，使路由组件代码分开打包。\n\n```javascript\nimport Loading from './Loading';\nconst Home = lazy(() => import('./Home'));\nconst About = lazy(() => import('./About'));\n```\n\n通过`<Suspense>`标签指定在加载得到路由打包文件前显示一个自定义`loading界面`。\n\n```javascript\n<Suspense fallback={<Loading />}>\n    {/* 注册路由 */}\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/home\" component={Home} />\n</Suspense>\n```\n\n## 3. Hooks\n\n`Hook`是 React 16.8.0 版本增加的新特性，可以在`函数组件`中使用`state`以及其他的 React 特性。下面介绍三个常用的`Hook`：\n\n-   State Hook：`React.useState()`\n-   Effect Hook：`React.useEffect()`\n-   Ref Hook：`React.useRef()`\n\n### 1. State-Hook\n\nState Hook 让函数组件也可以有`state`状态，并进行状态数据的读写操作。\n\n```javascript\nconst [xxx, setXxx] = React.useState(initValue); // 解构赋值\n```\n\n-   `useState()`\n\n    参数：第一次初始化指定的值在内部作缓存\n\n    返回值：包含 2 个元素的数组，第 1 个为内部当前状态值，第 2 个为更新状态值的函数\n\n-   `setXxx()`2 种写法\n\n    `setXxx(newValue)`：参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值\n\n    `setXxx(value => newValue)`：参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值\n\n```javascript\nfunction Demo() {\n    const [count, setCount] = React.useState(0);\n\n    //加的回调\n    function add() {\n        // 第一种写法\n        // setCount(count + 1);\n        // 第二种写法\n        setCount(count => count + 1);\n    }\n\n    return (\n        <div>\n            <h2>当前求和为：{count}</h2>\n            <button onClick={add}>点我+1</button>\n        </div>\n    );\n}\n```\n\n### 2. Effect-Hook\n\nEffect Hook 可以在函数组件中执行`副作用操作`（用于模拟类组件中的生命周期钩子）。\n\nReact 中的`副作用操作`：\n\n-   发`ajax`请求数据获取\n-   设置订阅 / 启动定时器\n-   手动更改真实 DOM\n\n```javascript\nuseEffect(() => {\n    // 在此可以执行任何带副作用操作\n    // 相当于componentDidMount()\n    return () => {\n        // 在组件卸载前执行\n        // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n        // 相当于componentWillUnmount()\n    };\n}, [stateValue]); // 监听stateValue\n// 如果省略数组，则检测所有的状态，状态有更新就又调用一次回调函数\n// 如果指定的是[], 回调函数只会在第一次render()后执行\n```\n\n可以把`useEffect()`看做如下三个函数的组合：\n\n-   `componentDidMount()`\n-   `componentDidUpdate()`\n-   `componentWillUnmount() `\n\n```javascript\nfunction Demo() {\n    const [count, setCount] = React.useState(0);\n\n    React.useEffect(() => {\n        let timer = setInterval(() => {\n            setCount(count => count + 1);\n        }, 500);\n        console.log('@@@@');\n        return () => {\n            clearInterval(timer);\n        };\n    }, [count]);\n    // 检测count的变化，每次变化，都会输出'@@@@'\n\n    //加的回调\n    function add() {\n        // 第一种写法\n        // setCount(count + 1);\n        // 第二种写法\n        setCount(count => count + 1);\n    }\n\n    // 卸载组件的回调;\n    function unmount() {\n        ReactDOM.unmountComponentAtNode(document.getElementById('root'));\n    }\n\n    return (\n        <div>\n            <h2>当前求和为：{count}</h2>\n            <button onClick={add}>点我+1</button>\n            <button onClick={unmount}>卸载组件</button>\n        </div>\n    );\n}\n```\n\n### 3. Ref-Hook\n\nRef Hook 可以在函数组件中存储/查找组件内的标签或任意其它数据。\n\n保存标签对象，功能与`React.createRef()`一样\n\n```javascript\nconst refContainer = useRef();\n```\n\n```javascript\nfunction Demo() {\n    const myRef = React.useRef();\n\n    //提示输入的回调\n    function show() {\n        alert(myRef.current.value);\n    }\n\n    return (\n        <div>\n            <input type=\"text\" ref={myRef} />\n        </div>\n    );\n}\n```\n\n## 4. Fragment\n\n使用`<Fragment><Fragment>`后，可以不用必须有一个真实的 DOM 根标签了。\n\n```javascript\nimport React, { Component, Fragment } from 'react';\n\nexport default class Demo extends Component {\n    render() {\n        return (\n            <Fragment key={1}>\n                <input type=\"text\" />\n                <input type=\"text\" />\n            </Fragment>\n        );\n    }\n}\n```\n\n使用空标签`<></>`包裹也可以，他们的区别如下：\n\n-   `<Fragment><Fragment>`：可以接收`key`属性，不能接收其他属性\n-   `<></>`：不能接受属性\n\n## 5. Context\n\n一种组件间通信方式，常用于`祖组件`与`后代组件`间通信。\n\n在组件外部创建`Context`容器对象：\n\n```javascript\nconst XxxContext = React.createContext();\n```\n\n渲染子组时，外面包裹`xxxContext.Provider`，通过`value`属性给后代组件传递数据：\n\n```javascript\n<XxxContext.Provider value={数据}>\n    子组件\n</XxxContext.Provider>\n```\n\n后代组件读取数据：\n\n方式（1），仅适用于`类组件`：\n\n```javascript\nstatic contextType = xxxContext  // 声明接收context\nconsole.log(this.context); // 读取context中的value数据\n```\n\n方式（2），`函数组件`与`类组件`都可以：\n\n```javascript\n<XxxContext.Consumer>\n    {value => `${value.username},年龄是${value.age}`}\n</XxxContext.Consumer>\n```\n\n## 6. 组件优化\n\nReact 中`Component`组件的2个问题：\n\n1. 只要执行`setState()`，即使**不改变状态数据**，组件也会重新`render()`\n2. 只要当前组件重新`render`，就会自动重新`render`子组件，即使子组件没有发生任何变化，这导致页面更新的效率低下\n\n效率高的做法：\n\n- 只有当组件的`state`或`props`数据发生改变时才重新`render()`。\n\n问题的原因：\n\n- `Component`中的`shouldComponentUpdate()`总是返回`true`\n\n解决办法：\n\n- 重写`shouldComponentUpdate()`方法\n\n  比较新旧`state`或`props`数据，如果有变化才返回`true`，否则返回`false`\n\n- 使用`PureComponent`组件代替`Component`组件\n\n  `PureComponent`重写了`shouldComponentUpdate()`，只有`state`或`props`数据有变化才返回`true`\n\n  只是进行`state`和`props`数据的`浅比较`，如果只是数据对象内部数据变了，返回`false`\n\n  所以不要直接修改`state`数据，而是要**产生新数据**\n\n## 7. render-props\n\n向组件内部动态传入带内容的结构（标签）。\n\n### 1. children-props\n\n```javascript\n<A>\n    <B>xxxx</B>\n</A>\n```\n\n`B`组件通过`this.props.children`获取便签中的数据。\n\n但是`B`组件获得不到`A`组件内的数据。\n\n### 2. render-props\n\n```javascript\nexport default class Parent extends Component {\n    render() {\n        return (\n            <div className=\"parent\">\n                <h3>我是Parent组件</h3>\n                <A render={name => <B name={name} />} />\n            </div>\n        );\n    }\n}\n\nclass A extends Component {\n    state = { name: 'tom' };\n    render() {\n        console.log(this.props);\n        const { name } = this.state;\n        return (\n            <div className=\"a\">\n                <h3>我是A组件</h3>\n                {this.props.render(name)}\n            </div>\n        );\n    }\n}\n\nclass B extends Component {\n    render() {\n        console.log('B--render');\n        return (\n            <div className=\"b\">\n                <h3>我是B组件,{this.props.name}</h3>\n            </div>\n        );\n    }\n}\n```\n\n相当于`A`组件内部写了个插槽，可以在`Parent`组件中任意更改向插槽中插入的组件，并传递`A`组件的数据。\n\n## 8. 错误边界\n\n用来捕获后代组件错误，渲染出备用页面。\n\n只能捕获后代组件`生命周期`产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误。\n\n`getDerivedStateFromError` + `componentDidCatch`\n\n```javascript\nexport default class Parent extends Component {\n    state = {\n        hasError: '', // 用于标识子组件是否产生错误\n    };\n\n    //当Parent的子组件出现报错时候，会触发getDerivedStateFromError调用，并携带错误信息\n    static getDerivedStateFromError(error) {\n        console.log('@@@', error);\n        // 返回状态对象\n        return { hasError: error };\n    }\n\n    componentDidCatch(error, info) {\n        // 统计页面的错误。发送请求发送到后台去\n        console.log(error, info);\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>我是Parent组件</h2>\n                {this.state.hasError ? <h2>当前网络不稳定，稍后再试</h2> : <Child />}\n            </div>\n        );\n    }\n}\n```\n\n## 9. 组件间通信方式总结\n\n通信方式：\n\n1. `props`\n\n   父子间通过`props`\n\n   `children props`\n\n   `render props`\n\n2. 消息订阅-发布\n\n   `pubs-sub`等\n\n3. 集中式管理\n\n   `redux`等\n\n4. `conText`\n\n   生产者-消费者模式\n\n组件之间的关系：\n\n1. 父子组件 —— `props`\n2. 兄弟组件（非嵌套组件） —— 消息订阅-发布、集中式管理\n3. 祖孙组件（跨级组件） —— 消息订阅-发布、集中式管理、`conText`",
      "date": 1619000985000,
      "post": true,
      "tags": ["React"],
      "title": "React 学习笔记 —— 扩展内容",
      "titleEng": "react-extension"
    },
    {
      "_id": "2d44d6c26128f89407703d23425974c3",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "React 学习笔记",
      "content": "## 1. params\n\n- 路由链接（携带参数）\n\n  `<Link to=\"/demo/test/tom/18\">详情</Link>`\n\n```javascript\n<Link to={`/home/message/detail/${msgObj.id}/${msgObj.title}`}>{msgObj.title}</Link>\n```\n\n- 注册路由（声明接收）\n\n  `<Route path=\"/demo/test/:name/:age\" component={Test} />`\n\n```javascript\n<Route path=\"/home/message/detail\" component={Detail} />\n```\n\n- 接收参数\n\n  `this.props.match.params`\n\n```javascript\nconst { id, title } = this.props.match.params;\n```\n\n## 2. search\n\n- 路由链接（携带参数）\n\n  `<Link to=\"/demo/test?name=tom&age=18\">详情</Link>`\n\n```javascript\n<Link to={`/home/message/detail/?id=${msgObj.id}&title=${msgObj.title}`}>{msgObj.title}</Link>\n```\n\n- 注册路由（无需声明，正常注册即可）\n\n  `<Route path=\"/demo/test\" component={Test} />`\n\n```javascript\n<Route path=\"/home/message/detail\" component={Detail} />\n```\n\n-   接收参数\n\n    `this.props.location.search`\n    \n    获取到的`search`是`urlencoded`编码字符串，需要借助`querystring`解析\n\n```javascript\nimport qs from 'querystring';\nconst { search } = this.props.location;\nconst { id, title } = qs.parse(search.slice(1));\n```\n\n## 3. state\n\n- 路由链接（携带参数）\n\n  `<Link to={{ pathname: '/demo/test', state: { name: 'tom', age: 18 } }}>详情</Link>`\n\n```javascript\n<Link to={{ pathname: '/home/message/detail', state: { id: msgObj.id, title: msgObj.title } }}>{msgObj.title}</Link>\n```\n\n- 注册路由（无需声明，正常注册即可）\n\n  `<Route path=\"/demo/test\" component={Test} />`\n\n```javascript\n<Route path=\"/home/message/detail\" component={Detail} />\n```\n\n- 接收参数\n\n  `this.props.location.state`\n\n```javascript\nconst { id, title } = this.props.location.state || {};\n```\n\n\n",
      "date": 1618816572000,
      "post": true,
      "tags": ["React"],
      "title": "React-Router 传递参数",
      "titleEng": "react-router-props"
    },
    {
      "_id": "8937eaa9612e2053078b1bff30163678",
      "_openid": "9bf44da2dbb8473da1fcf4f591cb82ff",
      "classes": "前端基础",
      "content": "JavaScript 中的`this`代表的是`当前行为执行的主体`，在 JavaScript 中主要研究的都是函数中的`this`，但并不是说只有在函数里才有`this`，`this`实际上是**在函数被调用时发生的绑定**，它指向什么完全取决于**函数在哪里被调用**。\n\n## 1. 函数调用\n\n函数执行时首先看函数名前面是否有`.`，若有，`.`前面是谁，`this`就是谁。没有的话`this`就是`window`。\n\n```javascript\nfunction fn() {\n    console.log(this);\n}\n\nlet obj = { fn: fn };\n\nfn(); // this -> window\nobj.fn(); // this -> obj\n\nfunction sum() {\n    fn();\n}\n\nsum(); // this -> window\n\nlet obj2 = {\n    sum: function () {\n        console.log(this);\n        fn();\n    },\n};\n\nobj2.sum();\n// sum中的this -> obj2\n// sum中fn中的this -> window\n```\n\n## 2. 自执行函数\n\n自执行函数中的`this`永远是`window`。\n\n```javascript\n(function () {\n    console.log(this); //this -> window\n})();\n~(function () {\n    console.log(this); //this -> window\n})();\n```\n\n## 3. 事件绑定\n\n-   DOM 零级事件绑定\n\n```javascript\noDiv.onclick = function () {\n    // this -> oDiv\n};\n```\n\n-   DOM 二级事件绑定\n\n```javascript\noDiv.addEventListener(\n    'click',\n    function () {\n        // this -> oDiv\n    },\n    false\n);\n```\n\n-   在`IE6~8`下使用`attachEvent`，默认的`this`就是指的`window`对象\n\n```javascript\noDiv.attachEvent('click', function () {\n    // this -> window\n});\n```\n\n## 4. 构造函数\n\n在构造函数模式中，类中（函数体中）出现的`this.xxx=xxx`中的`this`是当前类的一个实例。\n\n```javascript\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.do = function () {\n        console.log(this);\n    };\n}\nvar p1 = new Person('Jack', 18);\np1.do(); // this -> p1实例对象\n```\n\n类中某一个属性值（方法），方法中的`this`需要看方法执行的时候，前面是否有`.`，才能知道`this`是谁。\n\n```javascript\nfunction Fn() {\n    this.x = 100;\n    this.getX = function () {\n        console.log(this.x);\n    };\n}\nlet f1 = new Fn();\nf1.getX(); // this -> 100\nlet ss = f1.getX;\nss(); // this -> undefined\n```\n\n## 5. call、apply和bind\n\n详情请点击：<a href=\"https://www.wwflash.top/post?title=cd045e75611f69fc06cccfd349a889cf&page=13\" target=\"_blank\">`JavaScript改变函数内部this指向`</a>\n\n## 6. 箭头函数\n\n（1）箭头函数不绑定`this`。\n\n箭头函数的`this`看外层的是否有函数，如果有，外层函数的`this`就是内部箭头函数的`this`。如果没有，则`this`是`window`。\n\n```javascript\nlet btn1 = document.getElementById('btn1');\nlet obj = {\n    name: 'kobe',\n    age: 39,\n    getName: function () {\n        btn1.onclick = () => {\n            console.log(this); // this -> obj\n        };\n    },\n};\nobj.getName();\n```\n\n（2）若上一层并不存在函数，`this`指向又是谁？\n\n```javascript\nlet btn2 = document.getElementById('btn2');\nlet obj = {\n    name: 'kobe',\n    age: 39,\n    getName: () => {\n        btn2.onclick = () => {\n            console.log(this); // this -> window\n        };\n    },\n};\nobj.getName();\n```\n\n上例中，虽然存在两个箭头函数，其实`this`取决于最外层的箭头函数，由于`obj`是个对象而非函数，所以`this`指向为`window`。\n\n（3）用`call()`或者`apply()`调用箭头函数时，无法对`this`进行绑定，即传入的第一个参数被忽略\n\n```javascript\nlet obj = {\n    birth: 1990,\n    getAge: function (year) {\n        let fn = year => year - this.birth; // this.birth -> 1990\n        return fn.call({ birth: 2000 }, year); // 第一个参数被忽略，this.birth -> 1990\n    },\n};\nconsole.log(obj.getAge(2018)); // 28\n```\n\n\n",
      "date": 1618562177000,
      "post": true,
      "tags": ["JavaScript"],
      "title": "JavaScript this指向问题详解",
      "titleEng": "this"
    }
  ],
  "requestId": "f0d6db2398d9e"
}
